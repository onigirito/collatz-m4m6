<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>collatz-m4m6 Tool Description</title>
<style>
  body { font-family: 'Yu Gothic', 'Meiryo', sans-serif; max-width: 860px; margin: 40px auto; padding: 0 20px; color: #222; line-height: 1.8; }
  h1 { border-bottom: 3px solid #2a6496; padding-bottom: 8px; }
  h2 { border-left: 4px solid #2a6496; padding-left: 12px; margin-top: 2em; }
  h3 { color: #2a6496; }
  .hero { background: linear-gradient(135deg, #1a3a5c, #2a6496); color: #fff; border-radius: 10px; padding: 24px 28px; margin: 20px 0 28px 0; }
  .hero h2 { border-left: 4px solid #fff; color: #fff; margin-top: 0; }
  .hero strong { color: #ffd966; }
  .important-box { background: #fff3cd; border: 1px solid #e0c36a; border-radius: 6px; padding: 14px 18px; margin: 16px 0; }
  .important-box .label { font-weight: bold; color: #856404; }
  .warning-box { background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 6px; padding: 14px 18px; margin: 16px 0; }
  .warning-box .label { font-weight: bold; color: #721c24; }
  .info-box { background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 6px; padding: 14px 18px; margin: 16px 0; }
  .info-box .label { font-weight: bold; color: #0c5460; }
  .checkbox-section { background: #f0f4f8; border-radius: 8px; padding: 18px 22px; margin: 20px 0; }
  .checkbox-name { font-family: monospace; font-size: 1.1em; font-weight: bold; background: #dde4ec; padding: 2px 8px; border-radius: 4px; }
  table { border-collapse: collapse; width: 100%; margin: 12px 0; }
  th, td { border: 1px solid #ccc; padding: 8px 12px; text-align: left; }
  th { background: #e9ecef; }
  code { background: #e9ecef; padding: 1px 5px; border-radius: 3px; font-size: 0.95em; }
  .tab-desc { display: flex; gap: 16px; margin: 12px 0; }
  .tab-card { flex: 1; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 14px; }
  .tab-card h4 { margin: 0 0 8px 0; color: #2a6496; }
  .record-table th { background: #2a6496; color: #fff; }
</style>
</head>
<body>

<h1>collatz-m4m6 &mdash; Collatz-Type Map Analysis Tool Based on Pair Predicate Decomposition</h1>

<!-- ============================== -->
<!-- Sweep description at the top -->
<!-- ============================== -->

<div class="hero">
<h2>What This Tool Can Do: Exhaustive Range Verification (Sweep)</h2>
<p>
Have you ever come across world records in numerical verification of the Collatz conjecture,
such as "<strong>verified up to 2<sup>68</sup></strong>"?
</p>
<p>
This does not mean that the trajectory of one specific large number was traced.
It means that <strong>for every odd number from 3 to 2<sup>68</sup> &mdash; quadrillions of them &mdash;
each trajectory was confirmed to fall below its initial value, without a single exception</strong>.
What research institutions around the world have achieved by investing computational resources
is precisely this "exhaustive verification over a range."
</p>
<p>
The <strong>Range Analysis</strong> tab of this tool provides exactly this sweep functionality.
Simply enter a start value and an end value, press "Start Verification," and
the tool will compute the stopping time for all odd numbers in that range in parallel,
determining convergence or non-convergence for every single number.
</p>
<p>
The validity of the verification is guaranteed by <strong>reproducibility</strong>.
World records work the same way: the code is published, and anyone can re-run the same computation
and cross-check the results, which serves as the basis of proof.
This tool follows the same principle &mdash; you can run the same verification on your PC and obtain the same results.
</p>
</div>

<p>
There are many computational tools for Collatz-type maps,
but the vast majority are the "enter one number and observe the trajectory" type.
<strong>Tools that provide sweep verification over a specified range of all odd numbers are limited.</strong>
</p>

<p>
Furthermore, conventional verification tools output only three items:
"number of values checked, whether all converged, and maximum stopping time."
No structural information is recorded at all.
This tool accumulates GPK statistics and carry chain length distributions simultaneously with verification,
providing structural information that approaches the "why" behind convergence.
<strong>It is the only sweep tool that records not just "what was verified" but "what happened during the verification process."</strong>
</p>

<ul>
<li><strong>Parallel processing</strong>: Multi-threading utilizes all CPU cores</li>
<li><strong>3-tier fallback</strong>: Automatic switching of u128 → U256 → packed scan ensures small numbers are processed fast while large numbers are handled reliably</li>
<li><strong>GPK statistics accumulation</strong>: GPK is tallied for all steps during the sweep, enabling large-scale observation of statistical properties of carry propagation</li>
<li><strong>Progress display and interruption</strong>: Progress bar, speed display, and stop button allow control over long-running verifications</li>
<li><strong>Automatic log saving</strong>: Verification results are automatically saved to the output/ folder and can be reviewed later in the "Analysis" tab</li>
</ul>

<h3>Sweep Results</h3>

<table class="record-table">
<tr><th>Map</th><th>Verification Range</th><th>Number of Odd Numbers Verified</th><th>Time Required</th><th>Result</th></tr>
<tr><td>3n+1</td><td>3 ~ 99,999,999,999 (&#8776;2<sup>37</sup>)</td><td>50 billion</td><td>Approx. 2 min 17 sec</td><td>All converged (max stopping time 345, n=14,500,812,391)</td></tr>
</table>

<p style="color:#666; font-size:0.9em;">
* Measured on an Intel Core i7-12650H (single desktop PC).
The current world record is on the scale of 2<sup>71</sup> (January 2025, David Barina, distributed computation on a GPU cluster).
The sweep range can be extended as far as machine performance and time allow,
and anyone can reproduce the verification in their own environment.
</p>

<!-- ============================== -->
<h2>Tool Overview</h2>

<p>
<strong>collatz-m4m6</strong> is a tool that analyzes the Collatz-type map T(n) = (xn+1)/2<sup>d</sup>
using m4/m6 pair predicate decomposition.
Without using multiplication, it executes one step of the map as carry propagation of an adder
(Kogge-Stone parallel prefix scan) and obtains the GPK classification
(Generate / Propagate / Kill) at each pair position as a byproduct of the computation.
</p>

<p>
The supported maps use all constants of the form x = 2<sup>s</sup> + 1 (x = 3, 5, 9, 17, 33, ...).
Not only 3n+1 (the standard Collatz map), but also generalized maps such as 5n+1 and 9n+1 can be analyzed.
</p>

<!-- ============================== -->
<h2>Settings (Top Bar)</h2>

<div class="checkbox-section">
<h3><span class="checkbox-name">&#9745; GPK Statistics</span> Checkbox</h3>
<p>
<strong>Toggles GPK statistics collection ON/OFF.</strong>
</p>
<p>
When ON, at each step the carry propagation of the adder is classified at each pair position as
<strong>G (Generate: carry generation)</strong>,
<strong>P (Propagate: carry propagation)</strong>, or
<strong>K (Kill: carry extinction)</strong>,
and statistics are accumulated.
In range analysis, the GPK ratio, carry chain length distribution, and G-K balance (divergence/convergence tendency) are displayed as graphs.
</p>
<p>
In pair scan (packed bit operations), GPK is obtained as a byproduct of the scan process,
so the additional cost is only <strong>about 1.3x</strong>.
On the other hand, in the u128 direct computation path, separate bit decomposition is required to obtain GPK,
resulting in a slowdown of <strong>about 20x</strong>.
</p>
<p>
For large-scale range verification where speed is a priority, turning this OFF
allows the u128 path to achieve its maximum speed (approximately 440 million nums/s).
</p>
</div>

<div class="checkbox-section">
<h3><span class="checkbox-name">&#9745; u128 Phase1</span> Checkbox</h3>
<p>
<strong>Toggles the u128 native high-speed computation path ON/OFF.</strong>
</p>
<p>
When ON (default), during range analysis, as long as the value fits within 128 bits,
xn+1 is computed directly using the CPU's native multiplication instructions (4 instructions, register-contained).
If it exceeds 128 bits, it is promoted to U256 (256-bit stack computation),
and if it overflows further, it falls back to pair predicate decomposition (packed scan).
</p>
<p>
For 3n+1 range verification, nearly all numbers complete within u128,
so <strong>ON results in approximately 84x speedup</strong>.
</p>
<p>
When OFF, all steps are executed from the start using pair predicate decomposition.
Use this for verifying pair scan behavior or for obtaining GPK statistics at low cost.
</p>
<table>
<tr><th>Condition</th><th>Speed (3n+1, 50M odd numbers)</th><th>Use Case</th></tr>
<tr><td>Phase1 ON, GPK OFF</td><td>~442M nums/s</td><td>High-speed verification of large ranges</td></tr>
<tr><td>Phase1 ON, GPK ON</td><td>~22M nums/s</td><td>Range verification with GPK statistics</td></tr>
<tr><td>Phase1 OFF, GPK OFF</td><td>~5.3M nums/s</td><td>Pair scan speed measurement</td></tr>
<tr><td>Phase1 OFF, GPK ON</td><td>~4.0M nums/s</td><td>Pair scan + GPK (low overhead as a byproduct)</td></tr>
</table>
</div>

<div class="checkbox-section">
<h3>Other Settings</h3>
<ul>
<li><strong>x =</strong> &mdash; The map constant. x-1 must be a power of 2 (3, 5, 9, 17, 33, ...). If an invalid value is entered, a red warning is displayed and execution proceeds with the last valid value.</li>
<li><strong>max_steps:</strong> &mdash; The maximum number of steps for a single number. If this value is reached without convergence, the tracking for that number is terminated.</li>
</ul>
</div>

<div class="warning-box">
<p><span class="label">&#9888; Important Note Regarding max_steps (Divergent Series Such as 5n+1)</span></p>
<p>
<strong>Maps other than 3n+1 (5n+1, 9n+1, 17n+1, etc.) are not guaranteed to converge.</strong>
For many initial values, the numbers grow without bound (diverge) and never reach a stopping time.
</p>
<p>
Setting max_steps to a large value for diverging numbers causes the bit length of the values
to grow exponentially, leading to a rapid increase in memory consumption and computation time.
For 5n+1, there are examples where the trajectory starting from 999,999,999 reaches over 3,000 digits.
</p>
<p>
<strong>Recommendation:</strong>
<ul>
<li>3n+1: max_steps = 1,000 to 10,000 (safe since all numbers converge)</li>
<li>5n+1: Start with max_steps = 1,000 or less and adjust while observing behavior</li>
<li>9n+1 and above: Explore cautiously with max_steps = 100 to 500</li>
</ul>
During range analysis, you can interrupt at any time with the "Stop" button.
</p>
</div>

<!-- ============================== -->
<h2>Feature Tabs</h2>

<div class="tab-desc">
<div class="tab-card">
<h4>Single Analysis</h4>
<p>
Performs a detailed analysis of a single odd number n using pair predicate decomposition.
</p>
<ul>
<li><strong>1 Step</strong>: Applies T(n) once and displays the GPK sequence, d value, whether exchange occurred, and carry chain length</li>
<li><strong>Trajectory Tracking</strong>: Applies repeatedly until n = 1 or the stopping time is reached, recording the entire trajectory</li>
</ul>
</div>
<div class="tab-card">
<h4>Range Analysis</h4>
<p>
Performs stopping time verification (sweep) for all odd numbers in the specified range.
You can run exhaustive verification on your PC using the same method as world records.
</p>
</div>
<div class="tab-card">
<h4>Analysis</h4>
<p>
Browse past execution logs (output/ folder) and re-display GPK graphs and carry chain length histograms.
</p>
</div>
</div>

<!-- ============================== -->
<h2>Single Analysis: 16-Predicate CSV Output</h2>

<p>
In the trajectory tracking of single analysis, results are automatically saved as a <strong>CSV file</strong>.
The following data is recorded for each step:
</p>

<table>
<tr><th>Column</th><th>Content</th></tr>
<tr><td>step, n, d, exchanged</td><td>Step number, value, number of ÷2 operations, whether m4/m6 exchange occurred</td></tr>
<tr><td>m1 ~ m16</td><td>The <strong>16 predicates</strong> (all 16 Boolean functions of pair bits) of the odd number n' as bit strings</td></tr>
<tr><td>raw_m1 ~ raw_m16</td><td>16-predicate bit strings of the even number xn+1 (before division)</td></tr>
<tr><td>gpk, G, P, K</td><td>GPK classification sequence and respective counts</td></tr>
<tr><td>max_carry_chain</td><td>Maximum carry chain length</td></tr>
</table>

<div class="info-box">
<p><span class="label">Utilizing the CSV</span></p>
<p>
Since the complete bit patterns of all 16 predicates are recorded at each step,
this is ideal for tracking a single large number to observe how the GPK ratio fluctuates step by step,
analyzing correlations between predicates,
or exploring structural laws not yet known.
The CSV can be loaded into Excel or Python (pandas) for free-form analysis.
</p>
</div>

<!-- ============================== -->
<h2>3-Tier Computation Architecture</h2>

<p>
In range analysis, three tiers of computation paths are automatically switched depending on the magnitude of the numbers.
</p>

<table>
<tr><th>Phase</th><th>Bit Width</th><th>Computation Method</th><th>Instructions/Step</th><th>Memory</th></tr>
<tr><td>Phase 1 (u128)</td><td>~128bit</td><td>CPU native multiplication</td><td>~4</td><td>Register-contained</td></tr>
<tr><td>Phase 1.5 (U256)</td><td>~256bit</td><td>Stack-allocated 4×u64 multiplication</td><td>~8</td><td>Stack-contained</td></tr>
<tr><td>Phase 2 (packed scan)</td><td>Arbitrary length</td><td>Kogge-Stone pair predicate decomposition</td><td>~25/128bit</td><td>Heap (Vec&lt;u64&gt;)</td></tr>
</table>

<p>
Phase 1 / 1.5 is controlled by the <code>u128 Phase1</code> checkbox ON/OFF.
When OFF, all steps are executed from the start using Phase 2 (pair predicate decomposition).
</p>

<!-- ============================== -->
<h2>GPK Classification and Carry Chains</h2>

<p>
In pair predicate decomposition, one step of the Collatz map xn+1 is executed as carry propagation of an adder.
The behavior of the carry at each pair position is classified as GPK:
</p>

<table>
<tr><th>Classification</th><th>Meaning</th><th>Effect on Carry</th></tr>
<tr><td><strong>G</strong> (Generate)</td><td>This pair newly generates a carry</td><td>Output carry = 1 regardless of input carry</td></tr>
<tr><td><strong>P</strong> (Propagate)</td><td>This pair propagates the input carry as-is</td><td>Output = 1 if input carry exists, = 0 otherwise</td></tr>
<tr><td><strong>K</strong> (Kill)</td><td>This pair extinguishes the carry</td><td>Output carry = 0 regardless of input carry</td></tr>
</table>

<p>
If <strong>G &gt; K</strong>, the value tends to grow (divergence direction);
if <strong>G &lt; K</strong>, it tends to shrink (convergence direction).
For 3n+1, G &#8776; 38% and K &#8776; 35%, so G &gt; K; however,
the effect of ÷2<sup>d</sup> outweighs the contribution of G, so all numbers converge.
</p>

<p>
<strong>Carry chain length</strong> indicates the length of consecutive runs of P.
When P is consecutive, the carry propagates over long distances,
affecting the upper bits of the value.
In the 2<sup>33</sup>-scale verification of 3n+1, the chain length peaked at 4-5
with a maximum of 26. Long-distance propagation is exponentially rare,
statistically demonstrating that carries tend to remain localized.
</p>

<!-- ============================== -->
<h2>Output Files</h2>

<p>All results are automatically saved to the <code>output/</code> folder in the same directory as the executable.</p>

<table>
<tr><th>Type</th><th>File Name Example</th><th>Content</th></tr>
<tr><td>Single CSV</td><td><code>gui_trace_3n1_27_s10000_gpk.csv</code></td><td>Values, d, 16 predicates, and GPK for all steps (analyzable in spreadsheets)</td></tr>
<tr><td>Single Summary</td><td><code>gui_trace_3n1_27_s10000_gpk_2026051_174112.txt</code></td><td>GPK aggregation and carry chain length histogram</td></tr>
<tr><td>Range Summary</td><td><code>gui_verify_3n1_3-9999999999_s1000_gpk_2026051_174112.txt</code></td><td>Verification results, GPK statistics, and carry chain length distribution</td></tr>
</table>

<p>
By selecting a past log file in the "Analysis" tab, you can re-display GPK graphs and carry chain length histograms.
</p>

</body>
</html>
