<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>コラッツ型写像 (xn+1)/2^d のペア述語分解と 3n+1 の構造的閉鎖性</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif;
            line-height: 1.8;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 40px 60px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2em;
            margin: 1.2em 0 0.5em 0;
            color: #1a1a1a;
            border-bottom: 3px solid #333;
            padding-bottom: 0.3em;
        }

        h2 {
            font-size: 1.6em;
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            color: #2c3e50;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0.2em;
        }

        h3 {
            font-size: 1.3em;
            margin-top: 1.2em;
            margin-bottom: 0.6em;
            color: #34495e;
        }

        h4 {
            font-size: 1.1em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            color: #555;
        }

        p {
            margin-bottom: 1em;
        }

        .title-page {
            text-align: center;
            padding: 60px 0;
            border-bottom: 3px solid #333;
            margin-bottom: 40px;
        }

        .title-page h1 {
            border: none;
            font-size: 2.5em;
            margin-bottom: 0.3em;
        }

        .title-page .subtitle {
            font-size: 1.3em;
            color: #666;
            margin-bottom: 2em;
        }

        .abstract {
            background-color: #f8f9fa;
            padding: 20px;
            border-left: 4px solid #007bff;
            margin: 20px 0;
        }

        .chapter {
            margin-bottom: 60px;
            padding-bottom: 40px;
            border-bottom: 1px dashed #ccc;
        }

        .chapter:last-child {
            border-bottom: none;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9em;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 1em;
        }

        li {
            margin-bottom: 0.5em;
        }

        hr {
            border: none;
            border-top: 1px solid #ccc;
            margin: 30px 0;
        }

        .toc {
            background-color: #f8f9fa;
            padding: 20px 30px;
            margin: 30px 0;
            border-radius: 5px;
        }

        .toc h2 {
            margin-top: 0;
            border-bottom: none;
            color: #333;
        }

        .toc ul {
            list-style-type: none;
            margin-left: 0;
        }

        .toc li {
            margin-bottom: 8px;
        }

        .toc a {
            color: #007bff;
            text-decoration: none;
        }

        .toc a:hover {
            text-decoration: underline;
        }

        strong {
            color: #d32f2f;
            font-weight: bold;
        }

        @media print {
            body {
                background-color: white;
                padding: 0;
            }
            .container {
                box-shadow: none;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title-page">
            <h1>コラッツ型写像 (xn+1)/2^d のペア述語分解と 3n+1 の構造的閉鎖性</h1>
            <div class="subtitle">Pair Predicate Decomposition of Collatz-type Maps (xn+1)/2^d<br>and the Structural Closure of 3n+1</div>
        </div>

        <div class="toc">
            <h2>目次 (Table of Contents)</h2>
            <ul>
                <li><a href="#ch1">1. Introduction（序論）</a></li>
                <li><a href="#ch2">2. Pair Predicate System（ペア述語体系）</a></li>
                <li><a href="#ch3">3. Decomposition of xn+1（xn+1 の分解）</a></li>
                <li><a href="#ch4">4. The Carry Problem（キャリー問題）</a></li>
                <li><a href="#ch5">5. The Structural Privilege of 3n+1（3n+1 の構造的特権）</a></li>
                <li><a href="#ch6">6. Division by 2 as Exchange（÷2 = 交換操作）</a></li>
                <li><a href="#ch7a">7. Unified Algorithm（前半）</a></li>
                <li><a href="#ch7b">7. Unified Algorithm（後半）</a></li>
                <li><a href="#ch8">8. Cycle Analysis（サイクル解析）</a></li>
                <li><a href="#ch9">9. Discussion（考察）</a></li>
                <li><a href="#ch10">10. Conclusion（結論）</a></li>
            </ul>
        </div>

        <div class="chapter" id="ch1">
<h1>コラッツ型写像 (xn+1)/2^d のペア述語分解と 3n+1 の構造的閉鎖性</h1>
<h1>Pair Predicate Decomposition of Collatz-type Maps (xn+1)/2^d and the Structural Closure of 3n+1</h1>

<hr>

<h2>Abstract</h2>

<p>自然数 n の2進表現を2ビットペアに分解し、左ビット列 m4 と右ビット列 m6 を基底とする16個のブール述語体系を導入する。この枠組みにおいて、コラッツ型写像 T(n) = (xn+1)/2^d の加算構造を分解し、各ペア位置でのキャリーの振る舞いを Generate/Propagate/Kill（GPK）として分類する。</p>

<p>本論文の主結果は以下の通りである。x=3 の場合、加算の上位段（m4 段）における GPK が、入力 n 自身のペア内述語——m2(AND) と m7(XOR)——に各ペア位置で一致することを示す（定理 B）。すなわち、3n+1 のキャリー構造は n の符号化から直接読み取れる。本論文ではこの性質を<strong>構造的閉鎖性</strong>と呼ぶ。一方、x≥5 ではこの一致が成立しないことを証明する（定理 C）。x≥5 の GPK は隣接ペア間の相関に依存するが、16述語は各ペア独立であるため、ペア間相関を表現できない。</p>

<p>これらの結果から、写像のキャリー構造がペア述語空間内で閉じるのは x=3 に限られることが従う（分類定理）。この閉鎖性が、3n+1 と 5n+1 の力学的性質の差異にどのように関与するかは未解決であるが、パラメータ x=3 の構造的特異性を述語体系の枠内で特徴づけた。</p>

<hr>

<h2>1. Introduction</h2>

<h3>1.1 問題の背景</h3>

<p>コラッツ予想は、任意の正整数 n に対して写像</p>

$$
n \mapsto \begin{cases} n/2 & (n \text{ が偶数}) \\ 3n+1 & (n \text{ が奇数}) \end{cases}
$$

<p>を繰り返し適用すると、有限ステップで 1 に到達するという主張である。1937年の提起以来、Erdős が「数学はまだこの種の問題に対する準備ができていない」と評したことで知られるように、初等的な定式化に反して証明は得られていない [1]。</p>

<p>本論文が着目するのは、コラッツ写像そのものの証明ではなく、より基礎的な問いである。すなわち、<strong>写像 T(n) = (xn+1)/2^d の内部構造は何か</strong>、そして<strong>パラメータ x=3 に何が特別であるか</strong>という問いである。</p>

<p>変種として 5n+1 問題がよく研究される。5n+1 は 3n+1 と異なり、1 への収束を示さず、複数の非自明なサイクルを持つことが知られている [2]。たとえば 13→33→83→13 や 27→17→43→27 といった周期軌道が存在する。この振る舞いの差異が x の値のどのような性質に起因するかは、十分に理解されていない。</p>

<h3>1.2 先行研究の位置づけ</h3>

<p>コラッツ型写像の解析には長い歴史がある。Lagarias [1] による包括的なサーベイは、この問題の広がりと困難さを概観している。Wirsching [3] は2進表現に基づく解析を発展させ、コラッツ写像の統計的性質を論じた。</p>

<p>実用上、奇数から次の奇数への遷移は Syracuse 関数</p>

$$
T(n) = \frac{3n+1}{2^{v_2(3n+1)}}
$$

<p>としてまとめられる。ここで $v_2(m)$ は $m$ の2進付値（末尾ゼロの個数）である。Syracuse 関数は偶数ステップを省略することで軌道の追跡を効率化するが、写像の内部構造には踏み込まない。3n+1 という算術演算はブラックボックスのまま実行され、結果の末尾ゼロ数もやってみなければわからない。</p>

<p>2進表現に基づくアプローチとしては、Terras [4] の停止時間解析や Everett [5] の2進数操作による記述があるが、いずれも乗算 3×n を算術的に実行することを前提としている。</p>

<h3>1.3 本論文のアプローチ</h3>

<p>本論文は、自然数を算術対象ではなく<strong>情報構造</strong>として扱う。</p>

<p>具体的には、自然数 n の2進表現を2ビット幅のペア列に分解し、各ペア (aᵢ, bᵢ) に対して定義される16個のブール述語からなる体系を導入する。この体系を本論文で定義し、コラッツ型写像の解析に応用する。</p>

<p>16述語のうち、m4（各ペアの左ビット列）と m6（各ペアの右ビット列）が基底をなし、残りの14述語は m4 と m6 のビットごとの論理演算で導出される。この基底分解の下で、xn+1 の演算は以下のように記述される。</p>

<p>xn+1 = (x-1)n + n + 1 と分解すると、(x-1)n は n のビット列の左シフトに対応する。シフト量 s = log₂(x-1) の値が、m4/m6 のどのビット位置を参照するかを決定する。この参照パターンに基づいて、各ペア位置での加算がビット論理演算（AND, XOR と carry 伝播）に分解される。</p>

<p>核心的な発見は、x=3 の場合にシフト量が1ビットとなり、加算の一方の段（m4 段）の入力が n のペア (aᵢ, bᵢ) そのものに一致することである。これにより、キャリーの生成（Generate）と伝播（Propagate）の位置が n のペア内述語 m2 = AND(aᵢ, bᵢ) および m7 = XOR(aᵢ, bᵢ) として直接読み取れる。</p>

<p>x=5 以上ではこの縮退が起こらず、隣接ペア間の参照が必要となる。この差異は16述語の本質的性質——各ペア独立性——から生じるものであり、784通りの述語組み合わせを網羅的に検証することで確認される。</p>

<h3>1.4 主結果</h3>

<p>本論文の主要な結果を以下に要約する。</p>

<strong>定理 A（統一アルゴリズム）.</strong> 任意の奇数 n と xn+1 型パラメータ x に対して、次の奇数 n' = T(n) は m4/m6 の O(k) ビット走査によって計算可能である。ここで k = ⌈log₂(n)⌉/2 はペア数であり、乗算 xn は参照添字のシフトとペア内1ビット加算に分解される。

<strong>定理 B（3n+1 の構造的特権）.</strong> 3n+1 の m4 段キャリー構造において、Generate の位置集合は m2(AND) に、Propagate の位置集合は m7(XOR) に、各ペア位置で一致する。

<strong>定理 C（16述語の限界）.</strong> x ≥ 5 に対する xn+1 の全体キャリー構造 (G, P) は、n の16述語 m1〜m16 の任意の2つの AND, OR, XOR 組み合わせでは表現できない。

<p>定理 B と C を合わせると、x=3 は16述語の完備空間内で写像のキャリー構造が閉じる<strong>唯一の</strong>パラメータであることが示される。</p>

<h3>1.5 論文の構成</h3>

<p>第2節でペア述語体系の定義と基底の性質を与える。第3節で xn+1 のペア加算への分解を導出し、参照パターンの x 依存性を示す。第4節でキャリー問題を定式化し、走査による解決を示す。第5節で3n+1 の構造的特権を証明し、16述語の限界定理を与える。第6節で ÷2 操作の m4⇔m6 交換原理を論じる。第7節で統一アルゴリズムを定式化し、計算量を評価する。第8節でサイクル解析への応用を示す。第9節で考察と未解決問題を論じ、第10節で結論を述べる。</p>

<h3>References（本節で引用）</h3>

<p>[1] J. C. Lagarias, "The 3x+1 problem and its generalizations," American Mathematical Monthly, vol. 92, no. 1, pp. 3–23, 1985.</p>

<p>[2] R. K. Guy, Unsolved Problems in Number Theory, 3rd ed. Springer, 2004.</p>

<p>[3] G. J. Wirsching, The Dynamical System Generated by the 3n+1 Function. Springer Lecture Notes in Mathematics 1681, 1998.</p>

<p>[4] R. Terras, "A stopping time problem on the positive integers," Acta Arithmetica, vol. 30, pp. 241–252, 1976.</p>

<p>[5] C. J. Everett, "Iteration of the number-theoretic function f(2n)=n, f(2n+1)=3n+2," Advances in Mathematics, vol. 25, pp. 42–45, 1977.</p>

        </div>

        <div class="chapter" id="ch2">
<h1>2. Pair Predicate System（ペア述語体系）</h1>

<p>本節では、自然数の2ビットペア分解と、その上に定義される16個のブール述語体系を厳密に定義する。m4 と m6 が基底をなすことを示し、体系の完備性と各ペア独立性を確認する。</p>

<hr>

<h2>2.1 2ビットペア分解</h2>

<strong>定義 2.1（偶数桁パディング）.</strong> 正の整数 n に対して、その2進表現を $\beta(n) = d<em>{L-1} d</em>{L-2} \cdots d<em>1 d</em>0$ と書く。ここで $d<em>{L-1} = 1$（最上位ビット）、$L = \lfloor \log</em>2 n \rfloor + 1$ である。$L$ が奇数のとき、先頭にゼロを1つ付加して偶数桁とする：

$$
\hat{\beta}(n) = \begin{cases} \beta(n) & (L \text{ が偶数}) \\ 0\beta(n) & (L \text{ が奇数}) \end{cases}
$$

<p>パディング後の桁数を $2k$ と書く。$k = \lceil L/2 \rceil$ がペア数である。</p>

<strong>定義 2.2（ペア列）.</strong> パディング済み2進表現 $\hat{\beta}(n) = s<em>1 s</em>2 \cdots s_{2k}$ を、左から順に2ビットずつ組にしてペア列を定義する：

$$
P(n) = ((a<em>0, b</em>0),\, (a<em>1, b</em>1),\, \ldots,\, (a<em>{k-1}, b</em>{k-1}))
$$

<p>ここで $a<em>i = s</em>{2i+1}$、$b<em>i = s</em>{2i+2}$（1-indexed）である。すなわち各ペアの左ビットが $a<em>i$、右ビットが $b</em>i$ である。</p>

<strong>例 2.1.</strong> $n = 27 = 11011_2$ → パディング: $011011$ → ペア列: $((0,1),\,(1,0),\,(1,1))$。ペア数 $k=3$。

<strong>例 2.2.</strong> $n = 17 = 10001_2$ → パディング: $010001$ → ペア列: $((0,1),\,(0,0),\,(0,1))$。ペア数 $k=3$。

<strong>定義 2.3（ファスナー構造と復元）.</strong> ペア列 $P(n)$ から元の2進表現を復元するには、左ビットと右ビットを交互に並べる：

$$
\hat{\beta}(n) = a<em>0\, b</em>0\, a<em>1\, b</em>1\, \cdots\, a<em>{k-1}\, b</em>{k-1}
$$

<p>この交互配置をファスナー（zipper）構造と呼ぶ。復元は一意的であり、パディングの先頭ゼロを除去して $n$ が一意に定まる。</p>

<hr>

<h2>2.2 m4 と m6 の定義</h2>

<strong>定義 2.4（射影 m4, m6）.</strong> 正整数 n のペア列 $P(n) = ((a<em>0, b</em>0), \ldots, (a<em>{k-1}, b</em>{k-1}))$ に対して、2つのビット列を定義する：

$$
\text{m4}(n) = (a<em>0, a</em>1, \ldots, a_{k-1})
$$
$$
\text{m6}(n) = (b<em>0, b</em>1, \ldots, b_{k-1})
$$

<p>m4 は各ペアの左ビット列（LEFT projection）、m6 は各ペアの右ビット列（RIGHT projection）である。</p>

<strong>命題 2.1（復元性）.</strong> m4(n) と m6(n) の組から n は一意に復元される。

<em>証明.</em> ファスナー構造により $\hat{\beta}(n)$ が復元され、先頭ゼロの除去で $n$ が一意に定まる。 □

<strong>例 2.3.</strong> $n=27$: m4 = $(0,1,1)$, m6 = $(1,0,1)$。ファスナー: $0\,1\,1\,0\,1\,1 = 011011_2 = 27$。✓

<hr>

<h2>2.3 16述語の定義</h2>

<p>2入力ブール関数は $2^{2^2} = 16$ 個存在し、完備な体系をなす。各ペア $(a<em>i, b</em>i)$ に対して、以下の16述語 m1〜m16 を定義する。</p>

<strong>定義 2.5（16述語）.</strong>

<table>
<tr><th>述語</th><th>名称</th><th>定義 $f(a,b)$</th><th>真理値 (0,0)(0,1)(1,0)(1,1)</th></tr>
<tr><td>m1</td><td>FALSE</td><td>0</td><td>0 0 0 0</td></tr>
<tr><td>m2</td><td>AND</td><td>$a \wedge b$</td><td>0 0 0 1</td></tr>
<tr><td>m3</td><td>L>R</td><td>$a \wedge \neg b$</td><td>0 0 1 0</td></tr>
<tr><td>m4</td><td>LEFT</td><td>$a$</td><td>0 0 1 1</td></tr>
<tr><td>m5</td><td>R>L</td><td>$\neg a \wedge b$</td><td>0 1 0 0</td></tr>
<tr><td>m6</td><td>RIGHT</td><td>$b$</td><td>0 1 0 1</td></tr>
<tr><td>m7</td><td>XOR</td><td>$a \oplus b$</td><td>0 1 1 0</td></tr>
<tr><td>m8</td><td>OR</td><td>$a \vee b$</td><td>0 1 1 1</td></tr>
<tr><td>m9</td><td>NOR</td><td>$\neg a \wedge \neg b$</td><td>1 0 0 0</td></tr>
<tr><td>m10</td><td>XNOR</td><td>$\neg(a \oplus b)$</td><td>1 0 0 1</td></tr>
<tr><td>m11</td><td>NOT_R</td><td>$\neg b$</td><td>1 0 1 0</td></tr>
<tr><td>m12</td><td>R→L</td><td>$a \vee \neg b$</td><td>1 0 1 1</td></tr>
<tr><td>m13</td><td>NOT_L</td><td>$\neg a$</td><td>1 1 0 0</td></tr>
<tr><td>m14</td><td>L→R</td><td>$\neg a \vee b$</td><td>1 1 0 1</td></tr>
<tr><td>m15</td><td>NAND</td><td>$\neg(a \wedge b)$</td><td>1 1 1 0</td></tr>
<tr><td>m16</td><td>TRUE</td><td>1</td><td>1 1 1 1</td></tr>
</table>

<p>各述語は n のペア列に対してビットごとに適用される：</p>

$$
\text{m}<em>j(n) = (f</em>j(a<em>0, b</em>0),\, f<em>j(a</em>1, b<em>1),\, \ldots,\, f</em>j(a<em>{k-1}, b</em>{k-1}))
$$

<hr>

<h2>2.4 基底定理</h2>

<strong>定理 2.1（m4/m6 基底）.</strong> 16述語 m1〜m16 は全て、m4 と m6 のビットごとの論理演算で表現される。

<em>証明.</em> 各述語の表現を直接与える：

<table>
<tr><th>述語</th><th>m4/m6 による表現</th></tr>
<tr><td>m1</td><td>$\mathbf{0}$（定数零）</td></tr>
<tr><td>m2</td><td>m4 AND m6</td></tr>
<tr><td>m3</td><td>m4 AND (NOT m6)</td></tr>
<tr><td>m4</td><td>m4（基底）</td></tr>
<tr><td>m5</td><td>(NOT m4) AND m6</td></tr>
<tr><td>m6</td><td>m6（基底）</td></tr>
<tr><td>m7</td><td>m4 XOR m6</td></tr>
<tr><td>m8</td><td>m4 OR m6</td></tr>
<tr><td>m9</td><td>(NOT m4) AND (NOT m6)</td></tr>
<tr><td>m10</td><td>NOT (m4 XOR m6)</td></tr>
<tr><td>m11</td><td>NOT m6</td></tr>
<tr><td>m12</td><td>m4 OR (NOT m6)</td></tr>
<tr><td>m13</td><td>NOT m4</td></tr>
<tr><td>m14</td><td>(NOT m4) OR m6</td></tr>
<tr><td>m15</td><td>NOT (m4 AND m6)</td></tr>
<tr><td>m16</td><td>$\mathbf{1}$（定数壱）</td></tr>
</table>

<p>全ての演算はビットごとに適用される。 □</p>

<strong>注意 2.1.</strong> 基底の選択は一意ではない。たとえば m2(AND) と m7(XOR) の組からも全述語を導出できる（m4 = m2 OR m3, m6 = m2 OR m5 など）。しかし m4/m6 は n の数値情報を直接保持しており、追加の演算なしにファスナー構造のみで n を復元できる唯一の基底対である（直接復元性）。他の基底対からも n の復元は可能である——たとえば補数対 (m13, m11) = (¬a, ¬b) からはビット反転により、(m13, m6) = (¬a, b) からは左ビットの反転により復元できる——が、いずれも追加の論理演算を要する。

<hr>

<h2>2.5 各ペア独立性</h2>

<strong>定義 2.6（各ペア独立性）.</strong> 関数 $g: \{0,1\}^{2k} \to \{0,1\}^k$ が各ペア独立であるとは、出力の第 $i$ 成分が入力の第 $i$ ペア $(a<em>i, b</em>i)$ のみに依存することをいう：

$$
g(n)<em>i = h(a</em>i, b_i) \quad \text{（ある $h: \{0,1\}^2 \to \{0,1\}$ が存在）}
$$

<strong>命題 2.2.</strong> 16述語 m1〜m16 は全て各ペア独立である。

<em>証明.</em> 定義 2.5 より、各 $f<em>j(a</em>i, b<em>i)$ は $(a</em>i, b_i)$ のみの関数である。 □

<strong>命題 2.3（閉包性）.</strong> 各ペア独立な関数のビットごとの AND, OR, XOR, NOT による合成は、再び各ペア独立である。

<em>証明.</em> $g<em>1(n)</em>i = h<em>1(a</em>i, b<em>i)$, $g</em>2(n)<em>i = h</em>2(a<em>i, b</em>i)$ とすると、$(g<em>1 \text{ AND } g</em>2)(n)<em>i = h</em>1(a<em>i, b</em>i) \wedge h<em>2(a</em>i, b<em>i)$ は $(a</em>i, b_i)$ のみの関数。他の演算も同様。 □

<strong>系 2.1.</strong> m1〜m16 の任意のブール合成は各ペア独立であり、位置 $i$ と位置 $j$（$i \neq j$）の間の相関を表現できない。

<p>この性質は第5節において、5n+1 のキャリー構造が16述語では記述不可能であることの証明に本質的に用いられる。</p>

<hr>

<h2>2.6 補数対の構造</h2>

<p>16述語には自然な対称性が存在する。</p>

<strong>定義 2.7（補数対）.</strong> 述語 $m<em>j$ と $m</em>{17-j}$ を補数対と呼ぶ。これらは $m<em>j(a,b) + m</em>{17-j}(a,b) = 1$ を満たす。

<table>
<tr><th>対</th><th>述語</th><th>補数</th><th>関係</th></tr>
<tr><td>1</td><td>m1 (FALSE)</td><td>m16 (TRUE)</td><td>定数対</td></tr>
<tr><td>2</td><td>m2 (AND)</td><td>m15 (NAND)</td><td>論理対</td></tr>
<tr><td>3</td><td>m3 (L>R)</td><td>m14 (L→R)</td><td>含意対</td></tr>
<tr><td>4</td><td>m4 (LEFT)</td><td>m13 (NOT_L)</td><td>射影対</td></tr>
<tr><td>5</td><td>m5 (R>L)</td><td>m12 (R→L)</td><td>含意対</td></tr>
<tr><td>6</td><td>m6 (RIGHT)</td><td>m11 (NOT_R)</td><td>射影対</td></tr>
<tr><td>7</td><td>m7 (XOR)</td><td>m10 (XNOR)</td><td>排他対</td></tr>
<tr><td>8</td><td>m8 (OR)</td><td>m9 (NOR)</td><td>論理対</td></tr>
</table>

<p>この対称性から、任意の述語についての結果は直ちに補数述語に翻訳される。</p>

<strong>命題 2.4.</strong> $\text{m}<em>j(n) = \neg\, \text{m}</em>{17-j}(n)$ が全ての $n$ について成立する。

<em>証明.</em> 真理値表の各行で $f<em>j(a,b) + f</em>{17-j}(a,b) = 1$ を確認すればよい。 □

<hr>

<h2>2.7 本節のまとめ</h2>

<p>本節で確立した事項：</p>

<p>1. 自然数 n は2ビットペア列 $P(n)$ に一意的に分解され、m4（左ビット列）と m6（右ビット列）から完全に復元される。</p>

<p>2. ペア $(a<em>i, b</em>i)$ 上の2入力ブール関数は16個で完備であり、全て m4 と m6 のビットごと演算で表現される。</p>

<p>3. 16述語は全て各ペア独立であり、この性質はブール合成で保存される。したがって、16述語の枠内では異なるペア位置間の相関を記述できない。</p>

<p>4. 16述語は8組の補数対をなし、述語番号 $j$ と $17-j$ が対応する。</p>

<p>第3節では、この述語体系の上で xn+1 型写像がどのように記述されるかを導出する。</p>
        </div>

        <div class="chapter" id="ch3">
<h1>3. Decomposition of xn+1（xn+1 の分解）</h1>

<p>本節では、コラッツ型写像 xn+1 をペア加算に分解する。シフト量 s = log₂(x-1) がペア構造上の参照パターンを決定することを示し、x=3 と x=5 の場合を詳細に導出する。</p>

<hr>

<h2>3.1 分解原理</h2>

<strong>命題 3.1（加法分解）.</strong> 正奇数 n とパラメータ x に対して：

$$
xn + 1 = (x-1)n + n + 1
$$

<p>$(x-1)n$ は $n$ の2進表現の左シフトに対応する。</p>

<em>証明.</em> $x-1$ が2の冪であるとき、$(x-1)n = 2^s n$ は $n$ の $s$ ビット左シフトそのものである。本論文では $x \in \{3, 5, 9, 17, \ldots\}$（$x-1$ が2の冪）の場合を扱う。 □

<strong>注意 3.1.</strong> $x-1$ が2の冪でない場合（$x=7$ で $x-1=6=2 \cdot 3$ など）は、シフトだけでなく追加の加算が生じる。本論文の枠組みは原理的に拡張可能であるが、記述の明晰さのため $x-1 = 2^s$ の場合に焦点を当てる。$x=3$（$s=1$）と $x=5$（$s=2$）が主要な対象となる。

<hr>

<h2>3.2 シフトとペア構造の関係</h2>

<p>n のペア列を $P(n) = ((a<em>0, b</em>0), \ldots, (a<em>{k-1}, b</em>{k-1}))$ とし、対応する2進表現を</p>

$$
\hat{\beta}(n) = a<em>0\, b</em>0\, a<em>1\, b</em>1\, \cdots\, a<em>{k-1}\, b</em>{k-1}
$$

<p>と書く。$2^s n$ の2進表現は末尾に $s$ 個のゼロが付加される。</p>

<strong>s=2 の場合（x=5, 4n）：</strong>

$$
\hat{\beta}(4n) = a<em>0\, b</em>0\, a<em>1\, b</em>1\, \cdots\, a<em>{k-1}\, b</em>{k-1}\, 0\, 0
$$

<p>これをペアに分解すると：</p>

$$
P(4n) = ((a<em>0, b</em>0),\, (a<em>1, b</em>1),\, \ldots,\, (a<em>{k-1}, b</em>{k-1}),\, (0, 0))
$$

<p>すなわち、n のペア列の末尾にゼロペア $(0,0)$ が付加される。<strong>ペア境界は保存される。</strong></p>

$$
\text{m4}(4n) = (a<em>0, a</em>1, \ldots, a_{k-1}, 0) = \text{m4}(n) \| 0
$$
$$
\text{m6}(4n) = (b<em>0, b</em>1, \ldots, b_{k-1}, 0) = \text{m6}(n) \| 0
$$

<p>ここで $\|$ はビット列の連結を表す。</p>

<strong>s=1 の場合（x=3, 2n）：</strong>

$$
\hat{\beta}(2n) = a<em>0\, b</em>0\, a<em>1\, b</em>1\, \cdots\, a<em>{k-1}\, b</em>{k-1}\, 0
$$

<p>桁数が奇数になるため、先頭にゼロを付加して偶数桁とする：</p>

$$
\hat{\beta}(2n)<em>{\text{padded}} = 0\, a</em>0\, b<em>0\, a</em>1\, b<em>1\, \cdots\, a</em>{k-1}\, b_{k-1}\, 0
$$

<p>ペアに分解すると：</p>

$$
P(2n) = ((0, a<em>0),\, (b</em>0, a<em>1),\, (b</em>1, a<em>2),\, \ldots,\, (b</em>{k-1}, 0))
$$

<strong>ペア境界が1ビットずれる。</strong> この結果：

$$
\text{m4}(2n) = (0, b<em>0, b</em>1, \ldots, b_{k-1}) = 0 \| \text{m6}(n)
$$
$$
\text{m6}(2n) = (a<em>0, a</em>1, \ldots, a_{k-1}, 0) = \text{m4}(n) \| 0
$$

<strong>命題 3.2（2n の m4/m6 交差）.</strong> $\text{m4}(2n)$ は $\text{m6}(n)$ の先頭にゼロを付加したものに等しく、$\text{m6}(2n)$ は $\text{m4}(n)$ の末尾にゼロを付加したものに等しい。すなわち、2n 操作は m4 と m6 の役割を交換する。

<hr>

<h2>3.3 ペア加算の定式化</h2>

<p>$xn + 1 = 2^s n + n + 1$ をペア列の加算として記述する。以下では LSB（最下位ペア）からの順序を用いる。n のペア列を LSB 順で $(a<em>0^L, b</em>0^L), (a<em>1^L, b</em>1^L), \ldots$ と書く。混乱を避けるため、以下 $a<em>i, b</em>i$ は LSB 順のペア $i$ の左右ビットを表す。</p>

<p>ペア位置 $i$ において、$n$ の寄与は $(a<em>i, b</em>i)$、$2^s n$ の寄与はシフト量に応じて定まる。加算は各ペア位置で右ビット（m6）と左ビット（m4）の2段で行われる。</p>

<strong>定義 3.1（ペア加算の2段構造）.</strong> ペア位置 $i$ での加算を以下の2段で定義する。

<strong>m6 段（右ビット）：</strong>
$$
\text{sum\<em>R}</em>i = r<em>i^{(6)} + b</em>i + c_{\text{in},i}
$$

<p>ここで $r<em>i^{(6)}$ は $2^s n$ のペア位置 $i$ の右ビット、$c</em>{\text{in},i}$ はペア $i$ への入力キャリーである。</p>

$$
\text{新m6}<em>i = \text{sum\</em>R}_i \mod 2
$$
$$
c<em>{\text{mid},i} = \lfloor \text{sum\</em>R}_i / 2 \rfloor
$$

<strong>m4 段（左ビット）：</strong>
$$
\text{sum\<em>L}</em>i = r<em>i^{(4)} + a</em>i + c_{\text{mid},i}
$$

<p>ここで $r_i^{(4)}$ は $2^s n$ のペア位置 $i$ の左ビット。</p>

$$
\text{新m4}<em>i = \text{sum\</em>L}_i \mod 2
$$
$$
c<em>{\text{out},i} = \lfloor \text{sum\</em>L}_i / 2 \rfloor
$$

<strong>キャリー伝播：</strong> $c<em>{\text{in},0} = 1$（$+1$ の効果）、$c</em>{\text{in},i+1} = c_{\text{out},i}$。

<hr>

<h2>3.4 x=5 の参照パターン</h2>

<p>$5n+1 = 4n + n + 1$ において、$4n$ は1ペア分のシフトであるから（§3.2）：</p>

$$
2^s n \text{ のペア位置 } i \text{ の値} = n \text{ のペア位置 } (i-1) \text{ の値}
$$

<p>すなわち $r<em>i^{(4)} = a</em>{i-1}$、$r<em>i^{(6)} = b</em>{i-1}$（ただし $a<em>{-1} = b</em>{-1} = 0$）。</p>

<strong>命題 3.3（5n+1 の参照パターン）.</strong> $5n+1$ のペア加算において：

$$
\text{m6 段入力}: (b<em>{i-1},\, b</em>i) \quad \text{— m6 の隣接ビット同士}
$$
$$
\text{m4 段入力}: (a<em>{i-1},\, a</em>i) \quad \text{— m4 の隣接ビット同士}
$$

<em>証明.</em> $r<em>i^{(6)} = b</em>{i-1}$ を m6 段に代入すると $\text{sum\<em>R}</em>i = b<em>{i-1} + b</em>i + c<em>{\text{in},i}$。$r</em>i^{(4)} = a<em>{i-1}$ を m4 段に代入すると $\text{sum\</em>L}<em>i = a</em>{i-1} + a<em>i + c</em>{\text{mid},i}$。 □

<strong>注意 3.2.</strong> 5n+1 では m6 段も m4 段も同型の参照パターン（隣接同型参照）を持つ。これは $s=2$ が偶数であることに起因する（§3.6 で一般化）。

<hr>

<h2>3.5 x=3 の参照パターン</h2>

<p>$3n+1 = 2n + n + 1$ において、$2n$ は1ビットシフトである。§3.2 より：</p>

$$
\text{m4}(2n)<em>i = \begin{cases} 0 & (i=0) \\ b</em>{i-1} & (i \geq 1) \end{cases}
\qquad
\text{m6}(2n)<em>i = \begin{cases} a</em>i & (i < k) \\ 0 & (i = k) \end{cases}
$$

<p>ここでの添字は LSB 順である。すなわち $r<em>i^{(6)} = a</em>{i-1}$（m4 が m6 側に来る）、$r<em>i^{(4)} = b</em>i$（m6 が m4 側に来る）。</p>

<p>ただし、1ビットシフトによるペア境界のずれを正確に追跡すると、LSB 側のペア位置 $i$ に対して：</p>

$$
r<em>i^{(6)} = a</em>{i-1} \quad (a_{-1} = 0)
$$
$$
r<em>i^{(4)} = b</em>i
$$

<strong>命題 3.4（3n+1 の参照パターン）.</strong> $3n+1$ のペア加算において：

$$
\text{m6 段入力}: (a<em>{i-1},\, b</em>i) \quad \text{— m4 前ペアと m6 現ペアの交差}
$$
$$
\text{m4 段入力}: (b<em>i,\, a</em>i) = (a<em>i,\, b</em>i) \quad \text{— 現ペア内（順序は加算の可換性で同一）}
$$

<em>証明.</em> $r<em>i^{(6)} = a</em>{i-1}$ を m6 段に代入すると $\text{sum\<em>R}</em>i = a<em>{i-1} + b</em>i + c<em>{\text{in},i}$。$r</em>i^{(4)} = b<em>i$ を m4 段に代入すると $\text{sum\</em>L}<em>i = b</em>i + a<em>i + c</em>{\text{mid},i} = a<em>i + b</em>i + c_{\text{mid},i}$。 □

<strong>核心的観察.</strong> m4 段の入力 $(a<em>i, b</em>i)$ は n のペア $i$ そのものである。この一致が第5節の定理 B の基礎となる。

<hr>

<h2>3.6 一般の参照パターン</h2>

<p>シフト量 $s$ の偶奇によって参照パターンの構造が質的に異なる。</p>

<strong>命題 3.5（参照パターンの分類）.</strong> $x - 1 = 2^s$ のとき、$xn+1$ のペア加算における参照パターンは以下のように分類される。

<strong>$s$ が偶数のとき（$s = 2t$）：</strong> シフトは $t$ ペア分に相当し、ペア境界が保存される。

$$
r<em>i^{(4)} = a</em>{i-t}, \quad r<em>i^{(6)} = b</em>{i-t}
$$

<p>m6 段は m6 同士、m4 段は m4 同士の参照（<strong>同型参照</strong>）。</p>

<strong>$s$ が奇数のとき（$s = 2t+1$）：</strong> シフトは $t$ ペア $+$ 1ビットであり、ペア境界が1ビットずれる。

$$
r<em>i^{(4)} = b</em>{i-t-1}, \quad r<em>i^{(6)} = a</em>{i-t}
$$

<p>m6 段は m4 由来、m4 段は m6 由来の参照（<strong>交差参照</strong>）。ただし $i-t$ ペアと $i$ ペアの距離が $t$ のため、$t > 0$ では隣接ペア間にも跨る。</p>

<em>証明.</em> $2^s n$ の2進表現は $n$ の末尾に $s$ 個のゼロを付加したものである。$s = 2t$ のとき、$t$ ペア分のゼロが付加されペア境界は保存される。$s = 2t+1$ のとき、$t$ ペア $+$ 1ビットの付加により先頭1ビットのパディングが生じ、ペア境界が1ビットずれる。各場合の m4/m6 の対応は §3.2 の議論を一般化すればよい。 □

<strong>表 3.1: 主要な参照パターン.</strong>

<table>
<tr><th>$x$</th><th>$s$</th><th>ペアシフト</th><th>境界</th><th>m6 段入力</th><th>m4 段入力</th><th>参照型</th></tr>
<tr><td>3</td><td>1</td><td>0+1bit</td><td>ずれる</td><td>$(a<em>{i-1},\, b</em>i)$</td><td>$(a<em>i,\, b</em>i)$</td><td>交差+ペア内</td></tr>
<tr><td>5</td><td>2</td><td>1ペア</td><td>保存</td><td>$(b<em>{i-1},\, b</em>i)$</td><td>$(a<em>{i-1},\, a</em>i)$</td><td>同型隣接</td></tr>
<tr><td>9</td><td>3</td><td>1+1bit</td><td>ずれる</td><td>$(a<em>{i-2},\, b</em>i)$</td><td>$(a<em>i,\, b</em>{i-1})$</td><td>交差+遠距離</td></tr>
<tr><td>17</td><td>4</td><td>2ペア</td><td>保存</td><td>$(b<em>{i-2},\, b</em>i)$</td><td>$(a<em>{i-2},\, a</em>i)$</td><td>同型遠距離</td></tr>
</table>

<hr>

<h2>3.7 具体例：n=27 における 5n+1</h2>

<p>$n=27$: m4 = $(0,1,1)$, m6 = $(1,0,1)$。LSB 順: $a = (1,1,0)$, $b = (1,0,1)$。</p>

<strong>ペア 0（LSB, $i=0$）：</strong>
$$
\text{m6 段}: b<em>{-1} + b</em>0 + c<em>{\text{in}} = 0 + 1 + 1 = 2 \Rightarrow \text{新m6}</em>0 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4 段}: a<em>{-1} + a</em>0 + c<em>{\text{mid}} = 0 + 1 + 1 = 2 \Rightarrow \text{新m4}</em>0 = 0,\; c_{\text{out}} = 1
$$

<strong>ペア 1（$i=1$）：</strong>
$$
\text{m6 段}: b<em>0 + b</em>1 + 1 = 1 + 0 + 1 = 2 \Rightarrow \text{新m6}<em>1 = 0,\; c</em>{\text{mid}} = 1
$$
$$
\text{m4 段}: a<em>0 + a</em>1 + 1 = 1 + 1 + 1 = 3 \Rightarrow \text{新m4}<em>1 = 1,\; c</em>{\text{out}} = 1
$$

<strong>ペア 2（$i=2$）：</strong>
$$
\text{m6 段}: b<em>1 + b</em>2 + 1 = 0 + 1 + 1 = 2 \Rightarrow \text{新m6}<em>2 = 0,\; c</em>{\text{mid}} = 1
$$
$$
\text{m4 段}: a<em>1 + a</em>2 + 1 = 1 + 0 + 1 = 2 \Rightarrow \text{新m4}<em>2 = 0,\; c</em>{\text{out}} = 1
$$

<strong>オーバーフローペア（$i=3$）：</strong>
$$
\text{m6 段}: b<em>2 + 0 + 1 = 1 + 0 + 1 = 2 \Rightarrow \text{新m6}</em>3 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4 段}: a<em>2 + 0 + 1 = 0 + 0 + 1 = 1 \Rightarrow \text{新m4}</em>3 = 1,\; c_{\text{out}} = 0
$$

<p>結果（LSB 順）: $((0,0),\,(1,0),\,(0,0),\,(1,0))$ → MSB 順: $((1,0),\,(0,0),\,(1,0),\,(0,0))$</p>

$$
5 \times 27 + 1 = 136 = 10001000_2 \quad \checkmark
$$

<hr>

<h2>3.8 具体例：n=27 における 3n+1</h2>

<p>同じ $n=27$: m4 = $(0,1,1)$, m6 = $(1,0,1)$。LSB 順: $a = (1,1,0)$, $b = (1,0,1)$。</p>

<strong>ペア 0（$i=0$）：</strong>
$$
\text{m6 段}: a<em>{-1} + b</em>0 + c<em>{\text{in}} = 0 + 1 + 1 = 2 \Rightarrow \text{新m6}</em>0 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4 段}: a<em>0 + b</em>0 + c<em>{\text{mid}} = 1 + 1 + 1 = 3 \Rightarrow \text{新m4}</em>0 = 1,\; c_{\text{out}} = 1
$$

<strong>ペア 1（$i=1$）：</strong>
$$
\text{m6 段}: a<em>0 + b</em>1 + 1 = 1 + 0 + 1 = 2 \Rightarrow \text{新m6}<em>1 = 0,\; c</em>{\text{mid}} = 1
$$
$$
\text{m4 段}: a<em>1 + b</em>1 + 1 = 1 + 0 + 1 = 2 \Rightarrow \text{新m4}<em>1 = 0,\; c</em>{\text{out}} = 1
$$

<strong>ペア 2（$i=2$）：</strong>
$$
\text{m6 段}: a<em>1 + b</em>2 + 1 = 1 + 1 + 1 = 3 \Rightarrow \text{新m6}<em>2 = 1,\; c</em>{\text{mid}} = 1
$$
$$
\text{m4 段}: a<em>2 + b</em>2 + 1 = 0 + 1 + 1 = 2 \Rightarrow \text{新m4}<em>2 = 0,\; c</em>{\text{out}} = 1
$$

<strong>オーバーフローペア（$i=3$）：</strong>
$$
\text{m6 段}: a<em>2 + 0 + 1 = 0 + 0 + 1 = 1 \Rightarrow \text{新m6}</em>3 = 1,\; c_{\text{mid}} = 0
$$
$$
\text{m4 段}: 0 + 0 + 0 = 0 \Rightarrow \text{新m4}<em>3 = 0,\; c</em>{\text{out}} = 0
$$

<p>結果（LSB 順）: $((1,0),\,(0,0),\,(0,1),\,(0,1))$ → MSB 順: $((0,1),\,(0,1),\,(0,0),\,(1,0))$</p>

$$
3 \times 27 + 1 = 82 = 01010010_2 \quad \checkmark
$$

<hr>

<h2>3.9 本節のまとめ</h2>

<p>本節で確立した事項：</p>

<p>1. $xn+1 = (x-1)n + n + 1$ と分解したとき、$(x-1)n$ は $s = \log_2(x-1)$ ビットの左シフトであり、シフト量の偶奇がペア境界の保存/シフトを決定する。</p>

<p>2. ペア位置 $i$ での加算は m6 段と m4 段の2段構造をとり、各段の入力は n の m4/m6 ビットへの参照で記述される。</p>

<p>3. $x=5$（$s=2$, 偶数）では m6 同士・m4 同士の同型隣接参照。$x=3$（$s=1$, 奇数）では m4→m6・m6→m4 の交差参照が生じ、特に m4 段の入力が現ペア $(a<em>i, b</em>i)$ そのものに一致する。</p>

<p>4. 乗算 $xn$ は明示的に実行されない。$(x-1)n$ のシフトは参照添字のずれとして吸収され、全ての操作はビット参照と1ビット加算（carry 伝播）に分解される。</p>

<p>次節では、キャリー伝播の構造を定式化し、走査による解決を示す。</p>
        </div>

        <div class="chapter" id="ch4">
<h1>4. The Carry Problem and Its Resolution（キャリー問題とその解決）</h1>

<p>前節でペア加算の2段構造を導出した。本節では、キャリー伝播の構造を定式化し、これが逐次走査で解決可能であること、さらに並列化が可能であることを示す。</p>

<hr>

<h2>4.1 問題の所在</h2>

<p>ペア位置 $i$ の出力は、入力キャリー $c<em>{\text{in},i}$ に依存する。$c</em>{\text{in},i}$ はペア $i-1$ の出力キャリー $c_{\text{out},i-1}$ に等しく、これはさらにペア $i-2$ に依存する。この連鎖は LSB（ペア 0）から MSB まで走る：</p>

$$
c<em>{\text{in},0} = 1 \;\xrightarrow{\text{ペア}0}\; c</em>{\text{out},0} = c<em>{\text{in},1} \;\xrightarrow{\text{ペア}1}\; c</em>{\text{out},1} = c_{\text{in},2} \;\xrightarrow{\text{ペア}2}\; \cdots
$$

<p>各ペア内部では2段のキャリーが存在する：</p>

$$
c<em>{\text{in},i} \;\xrightarrow{\text{m6段}}\; c</em>{\text{mid},i} \;\xrightarrow{\text{m4段}}\; c_{\text{out},i}
$$

<p>したがって、ペア $i$ の出力ビット（新 m4$<em>i$, 新 m6$</em>i$）を求めるには、原理的にペア $0$ からペア $i-1$ までの全てのキャリーが確定している必要がある。</p>

<strong>問い.</strong> この逐次依存は本質的か。すなわち、m4/m6 のビット列から各ペアのキャリーを「閉じた式」で表現できるか。

<hr>

<h2>4.2 局所キャリー分類（GPK）</h2>

<p>キャリーの逐次依存にもかかわらず、各ペアの<strong>キャリーに対する振る舞い</strong>は入力キャリーの値に依存せずに分類できる。</p>

<strong>定義 4.1（GPK 分類）.</strong> 2つのビット $p, q \in \{0,1\}$ と入力キャリー $c \in \{0,1\}$ に対する加算 $p + q + c$ のキャリー出力 $\lfloor(p+q+c)/2\rfloor$ について：

- <strong>Generate (G):</strong> $p + q = 2$（すなわち $p = q = 1$）のとき、$c$ の値によらずキャリー出力は 1。
- <strong>Propagate (P):</strong> $p + q = 1$（すなわち $p \neq q$）のとき、キャリー出力は $c$ に等しい。
- <strong>Kill (K):</strong> $p + q = 0$（すなわち $p = q = 0$）のとき、$c$ の値によらずキャリー出力は 0。

<p>ブール述語で表現すると：</p>

$$
G(p,q) = p \wedge q = \text{AND}(p,q)
$$
$$
P(p,q) = p \oplus q = \text{XOR}(p,q)
$$
$$
K(p,q) = \neg p \wedge \neg q = \text{NOR}(p,q)
$$

<p>$G, P, K$ は排他的かつ網羅的である（任意の $(p,q)$ に対してちょうど1つが真）。</p>

<strong>注意 4.0.</strong> GPK 分類は本論文で新たに導入した概念ではない。carry-lookahead adder [6] において加算器の各桁のキャリー振る舞いを分類する標準的な手法であり、半世紀以上の歴史を持つ。本論文の貢献は、この既存の分類をコラッツ型写像のペア加算に適用し、3n+1 において GPK が n のペア内述語（m2/m7/m9）に一致することを示した点にある。

<hr>

<h2>4.3 各段の GPK</h2>

<p>第3節で定義した参照パターンに基づき、各段の GPK を記述する。以下、一般的な参照ビット $(r<em>i^{(6)}, b</em>i)$（m6 段）および $(r<em>i^{(4)}, a</em>i)$（m4 段）に対して定義する。</p>

<strong>m6 段の GPK：</strong>
$$
G<em>{\text{mid}}[i] = \text{AND}(r</em>i^{(6)},\, b_i)
$$
$$
P<em>{\text{mid}}[i] = \text{XOR}(r</em>i^{(6)},\, b_i)
$$

<strong>m4 段の GPK：</strong>
$$
G<em>{\text{out}}[i] = \text{AND}(r</em>i^{(4)},\, a_i)
$$
$$
P<em>{\text{out}}[i] = \text{XOR}(r</em>i^{(4)},\, a_i)
$$

<strong>x=5 の場合の具体化：</strong>
$$
G<em>{\text{mid}}[i] = b</em>{i-1} \wedge b<em>i, \quad P</em>{\text{mid}}[i] = b<em>{i-1} \oplus b</em>i
$$
$$
G<em>{\text{out}}[i] = a</em>{i-1} \wedge a<em>i, \quad P</em>{\text{out}}[i] = a<em>{i-1} \oplus a</em>i
$$

<strong>x=3 の場合の具体化：</strong>
$$
G<em>{\text{mid}}[i] = a</em>{i-1} \wedge b<em>i, \quad P</em>{\text{mid}}[i] = a<em>{i-1} \oplus b</em>i
$$
$$
G<em>{\text{out}}[i] = a</em>i \wedge b<em>i, \quad P</em>{\text{out}}[i] = a<em>i \oplus b</em>i
$$

<hr>

<h2>4.4 ペア全体の GPK 合成</h2>

<p>m6 段と m4 段は直列に接続されている（m6 段のキャリー出力が m4 段のキャリー入力となる）。2段の直列合成により、ペア $i$ 全体の GPK を得る。</p>

<strong>命題 4.1（直列合成）.</strong> 2つの GPK 段 $(G<em>1, P</em>1)$ と $(G<em>2, P</em>2)$ が直列に接続されているとき（段1の出力が段2の入力）、全体の GPK は：

$$
G<em>{12} = G</em>2 \vee (P<em>2 \wedge G</em>1)
$$
$$
P<em>{12} = P</em>2 \wedge P_1
$$

<em>証明.</em> キャリー入力 $c$ に対する全体のキャリー出力を場合分けする。

- $G_2 = 1$ のとき：段2が自力生成するので出力は 1。 $c$ に依存しない。
- $G<em>2 = 0, P</em>2 = 1$ のとき：段2は段1の出力を通す。段1の出力は $G<em>1 = 1$ なら 1、$P</em>1 = 1$ なら $c$、$K_1 = 1$ なら 0。
- $K_2 = 1$ のとき：段2が吸収するので出力は 0。$c$ に依存しない。

<p>全体の Generate: 出力が $c$ によらず 1 となる条件は $G<em>2 \vee (P</em>2 \wedge G_1)$。
全体の Propagate: 出力が $c$ に等しくなる条件は $P<em>2 \wedge P</em>1$。 □</p>

<strong>定義 4.2（ペア GPK）.</strong> ペア位置 $i$ の全体 GPK を以下で定義する：

$$
G<em>i = G</em>{\text{out}}[i] \vee (P<em>{\text{out}}[i] \wedge G</em>{\text{mid}}[i])
$$
$$
P<em>i = P</em>{\text{out}}[i] \wedge P_{\text{mid}}[i]
$$

<p>意味：$G<em>i = 1$ ならばペア $i$ は入力キャリーの値によらずキャリーを出力する。$P</em>i = 1$ ならばペア $i$ は入力キャリーをそのまま出力に通す。どちらでもなければキャリーを吸収する。</p>

<hr>

<h2>4.5 走査によるキャリー確定</h2>

<p>局所 GPK が全ペアで計算されれば、キャリーの確定は LSB からの単純走査で行える。</p>

<strong>アルゴリズム 4.1（キャリー走査）.</strong>

<pre><code class="">入力: ペア GPK 列 (G<em>0, P</em>0), (G<em>1, P</em>1), ..., (G<em>{k-1}, P</em>{k-1})
      初期キャリー c_0 = 1

c ← 1
for i = 0 to k-1:
    c_in[i] ← c
    c ← G<em>i OR (P</em>i AND c)
</code></pre>

<strong>命題 4.2.</strong> アルゴリズム 4.1 は $O(k)$ 時間で全ペアの入力キャリーを確定する。

<em>証明.</em> ループは $k$ 回、各反復は定数時間の論理演算。 □

<strong>キャリーが確定した後の出力計算：</strong>

<p>各ペア $i$ について、$c_{\text{in},i}$ が判明すれば：</p>

$$
c<em>{\text{mid},i} = G</em>{\text{mid}}[i] \vee (P<em>{\text{mid}}[i] \wedge c</em>{\text{in},i})
$$
$$
\text{新m6}<em>i = r</em>i^{(6)} \oplus b<em>i \oplus c</em>{\text{in},i}
$$
$$
\text{新m4}<em>i = r</em>i^{(4)} \oplus a<em>i \oplus c</em>{\text{mid},i}
$$

<p>これも各ペア独立に $O(1)$ で計算される。</p>

<hr>

<h2>4.6 局所 GPK の計算コスト</h2>

<strong>核心的観察.</strong> 局所 GPK $G<em>{\text{mid}}[i], P</em>{\text{mid}}[i], G<em>{\text{out}}[i], P</em>{\text{out}}[i]$ の計算は、m4/m6 のビットを<strong>参照して AND/XOR を取るだけ</strong>である。参照先は $x$ によって異なるが（表 3.1）、演算の種類と回数は同一である。

- $x=3$: 位置 $i$ と位置 $i-1$ の m4 ビット、および位置 $i$ の m4/m6 ビットを参照
- $x=5$: 位置 $i$ と位置 $i-1$ の m4 ビット同士、m6 ビット同士を参照
- いずれの場合も、<strong>各ペアの局所 GPK は $O(1)$ で、追加の算術演算なしに得られる</strong>

<p>したがって、全ペアの局所 GPK の計算は $O(k)$ であり、その後の走査も $O(k)$ であるから、キャリーの完全確定は $O(k)$ 時間で達成される。</p>

<hr>

<h2>4.7 GPK ツリーによる並列化</h2>

<p>走査は $O(k)$ 時間であるが、各ステップが前ステップに依存するため並列化できない。並列計算環境では、GPK の二分木合成により $O(\log k)$ 段に圧縮できる。</p>

<strong>命題 4.3（GPK 合成の結合性）.</strong> GPK 合成（命題 4.1 の規則）は結合的である。

<em>証明.</em> 3つの段 $A, B, C$ に対して $(A \circ B) \circ C = A \circ (B \circ C)$ を示す。合成規則 $G<em>{AB} = G</em>B \vee (P<em>B \wedge G</em>A)$, $P<em>{AB} = P</em>B \wedge P_A$ に対して：

$$
G<em>{(AB)C} = G</em>C \vee (P<em>C \wedge G</em>{AB}) = G<em>C \vee (P</em>C \wedge (G<em>B \vee (P</em>B \wedge G_A)))
$$
$$
= G<em>C \vee (P</em>C \wedge G<em>B) \vee (P</em>C \wedge P<em>B \wedge G</em>A)
$$

$$
G<em>{A(BC)} = G</em>{BC} \vee (P<em>{BC} \wedge G</em>A) = (G<em>C \vee (P</em>C \wedge G<em>B)) \vee ((P</em>C \wedge P<em>B) \wedge G</em>A)
$$
$$
= G<em>C \vee (P</em>C \wedge G<em>B) \vee (P</em>C \wedge P<em>B \wedge G</em>A)
$$

<p>両者は一致する。$P$ についても：</p>

$$
P<em>{(AB)C} = P</em>C \wedge P<em>{AB} = P</em>C \wedge P<em>B \wedge P</em>A = P<em>{BC} \wedge P</em>A = P_{A(BC)}
$$

<p>□</p>

<strong>アルゴリズム 4.2（GPK ツリー合成）.</strong>

<pre><code class="">入力: ペア GPK 列 (G<em>0, P</em>0), ..., (G<em>{k-1}, P</em>{k-1})
出力: prefix GPK: (G<em>{0..j}, P</em>{0..j}) for all j

<p>レベル 0: 各ペアの (G<em>i, P</em>i)</p>

<p>レベル 1: 隣接ペアを合成
  (G<em>{01}, P</em>{01}), (G<em>{23}, P</em>{23}), ...</p>

<p>レベル 2: さらに合成
  (G<em>{0123}, P</em>{0123}), ...</p>

... log₂(k) 段で完了
</code></pre>

<strong>命題 4.4.</strong> GPK ツリー合成は $O(k)$ の作業量を $O(\log k)$ 段で完了する。各段の演算は AND と OR のみで構成される。

<em>証明.</em> 二分木の各レベルで $k/2^l$ 個の合成を行い（レベル $l$）、各合成は定数個の AND/OR 演算。総レベル数は $\lceil \log_2 k \rceil$。 □

<strong>注意 4.1.</strong> GPK ツリーは並列計算のための最適化であり、正しさの証明には不要である。逐次走査（アルゴリズム 4.1）で全てのキャリーは $O(k)$ 時間で確定する。以降の議論では、文脈に応じて走査またはツリーのいずれかを用いる。

<hr>

<h2>4.8 具体例：n=27, x=5 のキャリー確定</h2>

<p>§3.7 の例を GPK の観点から再訪する。</p>

<p>$n=27$, m4 = $(0,1,1)$, m6 = $(1,0,1)$。LSB 順: $a = (1,1,0)$, $b = (1,0,1)$。</p>

<strong>局所 GPK 計算：</strong>

<table>
<tr><th>ペア $i$</th><th>$b<em>{i-1}$</th><th>$b</em>i$</th><th>$G<em>{\text{mid}}$</th><th>$P</em>{\text{mid}}$</th><th>$a<em>{i-1}$</th><th>$a</em>i$</th><th>$G<em>{\text{out}}$</th><th>$P</em>{\text{out}}$</th><th>$G<em>i$</th><th>$P</em>i$</th></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>2</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
</table>

<p>GPK 列（LSB から）: <strong>P, G, P</strong></p>

<strong>走査：</strong>

<table>
<tr><th>ステップ</th><th>$c<em>{\text{in}}$</th><th>GPK</th><th>$c</em>{\text{out}}$</th><th>解釈</th></tr>
<tr><td>$i=0$</td><td>1</td><td>P</td><td>1</td><td>初期キャリー 1 を伝播</td></tr>
<tr><td>$i=1$</td><td>1</td><td>G</td><td>1</td><td>自力生成（$c_{\text{in}}$ に依存しない）</td></tr>
<tr><td>$i=2$</td><td>1</td><td>P</td><td>1</td><td>キャリー 1 を伝播</td></tr>
</table>

<p>全ペアで $c_{\text{in}} = 1$。§3.7 の逐次計算と一致する。</p>

<strong>構造的解釈.</strong> ペア 1 が Generate であるため、仮にペア 0 がキャリーを止めた（Kill だった）としても、ペア 2 にはキャリーが到達する。GPK はキャリー伝播の「地形」を記述しており、初期値 $c_0 = 1$ がその地形の上を流れる。

<hr>

<h2>4.9 具体例：n=27, x=3 のキャリー確定</h2>

<p>$n=27$, LSB 順: $a = (1,1,0)$, $b = (1,0,1)$。</p>

<strong>局所 GPK 計算（3n+1 参照パターン）：</strong>

<table>
<tr><th>ペア $i$</th><th>$a<em>{i-1}$</th><th>$b</em>i$</th><th>$G<em>{\text{mid}}$</th><th>$P</em>{\text{mid}}$</th><th>$a<em>i$</th><th>$b</em>i$</th><th>$G<em>{\text{out}}$</th><th>$P</em>{\text{out}}$</th><th>$G<em>i$</th><th>$P</em>i$</th></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>2</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
</table>

<p>注目すべき点：m4 段の $G<em>{\text{out}}, P</em>{\text{out}}$ は $(a<em>i, b</em>i)$ の AND, XOR であり、これは n の m2, m7 に他ならない。</p>

$n=27$ のペア（LSB 順）: $(1,1), (1,0), (0,1)$
- m2（AND）: $1, 0, 0$ → $G_{\text{out}} = 1, 0, 0$ ✓
- m7（XOR）: $0, 1, 1$ → $P_{\text{out}} = 0, 1, 1$ ✓

<p>GPK 列（LSB から）: <strong>G, P, G</strong></p>

<strong>走査：</strong>

<table>
<tr><th>ステップ</th><th>$c<em>{\text{in}}$</th><th>GPK</th><th>$c</em>{\text{out}}$</th></tr>
<tr><td>$i=0$</td><td>1</td><td>G</td><td>1</td></tr>
<tr><td>$i=1$</td><td>1</td><td>P</td><td>1</td></tr>
<tr><td>$i=2$</td><td>1</td><td>G</td><td>1</td></tr>
</table>

<p>全ペアで $c_{\text{in}} = 1$。§3.8 の逐次計算と一致する。</p>

<hr>

<h2>4.10 4.1 の問いへの回答</h2>

<p>§4.1 で提起した問い「キャリーの逐次依存は本質的か」に対する回答を整理する。</p>

<strong>回答 1（計算的）.</strong> 各ペアの局所 GPK は m4/m6 のビットを参照するだけで $O(1)$ で得られる。その後のキャリー確定は $O(k)$ の走査 1 回で完了する。乗算 $xn$ は参照添字のシフトに吸収されており、走査段階では現れない。

<strong>回答 2（構造的）.</strong> キャリーの値自体は逐次的に確定するが、各ペアのキャリーに対する<strong>振る舞い</strong>（G/P/K のいずれであるか）はキャリーの値に依存しない。したがって、「キャリーが何をするか」は局所的に決まり、「キャリーがどこまで届くか」だけが大域的な問題である。

<strong>回答 3（並列化）.</strong> 大域的伝播も GPK ツリー合成により $O(\log k)$ 段に圧縮可能。これは carry-lookahead adder [6] と同じ原理であり、結合性（命題 4.3）がその正当性を保証する。

<hr>

<h2>4.11 本節のまとめ</h2>

<p>1. キャリー伝播は各ペアの GPK（Generate/Propagate/Kill）分類に帰着される。GPK は AND と XOR のみで計算され、参照パターン（§3.6, 表 3.1）に従ってビットを読むだけで得られる。</p>

<p>2. 全ペアの GPK が求まれば、LSB からの $O(k)$ 走査 1 回で全キャリーが確定する。乗算 $xn$ は参照パターンの段階で吸収されており、走査は AND/OR のみで構成される。全体の計算量は $O(k)$ である。</p>

<p>3. 並列化が必要な場合、GPK の二分木合成により $O(\log k)$ 段に圧縮可能である（GPK ツリー）。ただしこれは最適化であり必須ではない。</p>

<p>4. x=3 と x=5 で局所 GPK の<strong>参照先</strong>は異なるが、<strong>計算構造は完全に同一</strong>である。</p>

<p>次節では、x=3 における特別な構造——m4 段 GPK が n のペア内述語に一致するという性質——を定理として証明し、その成立が x=3 に限定されることを示す。</p>

<h3>References（本節で引用）</h3>

<p>[6] O. J. Bedrij, "Carry-select adder," IRE Transactions on Electronic Computers, vol. EC-11, no. 3, pp. 340–346, 1962.</p>
        </div>

        <div class="chapter" id="ch5">
<h1>5. The Structural Privilege of 3n+1（3n+1 の構造的特権）</h1>

<p>本節は論文の核心部である。3n+1 の m4 段キャリー構造が n のペア内述語に一致すること（定理 B）を証明し、この性質が x=3 に限定されること（定理 C）を16述語の各ペア独立性から証明する。</p>

<hr>

<h2>5.1 定理 B：m4 段の一致</h2>

<strong>定理 5.1（定理 B：3n+1 の m4 段一致）.</strong> 3n+1 のペア加算において、m4 段の Generate および Propagate は、n の述語 m2(AND) および m7(XOR) に各ペア位置で一致する。すなわち、任意の奇数 $n$ の LSB 順ペア位置 $i$（$0 \leq i \leq k-1$）に対して：

$$
G<em>{\text{out}}[i] = \text{m2}(n)</em>i = a<em>i \wedge b</em>i
$$
$$
P<em>{\text{out}}[i] = \text{m7}(n)</em>i = a<em>i \oplus b</em>i
$$

<p>ここで $(a<em>i, b</em>i)$ は $n$ の LSB 順第 $i$ ペアである。</p>

<em>証明.</em> 命題 3.4 より、3n+1 の m4 段入力は $(r<em>i^{(4)}, a</em>i) = (b<em>i, a</em>i)$ である。加算の可換性から：

$$
G<em>{\text{out}}[i] = \text{AND}(b</em>i, a<em>i) = a</em>i \wedge b<em>i = \text{m2}(n)</em>i
$$
$$
P<em>{\text{out}}[i] = \text{XOR}(b</em>i, a<em>i) = a</em>i \oplus b<em>i = \text{m7}(n)</em>i
$$

<p>これは定義 2.5 における m2 と m7 の定義そのものである。 □</p>

<strong>系 5.1.</strong> 3n+1 において、m4 段の Kill（キャリー吸収）は m9(NOR) に一致する：

$$
K<em>{\text{out}}[i] = \neg a</em>i \wedge \neg b<em>i = \text{m9}(n)</em>i
$$

<em>証明.</em> $G, P, K$ は排他的かつ網羅的であるから、$K = \neg G \wedge \neg P = \neg(a<em>i \wedge b</em>i) \wedge \neg(a<em>i \oplus b</em>i)$。真理値表を検証すると、これは $a<em>i = b</em>i = 0$ のときのみ真であり、m9(NOR) の定義に一致する。 □

<strong>解釈.</strong> 定理 5.1 を言い換えると：

- n のペア $(a<em>i, b</em>i) = (1,1)$ → m2=1 → m4 段はキャリーを<strong>生成</strong>する
- n のペア $(a<em>i, b</em>i) \in \{(0,1),(1,0)\}$ → m7=1 → m4 段はキャリーを<strong>伝播</strong>する
- n のペア $(a<em>i, b</em>i) = (0,0)$ → m9=1 → m4 段はキャリーを<strong>吸収</strong>する

<p>3n+1 の m4 段キャリー地形は、n のペア型を「読む」だけで完全に決定される。§2 で定義した16述語体系の m2, m7, m9 が、3n+1 のキャリー動力学を文字通り記述している。</p>

<hr>

<h2>5.2 m6 段について</h2>

<p>m4 段とは対照的に、m6 段は n のペア内述語には一致しない。</p>

<strong>命題 5.1.</strong> 3n+1 の m6 段 GPK は：

$$
G<em>{\text{mid}}[i] = a</em>{i-1} \wedge b<em>i, \quad P</em>{\text{mid}}[i] = a<em>{i-1} \oplus b</em>i
$$

<p>これは位置 $i-1$ の m4 ビットと位置 $i$ の m6 ビットの交差参照であり、単一ペア位置の情報では決定されない。</p>

<em>証明.</em> 命題 3.4 より直接従う。 □

<strong>注意 5.1.</strong> ペア全体の GPK $G<em>i = G</em>{\text{out}}[i] \vee (P<em>{\text{out}}[i] \wedge G</em>{\text{mid}}[i])$ は m6 段の交差項を含むため、3n+1 であってもペア全体の GPK は各ペア独立ではない。しかし、m4 段が各ペア独立であるという事実は、キャリー構造の「上位段」が n の述語表から直接読めることを意味する。

<hr>

<h2>5.3 定理 C：16述語の限界</h2>

<strong>定義 5.1.</strong> 関数 $f: \mathbb{N}_{\text{odd}} \to \{0,1\}^k$ が<strong>16述語表現可能</strong>であるとは、m1〜m16 の有限個のビットごとブール合成で $f$ を表現できることをいう。系 2.1 より、16述語表現可能な関数は全て各ペア独立である。

<strong>定理 5.2（定理 C：16述語の限界）.</strong> $x \geq 5$（$x - 1$ が2の冪）に対して、$xn+1$ の m4 段 GPK $(G<em>{\text{out}}, P</em>{\text{out}})$ は16述語表現可能ではない。

<em>証明.</em> 2段階で証明する。

<strong>第1段階：参照構造の特定.</strong>

<p>$x = 5$ の場合、m4 段の入力は $(a<em>{i-1}, a</em>i)$ である（命題 3.3）：</p>

$$
G<em>{\text{out}}[i] = a</em>{i-1} \wedge a<em>i, \quad P</em>{\text{out}}[i] = a<em>{i-1} \oplus a</em>i
$$

<p>これは位置 $i-1$ と位置 $i$ の m4 ビットに同時に依存する。</p>

<strong>第2段階：各ペア独立性との矛盾.</strong>

<p>背理法による。$(G<em>{\text{out}}[0], G</em>{\text{out}}[1], \ldots, G_{\text{out}}[k-1])$ が16述語表現可能であると仮定する。系 2.1 より、この関数は各ペア独立でなければならない。すなわち、ある関数 $h: \{0,1\}^2 \to \{0,1\}$ が存在して：</p>

$$
G<em>{\text{out}}[i] = h(a</em>i, b_i) \quad \text{（全ての } i \text{, 全ての } n \text{ に対して）}
$$

<p>しかし $G<em>{\text{out}}[i] = a</em>{i-1} \wedge a<em>i$ は $a</em>{i-1}$ に依存する。$a<em>i = 1, b</em>i = 1$ を固定した状態で：</p>

- $a<em>{i-1} = 0$ ならば $G</em>{\text{out}}[i] = 0$
- $a<em>{i-1} = 1$ ならば $G</em>{\text{out}}[i] = 1$

<p>$(a<em>i, b</em>i) = (1,1)$ が同一であるにもかかわらず、$G<em>{\text{out}}[i]$ は $a</em>{i-1}$ の値に応じて変化する。$(a<em>i, b</em>i)$ のみの関数 $h$ ではこの変化を捕捉できない。矛盾。 □</p>

<hr>

<h2>5.4 網羅的検証による補強</h2>

<p>定理 5.2 の証明は原理的であるが、具体的反例で補強する。</p>

<strong>命題 5.2（網羅的不一致）.</strong> $n = 31$ に対して、5n+1 のペア全体 GPK $(G_i)$ は、m1〜m16 の任意の2述語に対する AND, OR, XOR（$16 \times 16 \times 3 = 768$ 通り）、および単独述語（16通り）のいずれとも一致しない。

<em>検証.</em> $n = 31 = 011111_2$、ペア列 $((0,1),(1,1),(1,1))$、$k=3$。

<p>LSB 順 $a = (1,1,0)$, $b = (1,1,1)$。</p>

<p>5n+1 の全体 GPK（MSB 順）: $G = (1, 1, 0)$, $P = (0, 0, 1)$。</p>

<p>n=31 の16述語値（MSB 順、重複除去）:</p>

$$
\{(0,0,0),\; (0,1,1),\; (1,0,0),\; (1,1,1)\}
$$

<p>ペア 1 とペア 2 がともに $(1,1)$ であるため、任意の各ペア独立関数はこれら2位置で同一の出力を与える。したがって、16述語の任意のブール合成が取り得る3ビット列のパターンは、第2成分と第3成分が等しいものに限られる。</p>

<p>$G = (1, 1, 0)$ は第2成分 $= 1$, 第3成分 $= 0$ であり、この制約を破る。</p>

<p>合計 <strong>784通り</strong>を計算機で網羅検証し、全て不一致を確認。 □</p>

<strong>注意 5.2.</strong> 命題 5.2 の本質は「同一ペアからは同一の出力しか得られない」という各ペア独立性の帰結である。GPK が隣接ペア間の関係に依存するため、同一ペアであっても隣のペアが異なれば GPK は異なり得る。これが16述語の枠組みでは原理的に記述不可能な情報である。

<hr>

<h2>5.5 分類定理</h2>

<strong>定理 5.3（分類定理）.</strong> $x - 1 = 2^s$ を満たすパラメータ $x$ に対して、$xn+1$ の m4 段 GPK が16述語表現可能であるのは $s = 1$（$x = 3$）のときに限る。

<em>証明.</em>

<strong>($s = 1$)</strong> 定理 5.1 より、$G<em>{\text{out}} = \text{m2}$, $P</em>{\text{out}} = \text{m7}$。✓

<strong>($s = 2$, $x = 5$)</strong> m4 段入力は $(a<em>{i-1}, a</em>i)$。定理 5.2 により16述語表現不可能。✗

<strong>($s \geq 3$)</strong> m4 段入力の参照距離は $\lfloor s/2 \rfloor \geq 1$ ペア以上離れる。定理 5.2 と同じ議論（$a_{i-t}$ への依存、$t \geq 1$）により各ペア独立性と矛盾。✗

<p>したがって $s = 1$ のみが表現可能。 □</p>

<strong>系 5.2.</strong> $x = 3$ は、m4 段のキャリー構造が n のペア内述語として読み取れる<strong>唯一の</strong> $xn+1$ 型パラメータである。

<hr>

<h2>5.6 構造的解釈</h2>

<strong>なぜ s=1 だけが特別か.</strong> $xn+1 = 2^s n + n + 1$ において、$2^s n$ は $s$ ビットの左シフトである。ペア構造の幅は2ビットであるから：

- $s = 1$（ペア幅未満）: シフトが m4 と m6 の役割を交換するが、<strong>位置は同一ペア内に留まる</strong>。$r<em>i^{(4)} = b</em>i$ は位置 $i$ 自身の右ビット。
- $s = 2$（ペア幅に等しい）: $r<em>i^{(4)} = a</em>{i-1}$ は前のペアのビット。位置間相関が不可避。
- $s \geq 3$（ペア幅超過）: さらに遠いペアとの相関。

<p>これを図式化すると：</p>

$$
\underbrace{\text{16述語の記述力}}<em>{\text{ペア内情報（位置独立）}} \quad \text{vs} \quad \underbrace{\text{写像の要求}}</em>{\text{シフト量に応じた位置間情報}}
$$

<p>$s = 1$ のときのみ、要求が記述力の範囲に収まる。</p>

<strong>コラッツ予想との関連.</strong> コラッツ予想が $3n+1$ で定式化される理由について、定理 5.3 は以下の構造的説明を提示する：$x = 3$ は述語空間においてキャリー構造の一部が n の内部情報として直接読み取れる唯一のパラメータである。この「透明性」が、$3n+1$ の力学系としての性質——全軌道の収束——に寄与しているかどうかは未解決であるが、構造的特異性が同定されたことは確かである。

<hr>

<h2>5.7 数値的確認</h2>

<strong>定理 B の確認.</strong> $n = 1, 3, 5, \ldots, 99$ の50個の奇数、および $n = 127, 255, 511, 1023, 4095, 8191, 65535, 99991, 999999$ の大数に対して、3n+1 の m4 段 $G<em>{\text{out}}[i]$ と m2$(n)</em>i$ の一致、$P<em>{\text{out}}[i]$ と m7$(n)</em>i$ の一致を計算機で検証。全数一致。

<strong>定理 C の確認.</strong> $n = 31$ に対する784通りの網羅照合に加え、$n = 7, 13, 19, 27, 43, 83$ に対しても同様の照合を実施。$n = 27, 43$ では一部の述語組み合わせが偶然一致するが（ペア値の配置に起因）、$n = 31$ では完全不一致。定理 C は存在命題であり、1つの反例で証明は完了する。

<hr>

<h2>5.8 本節のまとめ</h2>

<p>1. <strong>定理 B（定理 5.1）:</strong> 3n+1 の m4 段 GPK は n の m2(AND)/m7(XOR)/m9(NOR) に一致する。n のペア型を読むだけでキャリーの生成・伝播・吸収が判明する。</p>

<p>2. <strong>定理 C（定理 5.2）:</strong> x≥5 の m4 段 GPK は16述語表現不可能。各ペア独立性の壁により、隣接ペア間の相関は原理的に記述できない。n=31 で784通りの網羅検証で補強。</p>

<p>3. <strong>分類定理（定理 5.3）:</strong> m4 段 GPK がペア内述語で閉じるのは x=3 に限る。3n+1 はペア述語体系内でキャリー構造が「透明」になる唯一のコラッツ型写像である。</p>
        </div>

        <div class="chapter" id="ch6">
<h1>6. Division by 2 as Exchange（÷2 = 交換操作）</h1>

<p>xn+1 の計算後、結果を次の奇数に到達させるために2で繰り返し割る操作が必要である。本節では、この操作が m4/m6 の枠組みにおいて役割の交換として記述されることを示す。</p>

<hr>

<h2>6.1 末尾ゼロと2進付値</h2>

<strong>定義 6.1.</strong> 正整数 $m$ の2進付値 $v_2(m)$ を、$m$ を割り切る2の最大冪の指数として定義する：

$$
v_2(m) = \max\{d \in \mathbb{N} : 2^d \mid m\}
$$

<p>2進表現において $v_2(m)$ は末尾ゼロの個数に等しい。</p>

<p>$xn+1$ の結果 $m = xn+1$ に対して $d = v_2(m)$ とおくと、次の奇数は：</p>

$$
n' = \frac{m}{2^d} = \frac{xn+1}{2^d}
$$

<hr>

<h2>6.2 ÷2 のビット操作</h2>

<p>2進表現における $m/2$ は最下位ビットの除去（右シフト1ビット）である。$m$ が偶数ならば最下位ビットは 0 であり、この除去で情報は失われない。</p>

<p>$d$ 回の ÷2 は、末尾の $d$ 個のゼロビットを除去する。これらのゼロビットは情報を持たないから：</p>

<strong>命題 6.1.</strong> $m/2^d$（$2^d \mid m$）の2進表現は、$m$ の2進表現から末尾 $d$ 個のゼロを除去したものに等しい。この操作で情報は失われない。

<hr>

<h2>6.3 ペア構造への影響</h2>

<p>$m = xn+1$ のペア表現から $n' = m/2^d$ のペア表現への変換を考える。</p>

<p>$m$ の2進表現を $\hat{\beta}(m) = s<em>1 s</em>2 \cdots s_{2l}$ とする（偶数桁パディング済み）。末尾 $d$ ビットは全てゼロであるから：</p>

$$
\hat{\beta}(m) = s<em>1 s</em>2 \cdots s<em>{2l-d} \underbrace{0 \cdots 0}</em>{d}
$$

<p>末尾 $d$ ビットを除去して $m/2^d$ のビット列を得る：</p>

$$
\beta(m/2^d) = s<em>1 s</em>2 \cdots s_{2l-d}
$$

<p>この列を偶数桁パディングしてペアに分解する。<strong>$d$ の偶奇によって、ペア境界のずれ方が異なる。</strong></p>

<strong>$d$ が偶数のとき：</strong> $d = 2q$ ビットの除去は $q$ ペアの除去に相当する。ペア境界は保存される。残りのペア列は $m$ のペア列の先頭 $l-q$ 個と一致する。

$$
P(m/2^d) = ((s<em>1, s</em>2), (s<em>3, s</em>4), \ldots, (s<em>{2l-d-1}, s</em>{2l-d}))
$$

<p>m4 と m6 の対応関係は $m$ と同じである。</p>

<strong>$d$ が奇数のとき：</strong> $d = 2q+1$ ビットの除去は $q$ ペアと1ビットの除去に相当する。残りのビット列は奇数桁であるから、先頭に0を1つパディングする。

$$
\hat{\beta}(m/2^d) = 0\, s<em>1\, s</em>2\, \cdots\, s_{2l-d}
$$

<p>パディングにより、元のペア $(s<em>1, s</em>2)$ が $(0, s<em>1)$ と $(s</em>2, s_3)$ に再分割される。<strong>これは m4 と m6 の役割が入れ替わることに相当する。</strong></p>

<hr>

<h2>6.4 m4⇔m6 交換定理</h2>

<strong>定理 6.1（÷2 の交換原理）.</strong> $m$ のペア列から $m/2^d$ のペア列への変換において：

- $d$ が偶数のとき：m4 と m6 の対応は<strong>維持</strong>される。
- $d$ が奇数のとき：m4 と m6 の対応は<strong>交換</strong>される。

<p>より正確には、$m$ の MSB 側ペア列を $((\alpha<em>0, \beta</em>0), (\alpha<em>1, \beta</em>1), \ldots)$ とするとき、末尾 $d$ ビット除去後の再ペア化において：</p>

$$
d \text{ 偶数}: \quad \text{m4}(n')<em>j = \alpha</em>j, \quad \text{m6}(n')<em>j = \beta</em>j
$$
$$
d \text{ 奇数}: \quad \text{m4}(n')<em>j \sim \beta</em>j, \quad \text{m6}(n')<em>j \sim \alpha</em>{j+1}
$$

<p>ここで $\sim$ はパディングと端の処理を除いた対応関係を表す。</p>

<em>証明.</em> $d$ が偶数のとき、$d$ ビットは偶数個のペアを構成し、その除去はペア境界を保存する。$d$ が奇数のとき、除去後のビット列は奇数桁となり、先頭0パディングにより全ビットが1つずれてペアに再配置される。左ビット位置に入っていたビットが右ビット位置に、右ビット位置に入っていたビットが（次のペアの）左ビット位置に移動する。 □

<hr>

<h2>6.5 具体例</h2>

<strong>例 6.1（d=3, 奇数：交換）.</strong> $5 \times 27 + 1 = 136 = 10001000_2$。

<p>ペア列: $((1,0),(0,0),(1,0),(0,0))$。m4 = $(1,0,1,0)$, m6 = $(0,0,0,0)$。</p>

<p>$v<em>2(136) = 3$。$136/8 = 17 = 10001</em>2$。パディング: $010001$。</p>

<p>ペア列: $((0,1),(0,0),(0,1))$。m4' = $(0,0,0)$, m6' = $(1,0,1)$。</p>

<p>$d=3$（奇数）→ 交換が発生。実際に、136 の m4 の非ゼロパターン $(1,0,1,0)$ の構造が、17 の m6' = $(1,0,1)$ に対応していることが確認できる。</p>

<strong>例 6.2（d=1, 奇数：交換）.</strong> $3 \times 27 + 1 = 82 = 1010010_2$。パディング: $01010010$。

<p>ペア列: $((0,1),(0,1),(0,0),(1,0))$。m4 = $(0,0,0,1)$, m6 = $(1,1,0,0)$。</p>

<p>$v<em>2(82) = 1$。$82/2 = 41 = 101001</em>2$。</p>

<p>ペア列: $((1,0),(1,0),(0,1))$。m4' = $(1,1,0)$, m6' = $(0,0,1)$。</p>

<p>$d=1$（奇数）→ 交換。82 の m4 パターンと 41 の m6' パターン、82 の m6 パターンと 41 の m4' パターンの間に対応関係がある。</p>

<strong>例 6.3（d が偶数: m4/m6 維持）.</strong>

<p>$n = 7 = 111_2$</p>

<p>偶数桁パディング: $0111_2$</p>

<p>ペア列: $P_1 = (0,1),\; P_0 = (1,1)$</p>

<p>m4 = $(0, 1)$,　m6 = $(1, 1)$</p>

<p>$5n + 1 = 36 = 100100_2$</p>

<p>ペア列: $P_2 = (1,0),\; P_1 = (0,1),\; P_0 = (0,0)$</p>

<p>$v_2(36) = 2$（<strong>偶数</strong>）</p>

<p>除算過程:</p>
<pre><code>36 ÷ 2 = 18    (100100 → 10010)    ← ペア境界1ビットずれ
18 ÷ 2 = 9     (10010 → 1001)      ← ペア境界が元に戻る</code></pre>

<p>$n' = 9 = 1001_2$</p>

<p>ペア列: $P_1 = (1,0),\; P_0 = (0,1)$</p>

<p>m4' = $(1, 0)$,　m6' = $(0, 1)$</p>

<p>$d = 2$（偶数）→ 2回の右シフトでペア境界が元の位置に復帰。m4 は m4 のまま、m6 は m6 のまま。<strong>役割の交換は発生しない。</strong></p>

<table border="1" cellpadding="6" cellspacing="0" style="border-collapse: collapse; margin: 1em 0;">
<thead>
<tr><th>項目</th><th>例 6.1 (n=27)</th><th>例 6.3 (n=7)</th></tr>
</thead>
<tbody>
<tr><td>5n+1</td><td>136</td><td>36</td></tr>
<tr><td>d</td><td>3（奇数）</td><td>2（偶数）</td></tr>
<tr><td>ペア境界</td><td>1ビットずれたまま</td><td>元に復帰</td></tr>
<tr><td>m4⇔m6</td><td><strong>交換</strong></td><td><strong>維持</strong></td></tr>
</tbody>
</table>

<hr>

<h2>6.6 情報保存の原理</h2>

<strong>命題 6.2.</strong> コラッツ型写像 $T(n) = (xn+1)/2^d$ の1ステップにおいて、入力 $n$ のビット情報は以下のように変換される：

<p>1. <strong>ペア加算</strong>（§3-4）: m4/m6 のビット参照と carry 伝播により新しい m4/m6 を生成。ビット数は高々定数個増加。
2. <strong>末尾ゼロ除去</strong>: 情報量ゼロのビットを除去。情報は失われない。
3. <strong>再ペア化</strong>: $d$ の偶奇に応じて m4⇔m6 の対応が維持または交換される。</p>

<p>特に、÷2 は情報の<strong>位置移動</strong>（ペア内での左右入れ替え）であり、情報の<strong>消失</strong>ではない。</p>

<strong>注意 6.1.</strong> 桁数の増減は写像の収束/発散に直結する。xn+1 の結果は n より大きい（ビット数が増加する可能性がある）が、÷2^d によりビット数が減少する。$d$ が十分大きければ桁数は減少し、軌道は「縮む」。この桁数変動のバランスがコラッツ予想の核心であるが、本論文ではこの問題には立ち入らない。

<hr>

<h2>6.7 写像 T の m4/m6 表現</h2>

<p>以上を統合すると、奇数→奇数の写像 $T: n \mapsto n'$ は m4/m6 空間上の変換として記述される：</p>

$$
T: (\text{m4}(n),\, \text{m6}(n)) \;\longrightarrow\; (\text{m4}(n'),\, \text{m6}(n'))
$$

<p>この変換は3つのフェーズからなる：</p>

<strong>フェーズ 1（ペア加算）:</strong>
$$
(\text{m4}(n),\, \text{m6}(n)) \;\xrightarrow{\text{参照+carry走査}}\; (\text{m4}(xn\!+\!1),\, \text{m6}(xn\!+\!1))
$$

<strong>フェーズ 2（末尾除去）:</strong>
$$
(\text{m4}(xn\!+\!1),\, \text{m6}(xn\!+\!1)) \;\xrightarrow{\text{末尾ゼロペア除去}}\; \text{短縮ペア列}
$$

<strong>フェーズ 3（交換判定）:</strong>
$$
\text{短縮ペア列} \;\xrightarrow{d \bmod 2}\; \begin{cases} (\text{m4}',\, \text{m6}') & (d \text{ 偶数: 維持}) \\ (\text{m6}',\, \text{m4}') & (d \text{ 奇数: 交換}) \end{cases}
$$

<hr>

<h2>6.8 d の決定</h2>

<p>末尾ゼロ数 $d$ もペア加算の結果から直接読み取れる。</p>

<strong>命題 6.3.</strong> $xn+1$ のペア加算結果（LSB 順）において、$d$ は末尾の連続するゼロビット数に等しい。ペア列の LSB 側から、$(0,0)$ ペアの個数を $q$、その直後のペアの右ビットが 0 であれば $d = 2q + 1$（左ビットは奇数性から必ず 1）、右ビットが 1 であれば $d = 2q$ である。

<em>証明.</em> ファスナー構造 $\ldots a<em>1 b</em>1 a<em>0 b</em>0$（LSB 側）において、末尾ゼロは右ビット $b_0$ から始まる。$(0,0)$ ペアの列が $q$ 個続くと $2q$ 個のゼロ。その次のペア $(a, b)$ で $b = 0$ ならさらに1個のゼロが加わり $d = 2q+1$（このとき $a = 1$ は $n'$ が奇数であることから保証される）。$b = 1$ なら $d = 2q$。 □

<hr>

<h2>6.9 本節のまとめ</h2>

<p>1. ÷2 の繰り返しは、末尾ゼロビット（情報量ゼロ）の除去であり、情報は保存される。</p>

<p>2. 除去後の再ペア化において、$d$ の偶奇が m4 と m6 の対応関係を決定する。$d$ 偶数で維持、$d$ 奇数で交換。</p>

<p>3. 写像 $T: n \mapsto n'$ は (m4, m6) 空間上の3フェーズ変換（ペア加算 → 末尾除去 → 交換判定）として閉じた形で記述される。</p>

<p>4. $d$ の値自体もペア加算の結果から直接読み取れ、追加の計算は不要。</p>
        </div>

        <div class="chapter" id="ch7a">
<h1>7. Unified Algorithm（統一アルゴリズム）</h1>

<p>前節までの結果を統合し、任意の xn+1 型写像に対する統一的なアルゴリズムを定式化する。計算量を評価し、従来の算術ベース計算との比較を行う。</p>

<hr>

<h2>7.1 アルゴリズムの定式化</h2>

<strong>アルゴリズム 7.1（m4/m6 直読走査による xn+1 計算）.</strong>

<pre><code class="">入力: 奇数 n, パラメータ x（x-1 = 2^s）
出力: 次の奇数 n' = (xn+1) / 2^d, および d

<p>前処理:
  n → 偶数桁2進表現 → ペア列 P(n)
  m4(n) = (a<em>0, ..., a</em>{k-1})  [MSB 順]
  m6(n) = (b<em>0, ..., b</em>{k-1})  [MSB 順]
  a[], b[] ← m4, m6 を LSB 順に反転</p>

<p>参照パターン決定:
  s ← log₂(x-1)
  t ← ⌊s/2⌋
  s が偶数: ref_R(i) = (b[i-t], b[i])    // m6 段：m6 同型
             ref_L(i) = (a[i-t], a[i])    // m4 段：m4 同型
  s が奇数: ref_R(i) = (a[i-t-1], b[i])  // m6 段：m4→m6 交差
             ref_L(i) = (b[i-t], a[i])    // m4 段：m6→m4 交差
  （範囲外の添字は 0 とする）</p>

<p>走査:
  c ← 1                               // +1 の効果
  for i = 0 to k + ⌈s/2⌉:            // オーバーフロー分を含む
    (p<em>R, q</em>R) ← ref_R(i)
    sum<em>R ← p</em>R + q_R + c
    new<em>b[i] ← sum</em>R mod 2            // 新 m6
    c<em>mid ← ⌊sum</em>R / 2⌋</p>

<p>(p<em>L, q</em>L) ← ref_L(i)
    sum<em>L ← p</em>L + q<em>L + c</em>mid
    new<em>a[i] ← sum</em>L mod 2            // 新 m4
    c ← ⌊sum_L / 2⌋</p>

<p>if c = 0 and i ≥ k: break         // キャリー消滅で終了</p>

<p>後処理:
  結果ペア列（LSB 順）→ 末尾の (0,0) ペアを除去
  ファスナー展開 → 末尾ゼロ数 d を計数
  d ビット右シフト → 偶数桁パディング → 再ペア化
  m4'(n'), m6'(n') を抽出
  n' を復元</p>

出力: n', d
</code></pre>

<hr>

<h2>7.2 x=3 と x=5 の具体化</h2>

<p>アルゴリズム 7.1 の参照パターン部分を具体化する。</p>

<strong>x=3（s=1, 奇数）:</strong>
<pre><code class="">ref_R(i) = (a[i-1], b[i])     // m6 段：前ペアの m4 × 現ペアの m6
ref_L(i) = (b[i],   a[i])     // m4 段：現ペア内（= ペア自身）
</code></pre>

<p>m4 段が現ペア内で完結する（定理 5.1 の計算的表現）。</p>

<strong>x=5（s=2, 偶数）:</strong>
<pre><code class="">ref_R(i) = (b[i-1], b[i])     // m6 段：m6 の隣接ビット
ref_L(i) = (a[i-1], a[i])     // m4 段：m4 の隣接ビット
</code></pre>

<p>両段とも隣接ペアの同型ビットを参照する。</p>

<strong>観察.</strong> 2つのアルゴリズムの差異は <code>ref<em>R</code> と <code>ref</em>L</code> の4つの添字のみである。走査のループ構造、キャリー伝播、後処理は完全に同一。

<hr>

<h2>7.3 計算量の解析</h2>

<p>$k = \lceil \log_2(n) / 2 \rceil$ をペア数とする。</p>

<strong>定理 7.1（計算量）.</strong> アルゴリズム 7.1 は $O(k)$ 時間で動作し、使用する演算は加算（2ビット幅）、剰余、整数除算（2による）、および比較のみである。乗算 $x \times n$ は参照添字のシフトとして吸収され、走査段階では明示的に現れない。

<em>証明.</em>

- 前処理: $n$ の2進展開は $O(k)$。m4/m6 の抽出は $O(k)$。
- 参照パターン決定: $s$ は定数（$x$ から事前に計算）。$O(1)$。
- 走査: ループは高々 $k + O(1)$ 回。各反復は定数個の $O(1)$ 演算。合計 $O(k)$。
- 後処理: ペア列の整形、末尾ゼロ計数、再ペア化。各 $O(k)$。

<p>全体: $O(k)$。 □</p>

<hr>

<h2>7.4 従来手法との比較</h2>

<strong>従来の算術的計算:</strong>

<pre><code class="">1. x × n を計算（k ビット × 定数 → O(k) の加算、ただし多倍長では O(k²) ないし O(k log k)）
2. +1 する（O(k) のキャリー伝播）
3. 末尾ゼロを数える（O(k)）
4. 2^d で割る（O(k) のシフト）
</code></pre>

<p>標準的な筆算乗算では、$3 \times n$ は $n + 2n$（1回のシフトと1回の加算）で $O(k)$ に見えるが、これは $x=3$ の特殊事情である。$5 \times n = 4n + n$ も同様に $O(k)$ だが、一般の $x$ では $O(k \log x)$ となる。</p>

<strong>m4/m6 走査:</strong>

<pre><code class="">1. m4, m6 を抽出（O(k)）
2. 参照パターンに従い走査（O(k)、ビット参照と1ビット加算のみ）
3. 末尾ゼロを読む（O(k)）
4. 再ペア化（O(k)）
</code></pre>

<p>$O$ 記法の次数は同じであるが、本質的な差異がある：</p>

<strong>差異 1（演算の種類）.</strong> 従来手法は算術演算（加算、シフト）を使う。m4/m6 走査はビット参照と1ビット加算のみ。定数係数が小さい。

<strong>差異 2（構造的透明性）.</strong> 従来手法では $xn+1$ の結果を算術的に得た後、その内部構造は不明である。m4/m6 走査ではキャリーの各ペアでの振る舞い（G/P/K）が計算の副産物として得られる。これは解析的応用（§8）の基盤となる。

<strong>差異 3（乗算の分解）.</strong> m4/m6 走査では乗算 $xn$ が参照パターン（添字のずれ）とペア内1ビット加算に分解されている。$x$ の値は走査の参照先を切り替えるだけであり、多倍長整数の乗算としては現れない。

<hr>

<h2>7.5 正当性の検証</h2>

<p>アルゴリズム 7.1 の正当性を、従来の算術的計算との一致により検証した。</p>

<strong>検証 1（3n+1）.</strong> $n = 1, 3, 5, \ldots, 99$ の50個の奇数に対して、算術計算 $3n+1$ と m4/m6 走査の結果（$xn+1$ の値、$d$、次の奇数 $n'$）が完全に一致することを確認。大数 $n = 127, 255, 511, 1023, 4095, 8191, 65535, 99991, 999999$ でも一致。

<strong>検証 2（5n+1）.</strong> 同一の検証範囲で、算術計算 $5n+1$ と m4/m6 走査の完全一致を確認。

<strong>検証 3（軌道追跡）.</strong> $n=27$ から開始する5n+1 軌道 $27 \to 17 \to 43 \to 27$（3ステップサイクル）を m4/m6 走査で追跡し、各ステップの中間値と最終値が算術計算と一致することを確認。3n+1 についても $n=27$ の軌道を $n=1$ まで追跡し、全ステップで一致を確認。

<hr>

<h2>7.6 汎化の射程</h2>

<p>アルゴリズム 7.1 は $x - 1$ が2の冪である場合に直接適用される。これは $x \in \{3, 5, 9, 17, 33, 65, \ldots\}$ を含む。</p>

<p>$x - 1$ が2の冪でない場合（例: $x = 7$, $x-1 = 6 = 2 \times 3$）は、シフトだけでなく追加の加算段が必要となる。原理的には同じ枠組みで扱えるが、走査が複数パスになる可能性がある。この拡張は今後の課題とする。</p>

$$
7n + 1 = 4n + 2n + n + 1
$$

<p>これは3項の加算であり、2段（m6 段 + m4 段）の構造が3段以上に拡張される。ペア加算の枠組み自体は有効であるが、参照パターンの記述がより複雑になる。</p>

<hr>

<h2>7.7 本節のまとめ</h2>

<p>1. 任意の xn+1 型写像（$x-1$ が2の冪）に対する統一アルゴリズムを定式化した。参照パターンの差し替えだけで異なる $x$ に対応する。</p>

<p>2. 計算量は $O(k)$。走査はビット参照と1ビット加算のみで構成される。乗算 $xn$ は参照添字のシフトとして吸収されている。</p>

<p>3. 従来の算術的計算と $O$ の次数は同じだが、乗算の内部構造が透明に分解されること、および GPK が副産物として取得できることが本手法の利点である。</p>

<p>4. $n = 1 \sim 99$ の全数および大数での検証により正当性を確認した。</p>
        </div>

        <div class="chapter" id="ch7b">
<h2>7.8 走査とGPKツリーの関係</h2>

<p>§4 で導入した GPK（Generate-Propagate-Kill）分類と二分木合成、および §7.1 の走査アルゴリズムの関係を明確にする。</p>

<strong>命題 7.1（走査の自己充足性）.</strong> アルゴリズム 7.1 の走査は、GPK ツリー合成を経由せずに全ペアのキャリーを確定する。各ペア位置 $i$ において m6 段・m4 段の加算を実行し、キャリーを次のペアに渡す。この手続きは GPK 分類の明示的計算を含まない。

<em>証明.</em> アルゴリズム 7.1 のループ本体を検査する。各反復は参照ビットの読み取り（$O(1)$）、2回の1ビット加算（$O(1)$）、キャリーの更新（$O(1)$）のみからなる。GPK 値 $(G<em>i, P</em>i)$ は計算されない。 □

<strong>命題 7.2（GPK 分類の事後導出）.</strong> 走査の各ペアにおいて、参照ビットから GPK 分類を $O(1)$ の追加コストで導出できる。

<em>証明.</em> $G<em>{\text{mid}} = \text{AND}(r^{(6)}, b</em>i)$, $P<em>{\text{mid}} = \text{XOR}(r^{(6)}, b</em>i)$, $G<em>{\text{out}} = \text{AND}(r^{(4)}, a</em>i)$, $P<em>{\text{out}} = \text{XOR}(r^{(4)}, a</em>i)$, $G<em>i = G</em>{\text{out}} \vee (P<em>{\text{out}} \wedge G</em>{\text{mid}})$, $P<em>i = P</em>{\text{out}} \wedge P_{\text{mid}}$。全て $O(1)$ のビット演算。 □

<strong>系 7.1.</strong> 走査の実行と同時に GPK 分類を副産物として得ることが可能であり、追加の計算量は $O(k)$ に対して定数係数の増加に留まる。

<strong>意味.</strong> §4 の GPK 理論は走査アルゴリズムの<strong>正当性の基盤</strong>を提供する。走査がキャリーを正しく確定する理由は、各ペアの GPK 分類が入力キャリーの値に依存しない（§4.2）からである。しかし、走査の<strong>実行</strong>に GPK の明示的計算は不要である。GPK は「なぜ走査が正しいか」を説明する理論的道具であり、「どう計算するか」の実行手続きではない。

<hr>

<h2>7.9 三層アーキテクチャ</h2>

<p>本論文の計算手法は、リソース条件に応じて3つの層で運用される。</p>

<h3>層1：逐次走査（基本）</h3>

<pre><code class="">計算量:     O(k) 時間、O(k) 空間
並列度:     なし（逐次）
GPK使用:   不要（走査のみ）
適用場面:   単一軌道の追跡、小〜中規模の数
利点:       最小のオーバーヘッド、実装が最も単純
</code></pre>

<p>アルゴリズム 7.1 そのもの。参照ビットを読み、2回の1ビット加算とキャリー更新を $k$ 回繰り返す。GPK 分類は計算しない。計算量は $O(k)$ であり、これは漸近的に最適である（入力の読み取りだけで $\Omega(k)$ を要するため）。</p>

<h3>層2：走査 + GPK 分類（解析的）</h3>

<pre><code class="">計算量:     O(k) 時間（定数係数増加）、O(k) 空間
並列度:     なし
GPK使用:   副産物として取得
適用場面:   キャリー構造の解析、サイクル条件の検証、統計収集
利点:       構造情報がタダで手に入る
</code></pre>

<p>走査の各ペアで GPK 分類を同時計算する（命題 7.2）。次の奇数 $n'$ に加えて、各ペアの G/P/K 分類、キャリーの到達距離、m2/m7 パターン（$x=3$ の場合）が得られる。</p>

<p>同じ $O(k)$ のコストから得られる情報の量が質的に異なる。</p>

<h3>層3：GPK ツリー合成（並列）</h3>

<pre><code class="">計算量:     O(k) 作業量、O(log k) 深度
並列度:     O(k / log k) プロセッサで O(log k) 時間
GPK使用:   必須（ツリー合成の入力）
適用場面:   大規模並列検証（2^68 以上）、FPGA/GPU 実装
利点:       深度が対数、ハードウェア carry-lookahead と直結
</code></pre>

<p>§4.7 の二分木合成を使用する。まず全ペアの局所 GPK を $O(k)$ で計算し（各ペア独立、完全並列化可能）、次に二分木で prefix GPK を $O(\log k)$ 段で合成する。各段は AND/OR のみ。</p>

<p>この層が有効になるのは以下の条件が揃うとき：</p>
<p>- $k$ が非常に大きい（$k > 10^6$ 程度）<br>
- 並列プロセッサが利用可能（GPU, FPGA, ASIC）<br>
- 単一ステップの遅延が律速（走査の $O(k)$ が許容できない）</p>

<p>carry-lookahead adder [6] として50年以上のハードウェア実績があるため、実装は確立された技術の適用である。</p>

<h3>層の選択基準</h3>

<table>
<tr><th>条件</th><th>推奨層</th></tr>
<tr><td>軌道追跡、$k < 10^4$</td><td>層1（走査のみ）</td></tr>
<tr><td>構造解析、サイクル研究</td><td>層2（走査 + GPK）</td></tr>
<tr><td>大規模検証、$k > 10^6$、並列HW</td><td>層3（GPK ツリー）</td></tr>
<tr><td>情報密度を最大化したい</td><td>層2</td></tr>
<tr><td>遅延を最小化したい</td><td>層3</td></tr>
</table>

<hr>

<h2>7.10 計算量の統合的評価</h2>

<p>3つの層と従来手法を統合的に比較する。</p>

<strong>表 7.1: 計算量の比較.</strong>

<table>
<tr><th>手法</th><th>1ステップ時間</th><th>深度（並列）</th><th>乗算の形態</th><th>構造情報</th></tr>
<tr><td>従来（算術）</td><td>$O(k)$</td><td>$O(k)$</td><td>明示的 shift+add</td><td>なし</td></tr>
<tr><td>層1（走査）</td><td>$O(k)$</td><td>$O(k)$</td><td><strong>参照添字に吸収</strong></td><td>なし</td></tr>
<tr><td>層2（走査+GPK）</td><td>$O(k)$</td><td>$O(k)$</td><td><strong>参照添字に吸収</strong></td><td><strong>あり</strong></td></tr>
<tr><td>層3（GPKツリー）</td><td>$O(k)$</td><td>$O(\log k)$</td><td><strong>参照添字に吸収</strong></td><td><strong>あり</strong></td></tr>
</table>

<strong>注意.</strong> 漸近的な $O(k)$ は従来手法と層1/2 で同一である。差異は以下の定数係数レベルにある。

<strong>(1) 演算の種類.</strong> 従来手法は多倍長整数の乗算（GMP レベルでは shift + add だが、内部で carry 伝播を含む）。層1/2 は1ビット加算と AND/XOR のみ。ハードウェアレベルでの演算コストが異なる。

<strong>(2) 情報の抽出効率.</strong> 従来手法は $n'$ の数値のみ。層2 は同じコストで GPK 分類、キャリー地形、$d$、交換情報を得る。同一の計算エネルギーから得られる情報量に質的差異がある。

<strong>(3) 並列化可能性.</strong> 従来手法のキャリー伝播は逐次的であり、並列化には carry-lookahead の別途実装が必要。層3 は GPK ツリーとして自然に並列化される。

<strong>(4) $x$ への汎用性.</strong> 従来手法は $x$ ごとに乗算の実装が異なる。層1/2/3 は参照パターン（4つの添字）の差し替えのみで任意の $x$（$x-1$ が2の冪）に対応する。
        </div>

        <div class="chapter" id="ch8">
<h1>8. Cycle Analysis via m4/m6（m4/m6 によるサイクル解析）</h1>

<p>統一アルゴリズムの応用として、5n+1 の既知サイクルを m4/m6 空間で解析する。3n+1 との構造的対比を行い、m4/m6 表現がサイクル研究に与える見通しを示す。</p>

<hr>

<h2>8.1 5n+1 の既知サイクル</h2>

<p>5n+1 には以下の非自明なサイクルが知られている [2]：</p>

<strong>サイクル A（2元）:</strong> $1 \to 3 \to 1$

<strong>サイクル B（3元）:</strong> $13 \to 33 \to 83 \to 13$

<strong>サイクル C（3元）:</strong> $27 \to 17 \to 43 \to 27$

<p>以下、各サイクルの m4/m6 軌道を完全に記述する。</p>

<hr>

<h2>8.2 サイクル A の m4/m6 軌道</h2>

<table>
<tr><th>ステップ</th><th>$n$</th><th>2進</th><th>m4</th><th>m6</th><th>$5n+1$</th><th>$d$</th><th>交換</th></tr>
<tr><td>0</td><td>1</td><td>01</td><td>(0)</td><td>(1)</td><td>6</td><td>1</td><td>⇄</td></tr>
<tr><td>1</td><td>3</td><td>11</td><td>(1)</td><td>(1)</td><td>16</td><td>4</td><td>—</td></tr>
<tr><td>→</td><td>1</td><td>01</td><td>(0)</td><td>(1)</td><td></td><td></td><td></td></tr>
</table>

<p>m4 軌道: $(0) \to (1) \to (0)$
m6 軌道: $(1) \to (1) \to (1)$</p>

<strong>観察.</strong> m6 は全ステップで $(1)$ に固定されている。m4 のみが $0 \to 1 \to 0$ と振動する。$d$ は1と4で交代し、交換は1回おきに発生する。

<hr>

<h2>8.3 サイクル B の m4/m6 軌道</h2>

<table>
<tr><th>ステップ</th><th>$n$</th><th>2進</th><th>m4</th><th>m6</th><th>$5n+1$</th><th>$d$</th><th>交換</th></tr>
<tr><td>0</td><td>13</td><td>1101</td><td>(1,0)</td><td>(1,1)</td><td>66</td><td>1</td><td>⇄</td></tr>
<tr><td>1</td><td>33</td><td>100001</td><td>(1,0,0)</td><td>(0,0,1)</td><td>166</td><td>1</td><td>⇄</td></tr>
<tr><td>2</td><td>83</td><td>01010011</td><td>(0,0,0,1)</td><td>(1,1,0,1)</td><td>416</td><td>5</td><td>⇄</td></tr>
<tr><td>→</td><td>13</td><td>1101</td><td>(1,0)</td><td>(1,1)</td><td></td><td></td><td></td></tr>
</table>

<p>m4 軌道: $(1,0) \to (1,0,0) \to (0,0,0,1) \to (1,0)$
m6 軌道: $(1,1) \to (0,0,1) \to (1,1,0,1) \to (1,1)$</p>

<strong>観察.</strong> ペア数が $2 \to 3 \to 4 \to 2$ と変動する。13→33 でペア数が増加し、83→13 の $d=5$ で大幅に減少して元に戻る。全ステップで $d$ が奇数であり、m4⇔m6 交換が毎回発生する。

<hr>

<h2>8.4 サイクル C の m4/m6 軌道</h2>

<table>
<tr><th>ステップ</th><th>$n$</th><th>2進</th><th>m4</th><th>m6</th><th>$5n+1$</th><th>$d$</th><th>交換</th></tr>
<tr><td>0</td><td>27</td><td>011011</td><td>(0,1,1)</td><td>(1,0,1)</td><td>136</td><td>3</td><td>⇄</td></tr>
<tr><td>1</td><td>17</td><td>010001</td><td>(0,0,0)</td><td>(1,0,1)</td><td>86</td><td>1</td><td>⇄</td></tr>
<tr><td>2</td><td>43</td><td>101011</td><td>(1,0,1)</td><td>(0,1,1)</td><td>216</td><td>3</td><td>⇄</td></tr>
<tr><td>→</td><td>27</td><td>011011</td><td>(0,1,1)</td><td>(1,0,1)</td><td></td><td></td><td></td></tr>
</table>

<p>m4 軌道: $(0,1,1) \to (0,0,0) \to (1,0,1) \to (0,1,1)$
m6 軌道: $(1,0,1) \to (1,0,1) \to (0,1,1) \to (1,0,1)$</p>

<strong>観察.</strong> ペア数は全ステップで $k=3$ に固定。桁数が変動しないサイクルである。$d$ は 3,1,3 と交代し、全ステップで交換が発生する。

<p>特筆すべき点として、m4(27) = $(0,1,1)$ と m6(43) = $(0,1,1)$ が一致し、m6(27) = $(1,0,1)$ と m4(43) = $(1,0,1)$ が一致する。すなわち 27 と 43 は m4 と m6 が完全に入れ替わった関係にある。</p>

<hr>

<h2>8.5 サイクルの m4/m6 構造的特徴</h2>

<p>3つのサイクルに共通する構造を抽出する。</p>

<strong>（1）交換の周期性.</strong> 全てのサイクルで $d$ が奇数のステップが出現し、m4⇔m6 交換が発生する。サイクル B と C では全ステップで交換が起きている。サイクル A では $d=4$（偶数）のステップがあるが、直前の $d=1$ で交換が起きるため、2ステップで m4/m6 の対応が元に戻る。

<strong>（2）ペア数の変動パターン.</strong> サイクル C はペア数固定（$k=3$）、サイクル B はペア数変動（$k = 2 \to 3 \to 4 \to 2$）。ペア数が変動するサイクルでは、大きな $d$（サイクル B の $d=5$）によって一気にペア数が減少する「圧縮ステップ」が存在する。

<strong>（3）m4/m6 の対称性.</strong> サイクル C の 27 と 43 に見られるように、サイクル内の要素間で m4 と m6 が入れ替わった対称関係が生じ得る。これは交換操作の蓄積による構造的帰結である。

<hr>

<h2>8.6 3n+1 のサイクルとの対比</h2>

<p>3n+1 の既知のサイクルは $1 \to 1$（自明サイクル、$3 \times 1 + 1 = 4, d=2$）のみである。コラッツ予想は、これが唯一のサイクルであることを主張する。</p>

<table>
<tr><th></th><th>$n$</th><th>m4</th><th>m6</th><th>$3n+1$</th><th>$d$</th><th>交換</th><th>$n'$</th></tr>
<tr><td></td><td>1</td><td>(0)</td><td>(1)</td><td>4</td><td>2</td><td>—</td><td>1</td></tr>
</table>

<p>$d=2$（偶数）であり交換は発生しない。m4 = $(0)$, m6 = $(1)$ は不動点。</p>

<strong>構造的対比:</strong>

- 5n+1: 複数サイクル、ペア数変動、m4⇔m6 交換が頻繁
- 3n+1: 唯一のサイクル（予想）、$d=2$ の不動点、交換なし

<p>3n+1 の自明サイクルが m4/m6 空間の不動点であることは、§5 で示した「構造的特権」と整合する。m4 段の GPK が m2/m7 として直読できる（定理 5.1）ことは、写像が n のペア構造を「透明に」変換することを意味し、複雑なサイクルが形成されにくい構造的理由の候補となる。</p>

<hr>

<h2>8.7 サイクル条件の定式化</h2>

<p>m4/m6 空間でのサイクル条件を定式化する。</p>

<strong>定義 8.1.</strong> 奇数の列 $n<em>0, n</em>1, \ldots, n<em>{p-1}$ が周期 $p$ のサイクルをなすとは、$T(n</em>i) = n_{i+1 \bmod p}$ が全ての $i$ で成立することをいう。

<p>m4/m6 空間では、これは以下の条件に翻訳される。</p>

<strong>命題 8.1（サイクルの m4/m6 条件）.</strong> $\{n<em>0, \ldots, n</em>{p-1}\}$ が5n+1 のサイクルをなすための必要条件：

<strong>(i) ペア数条件:</strong> $\sum<em>{i=0}^{p-1} (\delta</em>i - d<em>i) = 0$。ここで $\delta</em>i$ はステップ $i$ でのペア加算によるビット増加数、$d_i$ は末尾ゼロ数。サイクルは出発点のビット長に戻る。

<strong>(ii) 交換条件:</strong> $\sum<em>{i=0}^{p-1} d</em>i \equiv 0 \pmod{2}$。$d$ の総和が偶数でなければ、$p$ ステップ後に m4/m6 の対応が元に戻らない。

<strong>(iii) ビットパターン条件:</strong> $p$ ステップの走査を合成した結果が、元の m4/m6 パターンを再現する。

<em>証明.</em> (i) と (ii) はサイクルの定義と §6 の交換原理から直ちに従う。(iii) は走査の具体的合成であり、条件の明示的記述は今後の課題である。 □

<strong>検証.</strong> サイクル C（27→17→43→27）: $d = (3, 1, 3)$。$\sum d_i = 7$（奇数）であり、条件 (ii) を破るように見える。

<p>しかし、$d=3$ のようなビット除去はペア境界の再配置を含み、交換の判定は $d \bmod 2$ の単純な合計ではなく、各ステップでのビット列全体の整合性に依存する。条件 (ii) は $\sum d_i$ の偶奇ではなく、再ペア化の境界ずれを考慮した精密な定式化が必要である。この精密化は今後の課題とする。</p>

<hr>

<h2>8.8 本節のまとめ</h2>

<p>1. 5n+1 の3つの既知サイクルを m4/m6 空間で完全に記述した。各ステップの m4/m6 変遷、GPK 分類、$d$ の値、交換の有無を示した。</p>

<p>2. サイクルに共通する構造的特徴を抽出した：交換の周期性、ペア数変動パターン、m4/m6 の対称関係。</p>

<p>3. 3n+1 の自明サイクル（$n=1$）が m4/m6 不動点であることを確認し、5n+1 との構造的対比を行った。</p>

<p>4. m4/m6 空間でのサイクル条件を定式化した。精密化は今後の課題であるが、ペア数条件と交換条件が必要条件を与える。</p>
        </div>

        <div class="chapter" id="ch9">
<h1>9. Discussion（考察）</h1>

<hr>

<h2>9.1 先行研究との関係</h2>

<p>本論文の結果を既存の研究と対比する。</p>

<strong>Syracuse 関数との関係.</strong> Syracuse 関数 $T(n) = (3n+1)/2^{v<em>2(3n+1)}$ [1] は偶数ステップの省略であり、奇数→奇数の写像を1つの式で定義する。しかし $3n+1$ の内部構造には踏み込まず、$v</em>2$ の値も計算してみなければわからない。本論文の m4/m6 走査は $T(n)$ と同じ結果を与えるが、その導出過程で各ペアのキャリー構造（GPK 分類）を副産物として得る。Syracuse は写像の<strong>定義</strong>であり、m4/m6 走査は写像の<strong>分解</strong>である。

<strong>2進数解析との関係.</strong> Wirsching [3] および Lagarias [1] による2進数に基づくコラッツ写像の解析は、$3n+1$ を $2n + n + 1$ として扱い、ビット列の変化を追跡する手法を含む。本論文のアプローチはこの方向の延長上にあるが、以下の点で異なる：

- 2ビットペアへの分解と16述語体系の導入は、個々のビットではなく<strong>ペアの型</strong>（4種）を基本単位とする。これにより、キャリーの振る舞いがペア型の関数として記述される。
- m4/m6 基底の選択により、写像が (m4, m6) 空間上の変換として閉じた形で記述される。
- 16述語の完備性と各ペア独立性を利用して、「何が表現可能で何が不可能か」を証明する道具を得た（定理 5.2, 5.3）。

<strong>Carry-lookahead adder との関係.</strong> §4 の GPK 分解は、Bedrij [6] 以来の carry-lookahead 技術と同じ原理に基づく。本論文の貢献は、この技術をコラッツ型写像のキャリー構造に接続し、GPK 分類がペア述語（特に m2/m7）として解釈できることを示した点にある。計算機科学の標準的技法を数論の問題に架橋したものと位置づけられる。

<hr>

<h2>9.2 本論文の新規性</h2>

<p>本論文が新たに提示した内容を整理する。</p>

<strong>(1) m4/m6 ペア射影の枠組み.</strong> 自然数を2ビットペアに分解し、左右のビット列 m4/m6 を基底とする述語体系を定義した。16述語の完備性、基底の復元性、各ペア独立性を確立した。

<strong>(2) xn+1 のビット走査への分解.</strong> xn+1 の奇数→奇数遷移が、m4/m6 のビット走査で計算可能であることを示した。乗算 $xn$ は $(x-1)n$ のシフトとして参照添字のずれに分解され、走査段階ではペア内1ビット加算のみで記述される。

<strong>(3) 3n+1 の構造的特権の証明.</strong> x=3 において m4 段 GPK が m2/m7 に一致すること（定理 5.1）、および x≥5 ではこの一致が原理的に不可能であること（定理 5.2）を証明した。分類定理（定理 5.3）により、x=3 が16述語空間内でキャリー構造が閉じる唯一のパラメータであることを示した。

<strong>(4) ÷2 の交換原理.</strong> ÷2 操作が m4⇔m6 の役割交換として記述されること（定理 6.1）を示した。

<strong>(5) 統一アルゴリズム.</strong> 参照パターンの差し替えだけで任意の xn+1 に対応するアルゴリズムを定式化した（アルゴリズム 7.1）。

<hr>

<h2>9.3 計算実験による検証</h2>

<p>本論文で実装したアルゴリズム 7.1 により、$x=3, 5, 17$ の GPK 分布を同一条件で計測した。各奇数 $n \leq 10^7$ について停止時間法（$n$ 未満に到達するまでの反復、最大 500 ステップ）を適用し、全ステップの GPK を集約した結果を表 9.1 に示す。</p>

<table border="1" cellpadding="4" style="border-collapse:collapse; margin:1em auto;">
<caption><strong>表 9.1.</strong> コラッツ型写像 $T(n)=(xn+1)/2^d$ の GPK 分布比較（$n \leq 10^7$、max_steps = 500）</caption>
<tr><th></th><th>$3n+1$（$s=1$）</th><th>$5n+1$（$s=2$）</th><th>$17n+1$（$s=4$）</th></tr>
<tr><td>検証した奇数の数</td><td>4,999,999</td><td>4,999,999</td><td>4,999,999</td></tr>
<tr><td>全数収束</td><td><strong>Yes</strong></td><td>No</td><td>No</td></tr>
<tr><td>最大停止時間</td><td>155</td><td>490</td><td>18</td></tr>
<tr><td>平均ステップ数/数</td><td>3.5</td><td>179</td><td>456</td></tr>
<tr><td>G (Generate) %</td><td><strong>38.41</strong></td><td>36.91</td><td>37.26</td></tr>
<tr><td>P (Propagate) %</td><td><strong>28.32</strong></td><td>25.45</td><td>25.09</td></tr>
<tr><td>K (Kill) %</td><td><strong>33.26</strong></td><td>37.64</td><td>37.65</td></tr>
<tr><td>$G/K$ 比</td><td><strong>1.15</strong></td><td>0.98</td><td>0.99</td></tr>
<tr><td>最大キャリー連鎖長</td><td>19</td><td>61</td><td>74</td></tr>
</table>

<p><strong>観察 1: $G/K$ 非対称性は $x=3$ に固有.</strong> $x=3$ では $G/K \approx 1.15$ と明確に非対称であるのに対し、$x=5$ および $x=17$ では $G/K \approx 0.98$–$0.99$ とほぼ対称である。定理 B により、$x=3$ の GPK は入力 $n$ 自身のペア述語（$G = \mathrm{m2}$, $P = \mathrm{m7}$, $K = \mathrm{m9}$）に一致するため、奇数のビットパターンの偏りがそのまま GPK 分布に反映される。一方 $x \geq 5$ では、GPK が隣接ペア間の相関に依存する（定理 C）ため、入力固有の構造が混合され、$G \approx K$ に均質化される。この $G/K$ 非対称性の有無は、構造的閉鎖性の数値的指標と見なせる。</p>

<p><strong>観察 2: $P \approx 25\%$ は $x \geq 5$ に共通.</strong> $x=5$ で $P = 25.45\%$、$x=17$ で $P = 25.09\%$ であり、いずれも $1/4$ に近い。これは偶然ではない。$x \geq 5$ では GPK の直列合成において、m4 段と m6 段の Propagate が独立に発生し、$P = P_{\mathrm{m4}} \cdot P_{\mathrm{m6}} \approx 1/2 \times 1/2 = 1/4$ となる。一方 $x=3$ では $P = 28.32\%$ と高い。これは m4 段の入力が $(b_i, a_i)$——すなわち現ペアそのもの——であり、m6 段との間に相関があるためである。</p>

<p><strong>観察 3: キャリー連鎖長は $s$ とともに増大.</strong> 最大キャリー連鎖長は $x=3$（$s=1$）で 19、$x=5$（$s=2$）で 61、$x=17$（$s=4$）で 74 と、参照パターンのシフト距離 $s$ の増大に伴い伸長する。$x=3$ では GPK がペア内述語で決定されるため、K の出現が入力のビットパターンに直接対応し、連鎖が短く抑制される。$x \geq 5$ ではキャリー構造がペア間に拡散し、K の出現が入力構造と乖離するため、長い Propagate 連鎖が生じやすい。</p>

<hr>

<h2>9.4 本論文の限界</h2>

<p>率直に述べるべき限界がある。</p>

<strong>(1) コラッツ予想の証明には至っていない.</strong> 定理 5.3 は 3n+1 の構造的特異性を同定するが、全軌道の収束を証明するものではない。「なぜ 3n+1 か」に構造的回答を与えたが、「なぜ全ての軌道が1に至るか」には答えていない。

<strong>(2) キャリー伝播の逐次性.</strong> m4 段 GPK がペア内述語で読めること（定理 5.1）は、キャリーの<strong>局所分類</strong>に関する結果である。キャリーの<strong>伝播</strong>——G の位置から P の列を通って K にぶつかるまでの走査——は依然として逐次的であり、閉じた式で表現されていない。

<strong>(3) サイクル条件の不完全性.</strong> §8 で定式化したサイクル条件は必要条件にとどまり、十分条件は得られていない。m4/m6 パターンの $p$ ステップ合成を閉じた形で記述することが次の課題である。

<strong>(4) $x-1$ が2の冪でない場合.</strong> $x = 7, 11, 13, \ldots$ への拡張は原理的に可能だが、加算段が増えるため記述が複雑になる。本論文では扱わなかった。

<hr>

<h2>9.5 「道具」と「結果」の位置づけ</h2>

<p>本論文は、新しい道具（m4/m6 述語体系と走査アルゴリズム）を提示し、その道具の性質（定理 A, B, C および分類定理）を証明した段階にある。この道具で何かを「切る」——たとえばサイクルの非存在を証明する、軌道の統計的性質を導出する——には至っていない。</p>

<p>しかし、道具自体にいくつかの内在的価値がある：</p>

- <strong>16述語の枠組みは完備である。</strong> 2入力ブール関数を全て含むため、「この枠組みで表現できない」という否定的結果（定理 5.2）は原理的な限界を示す。
- <strong>分類定理は構成的である。</strong> x=3 の特権性は存在証明ではなく、参照パターンの具体的計算から導かれる。
- <strong>アルゴリズムは実装可能である.</strong> 理論的構成物ではなく、計算機で実行・検証可能な手続きとして与えられている。

<hr>

<h2>9.6 今後の方向</h2>

<p>本論文の枠組みから自然に生じる研究方向を列挙する。</p>

<strong>(1) GPK 列のパターン解析.</strong> 3n+1 において、m2/m7/m9 のビット列が1ステップの走査でどのように変換されるかを統計的に解析する。特に、m9（Kill、ペア $(0,0)$）の位置が軌道の進行とともにどう変化するかは、キャリー伝播の到達距離を支配するため重要である。

<strong>(2) 桁数変動の期待値.</strong> ステップ $n \to n'$ でのビット長の変化 $\Delta = \log<em>2(n') - \log</em>2(n)$ の期待値を、m4/m6 のペア型分布から導出する。$\Delta < 0$ が典型的であることを示せれば、「ほとんど全ての軌道が縮む」という統計的結果への道が開ける。

<strong>(3) m4/m6 空間の力学系.</strong> 写像 $T: (\text{m4}, \text{m6}) \to (\text{m4}', \text{m6}')$ を力学系として定式化し、アトラクタの構造を調べる。3n+1 の不動点 $(\text{m4}, \text{m6}) = ((0), (1))$ がグローバルアトラクタであることを示せれば、コラッツ予想に等価な主張となる。

<strong>(4) サイクルの m4/m6 特徴づけ.</strong> §8 のサイクル条件を精密化し、m4/m6 パターンの周期性からサイクルの非存在/存在を判定する条件を導出する。

<strong>(5) 大規模数値実験.</strong> BigInt 対応の実装により、$10^{100}$ 級の数に対する m4/m6 軌道の統計的性質を収集する。GPK 分類の分布、キャリー伝播長の分布、ペア数変動のヒストグラムなどが対象となる。

<hr>

<h2>9.6 本節のまとめ</h2>

<p>本論文は、コラッツ型写像を2ビットペア述語体系の枠組みで分解し、3つの定理（m4 段一致、16述語の限界、分類定理）を証明した。これは写像の「見え方を変えた」段階であり、新しい道具の提示とその基本的性質の確立に相当する。コラッツ予想の証明には至っていないが、3n+1 の構造的特異性を同定し、今後の解析的アプローチの基盤を提供する。</p>
        </div>

        <div class="chapter" id="ch10">
<h1>10. Conclusion（結論）</h1>

<p>本論文は、自然数の2ビットペア分解に基づく述語体系を導入し、コラッツ型写像 $T(n) = (xn+1)/2^d$ の構造分解を行った。得られた主要結果を要約する。</p>

<hr>

<h2>10.1 主要結果の要約</h2>

<strong>結果 1：ペア述語体系の確立（§2）.</strong>
自然数 $n$ の2進表現を2ビットペアに分解し、左ビット列 m4(LEFT) と右ビット列 m6(RIGHT) を基底とする16個のブール述語体系 m1〜m16 を定義した。16述語は2入力ブール関数として完備であり、全て m4 と m6 のビットごと演算で表現される。16述語は各ペア独立であり、この性質はブール合成で保存される。

<strong>結果 2：xn+1 のビット走査への還元（§3, §4, §7）.</strong>
$xn+1 = (x-1)n + n + 1$ の分解において、$(x-1)n$ の左シフトがペア構造上の参照パターンを決定することを示した。各ペア位置での加算は m6 段と m4 段の2段構造をとり、キャリーは LSB からの $O(k)$ 走査1回で確定する。これにより、乗算 $x \times n$ を参照パターンのシフトとペア内加算に分解した統一アルゴリズム（アルゴリズム 7.1）を定式化した。参照パターンの差し替えだけで異なるパラメータ $x$ に対応する。

<strong>結果 3：3n+1 の構造的特権（§5）.</strong>
本論文の核心的結果である。

- <strong>定理 B（定理 5.1）:</strong> $x=3$ において、m4 段の Generate は m2(AND) に、Propagate は m7(XOR) に、Kill は m9(NOR) に各ペア位置で一致する。n のペア型を読むだけでキャリーの生成・伝播・吸収が判明する。

- <strong>定理 C（定理 5.2）:</strong> $x \geq 5$ において、m4 段 GPK は16述語のいかなるブール合成でも表現できない。これは16述語の各ペア独立性と、写像が要求する位置間相関の間の原理的な不整合に起因する。

- <strong>分類定理（定理 5.3）:</strong> m4 段 GPK がペア内述語で閉じるのは $x = 3$ のときに限る。3n+1 は、16述語の完備空間内でキャリー構造が「透明」になる唯一のコラッツ型写像である。

<strong>結果 4：÷2 の交換原理（§6）.</strong>
÷2 操作が m4 と m6 の役割交換として記述されることを示した。末尾ゼロ数 $d$ の偶奇が交換の有無を決定する。情報は保存され、÷2 は情報の位置移動である。

<hr>

<h2>10.2 意義</h2>

<p>本論文の結果は、コラッツ型写像に対する新しい視座を提供する。</p>

<p>第一に、<strong>乗算の構造的分解</strong>。$xn+1$ という算術演算が、ビット参照パターンとキャリー走査に分解された。$x$ の値は参照添字のシフトとして吸収され、走査段階では現れない。2進数レベルでは shift+add は乗算と等価であるが、本手法はその内部機構をペア単位で透明に記述することで、キャリー構造（GPK）を直接観察可能にした。</p>

<p>第二に、<strong>3n+1 の特異性の同定</strong>。「なぜ 3n+1 か」という問いに対して、本論文は構造的回答を提示した。$x=3$ は、シフト量がペア幅未満であるため加算がペア内に折り返される唯一のパラメータであり、その結果としてキャリー構造が n のペア内述語（m2/m7/m9）で直接記述される。この「透明性」は $x \geq 5$ では原理的に成立し得ない。</p>

<p>第三に、<strong>限界の明示</strong>。16述語の各ペア独立性は、この枠組みの強みであると同時に限界でもある。ペア間の相関——コラッツ型写像のキャリー伝播が本質的に要求する情報——は16述語の外にあり、これを記述するには枠組みの拡張（隣接ペア間述語の導入、あるいは走査という動的操作の利用）が必要である。本論文では後者（走査）を採用した。</p>

<hr>

<h2>10.3 展望</h2>

<p>本論文は「道具の提示とその基本的性質の確立」の段階にある。この道具を用いてコラッツ予想に迫るには、以下の方向が考えられる。</p>

- m2/m7/m9 パターンの統計的性質から、軌道のビット長変化の期待値を導出すること。
- m4/m6 空間上の力学系として写像 $T$ を定式化し、アトラクタの構造を解析すること。
- サイクル条件の精密化により、非自明サイクルの非存在を（少なくとも制限された範囲で）証明すること。

<p>これらは今後の研究課題である。</p>

<hr>

<h2>10.4 結語</h2>

<p>コラッツ予想は、初等的な定式化に反して80年以上証明を拒んでいる。本論文はこの問題を解決するものではない。しかし、写像の内部構造を述語体系の言葉で記述し、3n+1 がその体系内で特権的な地位を占めることを証明した。問題の解決にはまだ距離があるが、問題の構造は少し見えやすくなったと考える。</p>

<hr>
<hr>

<h1>References（参考文献）</h1>

<p>[1] J. C. Lagarias, "The 3x+1 problem and its generalizations," <em>American Mathematical Monthly</em>, vol. 92, no. 1, pp. 3–23, 1985.</p>

<p>[2] R. K. Guy, <em>Unsolved Problems in Number Theory</em>, 3rd ed. New York: Springer, 2004.</p>

<p>[3] G. J. Wirsching, <em>The Dynamical System Generated by the 3n+1 Function</em>, Lecture Notes in Mathematics, vol. 1681. Berlin: Springer, 1998.</p>

<p>[4] R. Terras, "A stopping time problem on the positive integers," <em>Acta Arithmetica</em>, vol. 30, pp. 241–252, 1976.</p>

<p>[5] C. J. Everett, "Iteration of the number-theoretic function f(2n)=n, f(2n+1)=3n+2," <em>Advances in Mathematics</em>, vol. 25, pp. 42–45, 1977.</p>

<p>[6] O. J. Bedrij, "Carry-select adder," <em>IRE Transactions on Electronic Computers</em>, vol. EC-11, no. 3, pp. 340–346, 1962.</p>

<hr>
<hr>

<h1>Appendix 概要（付録）</h1>

<p>本論文の完全版には以下の付録を含む。</p>

<strong>Appendix A: 16述語完全定義表.</strong>
m1〜m16 の定義、真理値表、m4/m6 による表現、補数対の対応を一覧する。

<strong>Appendix B: n=27 の完全計算トレース.</strong>
5n+1 サイクル 27→17→43→27 の各ステップについて、ペアごとの参照ビット、局所 GPK、キャリー値、出力ビットを全て列挙する。3n+1 の n=27 軌道（n=1 到達まで）についても同様のトレースを与える。

<strong>Appendix C: GPK ツリー合成の形式的定義.</strong>
GPK 合成の結合性（命題 4.3）の完全な証明、二分木合成アルゴリズムの擬似コード、計算量解析を含む。

<strong>Appendix D: 参照パターンの一般導出.</strong>
シフト量 $s$ に対する参照ビット $(r<em>i^{(4)}, r</em>i^{(6)})$ の一般公式の導出。$x-1$ が2の冪でない場合の拡張についての考察を含む。

<strong>Appendix E: 検証用コード.</strong>
統一アルゴリズム（アルゴリズム 7.1）の Python 実装。3n+1 および 5n+1 に対する算術計算との一致検証スクリプト。16述語の網羅照合（定理 C の検証）スクリプト。
        </div>

        <hr style="margin: 40px 0;">
        <p style="text-align:center; color:#999; font-size:0.9em;">
            生成日時: 2026-02-06<br>
            このHTMLは11個のMarkdownチャプターファイルから自動生成されました<br>
            (Chapter 1-10、第7章は前半・後半の2ファイル構成)
        </p>
    </div>
</body>
</html>