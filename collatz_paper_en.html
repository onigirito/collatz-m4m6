<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pair Predicate Decomposition of Collatz-type Maps and the Structural Closure of 3n+1</title>
    <meta name="citation_title" content="Pair Predicate Decomposition of Collatz-type Maps (xn+1)/2^d and the Structural Closure of 3n+1">
    <meta name="citation_author" content="Honda, Yukihiro">
    <meta name="citation_publication_date" content="2026/02/09">
    <meta name="citation_doi" content="10.5281/zenodo.18521822">
    <meta name="citation_pdf_url" content="https://zenodo.org/records/18522403/files/collatz_paper_en.pdf">
    <meta name="citation_abstract" content="We decompose the binary representation of a natural number n into 2-bit pairs and introduce a system of 16 Boolean predicates defined on each pair, with the left-bit projection m4 and right-bit projection m6 serving as basis. Within this framework, we decompose the additive structure of Collatz-type maps T(n) = (xn+1)/2^d and classify the carry behavior at each pair position as Generate/Propagate/Kill (GPK).">
    <meta name="citation_keywords" content="Collatz conjecture; 3n+1 problem; pair predicate decomposition; carry propagation; GPK classification">
    <meta name="citation_language" content="en">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Screen styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Times New Roman', 'Latin Modern Roman', Georgia, serif;
            font-size: 11pt;
            line-height: 1.6;
            color: #000;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .paper {
            max-width: 210mm;
            margin: 0 auto;
            background-color: white;
            padding: 25mm 25mm 30mm 25mm;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1.paper-title {
            font-size: 16pt;
            text-align: center;
            margin: 0 0 8pt 0;
            border: none;
            line-height: 1.3;
        }

        .author { text-align: center; font-size: 11pt; margin-bottom: 20pt; }

        .abstract-box {
            margin: 20pt 20pt;
            padding: 10pt 15pt;
            border-left: 3pt solid #333;
            background-color: #f9f9f9;
        }
        .abstract-box h2 { font-size: 12pt; margin-bottom: 6pt; border: none; }

        h1 { font-size: 14pt; margin: 24pt 0 10pt 0; border-bottom: 1.5pt solid #000; padding-bottom: 3pt; }
        h2 { font-size: 12pt; margin: 18pt 0 8pt 0; border-bottom: 0.5pt solid #ccc; padding-bottom: 2pt; }
        h3 { font-size: 11pt; margin: 12pt 0 6pt 0; font-style: italic; }

        p { margin-bottom: 8pt; text-align: justify; }

        table { width: auto; border-collapse: collapse; margin: 10pt auto; font-size: 10pt; }
        th, td { border: 1pt solid #999; padding: 4pt 8pt; text-align: center; }
        th { background-color: #eee; font-weight: bold; }
        caption { font-size: 10pt; margin-bottom: 4pt; font-weight: bold; }

        pre { background-color: #f4f4f4; padding: 8pt; border: 0.5pt solid #ccc; font-size: 9pt; overflow-x: auto; margin: 8pt 0; }
        code { font-family: 'Courier New', monospace; font-size: 9.5pt; }

        .theorem { margin: 10pt 0; padding: 8pt 12pt; border-left: 3pt solid #333; background-color: #fafafa; }
        .theorem-title { font-weight: bold; }
        .derivation { margin: 6pt 0 10pt 0; }
        .derivation::after { content: " \25A1"; }

        ul, ol { margin-left: 20pt; margin-bottom: 8pt; }
        li { margin-bottom: 4pt; }

        hr { border: none; border-top: 0.5pt solid #ccc; margin: 16pt 0; }

        .page-break { page-break-before: always; }

        /* Print styles */
        @media print {
            body { background: white; padding: 0; margin: 0; font-size: 10.5pt; }
            .paper { box-shadow: none; padding: 0; max-width: none; }

            @page { size: A4; margin: 25mm 20mm 25mm 20mm; }

            h1 { page-break-after: avoid; }
            h2 { page-break-after: avoid; }
            table { page-break-inside: avoid; }
            .theorem { page-break-inside: avoid; }
            .page-break { page-break-before: always; }
        }
    </style>
</head>
<body>
<div class="paper">

<!-- ============ TITLE PAGE ============ -->
<h1 class="paper-title">Pair Predicate Decomposition of Collatz-type Maps \((xn+1)/2^d\)<br>and the Structural Closure of \(3n+1\)</h1>

<div class="author">
    Yukihiro Honda
    <br>February 2026 (v2: revised with complete finite case analysis)
</div>

<!-- ============ ABSTRACT ============ -->
<div class="abstract-box">
<h2>Abstract</h2>
<p>
We decompose the binary representation of a natural number \(n\) into 2-bit pairs and introduce a system of 16 Boolean predicates defined on each pair, with the left-bit projection m4 and right-bit projection m6 serving as basis. Within this framework, we decompose the additive structure of Collatz-type maps \(T(n) = (xn+1)/2^d\) and classify the carry behavior at each pair position as Generate/Propagate/Kill (GPK).
</p>
<p>
Our main result is the following. For \(x=3\), the GPK of the upper stage (m4-stage) of the addition coincides, at every pair position, with the intra-pair predicates m2(AND) and m7(XOR) of the input \(n\) itself (Theorem B). That is, the carry structure of \(3n+1\) can be read directly from the encoding of \(n\). We call this property <b>structural closure</b>. In contrast, we establish that this coincidence fails for all \(x \geq 5\) (Theorem C). For \(x \geq 5\), the GPK depends on correlations between adjacent pairs, but since all 16 predicates are per-pair independent, they cannot express inter-pair correlations.
</p>
<p>
From these results it follows that the m4-stage carry structure of the map closes within the predicate space only for \(x=3\) (Classification Theorem). This per-pair closure of the m4-stage, combined with exhaustive finite case analysis of the scan and re-pairing transitions (Tables 5.1, 5.2), yields a deterministic finite-state system in which the complete one-step dynamics are algebraically determined. Within this system, the activation condition for carry generation (G-dominance) and the activation result (carry-induced destruction of G-blocks) are inseparably coupled within the same algebraic identity; no configuration can maintain G-dominance indefinitely, rendering divergence of \(3n+1\) trajectories structurally impossible (Proposition 5.4). In contrast, for \(x \geq 5\), where this closure fails, non-trivial cycles are known to exist.
</p>
</div>

<hr>

<!-- ============ SECTION 1 ============ -->
<h1>1. Introduction</h1>

<h2>1.1 Background</h2>

<p>The Collatz conjecture asserts that for any positive integer \(n\), repeated application of the map</p>

$$
n \mapsto \begin{cases} n/2 & \text{if } n \text{ is even} \\ 3n+1 & \text{if } n \text{ is odd} \end{cases}
$$

<p>eventually reaches 1 in finitely many steps. Since its formulation in 1937, it has resisted resolution, famously prompting Erd&#337;s to remark that "mathematics is not yet ready for such problems" [1].</p>

<p>The focus of this paper is not the resolution of the Collatz conjecture itself, but a more fundamental question: <b>What is the internal structure of the map \(T(n) = (xn+1)/2^d\)</b>, and <b>what is special about the parameter \(x=3\)</b>?</p>

<p>The variant \(5n+1\) is a well-studied counterpart. Unlike \(3n+1\), it does not exhibit convergence to 1 and possesses multiple non-trivial cycles, such as \(13 \to 33 \to 83 \to 13\) and \(27 \to 17 \to 43 \to 27\) [2]. Why the dynamical behavior differs so sharply as a function of \(x\) is not well understood.</p>

<h2>1.2 Prior Work</h2>

<p>The analysis of Collatz-type maps has a long history. Lagarias [1] provides a comprehensive survey of the problem's breadth and difficulty. Wirsching [3] developed binary-representation-based analysis and studied the statistical properties of the Collatz map.</p>

<p>In practice, the odd-to-odd transition is captured by the Syracuse function</p>

$$
T(n) = \frac{3n+1}{2^{v_2(3n+1)}}
$$

<p>where \(v_2(m)\) denotes the 2-adic valuation (number of trailing zeros) of \(m\). The Syracuse function streamlines trajectory tracking by eliding even steps, but it does not penetrate the internal structure of the map. The arithmetic operation \(3n+1\) remains a black box, and the trailing-zero count can only be determined after computation.</p>

<p>Binary-based approaches include Terras's stopping time analysis [4] and Everett's binary-operation description [5], but both presuppose the arithmetic execution of \(3 \times n\).</p>

<h2>1.3 Our Approach</h2>

<p>This paper treats natural numbers not as arithmetic objects but as <b>information structures</b>.</p>

<p>Specifically, we decompose the binary representation of \(n\) into a sequence of 2-bit pairs and introduce a system of 16 Boolean predicates defined on each pair \((a_i, b_i)\). Of these 16 predicates, m4 (the left-bit projection of each pair) and m6 (the right-bit projection) form a basis; the remaining 14 are derived from m4 and m6 by bitwise Boolean operations.</p>

<p>Under this basis decomposition, the operation \(xn+1\) is described as follows. Decomposing \(xn+1 = (x-1)n + n + 1\), the term \((x-1)n\) corresponds to a left shift of the bit string of \(n\). The shift amount \(s = \log_2(x-1)\) determines which bit positions of m4/m6 are referenced. Based on this reference pattern, the addition at each pair position is decomposed into bit-level Boolean operations (AND, XOR, and carry propagation).</p>

<p>The core discovery is that when \(x=3\), the shift amount is 1 bit, and the inputs to one of the two addition stages (the m4-stage) coincide with the pair \((a_i, b_i)\) of \(n\) itself. Consequently, the positions of carry Generation and Propagation can be read directly as the intra-pair predicates \(\text{m2} = \text{AND}(a_i, b_i)\) and \(\text{m7} = \text{XOR}(a_i, b_i)\).</p>

<p>For \(x \geq 5\), this degeneracy does not occur, and references to adjacent pairs become necessary. This difference arises from an essential property of the 16 predicates&mdash;per-pair independence&mdash;and is confirmed by exhaustive verification over all 784 predicate combinations.</p>

<h2>1.4 Main Results</h2>

<p>The main results of this paper are summarized as follows.</p>

<div class="theorem">
<span class="theorem-title">Theorem A (Unified Algorithm).</span> For any odd number \(n\) and parameter \(x\) of the \(xn+1\) type, the next odd number \(n' = T(n)\) is computable by an \(O(k)\) bit-scan of m4/m6, where \(k = \lceil \log_2(n) \rceil / 2\) is the number of pairs. The multiplication \(xn\) is decomposed into index shifts of the reference pattern and intra-pair 1-bit additions.
</div>

<div class="theorem">
<span class="theorem-title">Theorem B (Structural Privilege of \(3n+1\)).</span> In the m4-stage carry structure of \(3n+1\), the Generate positions coincide with m2(AND) and the Propagate positions coincide with m7(XOR), at every pair position.
</div>

<div class="theorem">
<span class="theorem-title">Theorem C (Limitation of the 16 Predicates).</span> For \(x \geq 5\), the overall carry structure \((G, P)\) of \(xn+1\) cannot be expressed as any combination of AND, OR, XOR of any two of the 16 predicates m1&ndash;m16 of \(n\).
</div>

<p>Combining Theorems B and C, \(x = 3\) is the <b>unique</b> parameter for which the m4-stage carry structure of the map closes within the complete space of 16 predicates. This m4-stage closure serves as the foundation: the four pair types (G, P, P, K) determined by m2/m7/m9 become the input alphabet of a deterministic finite-state transducer that captures the complete scan dynamics (&sect;5.7).</p>

<div class="theorem">
<span class="theorem-title">Proposition 5.4 (Self-annihilation of G-dominance).</span> In the closed GPK system of \(3n+1\), the activation condition for carry generation (G-dominance) and the activation result (carry-induced destruction of G-blocks) are inseparably coupled within the same algebraic identity \(3n+1 = 2n + n + 1\). No configuration can maintain G-dominance indefinitely. Exhaustive finite case analysis of scan transitions (Table 5.1, 16 patterns) and re-pairing transitions (Table 5.2, 16 patterns) yields Lemmas 5.1&ndash;5.8, which collectively establish that divergence of \(3n+1\) trajectories is structurally impossible (Remark 5.5).
</div>

<h2>1.5 Organization</h2>

<p>Section 2 defines the pair predicate system and establishes basis properties. Section 3 derives the decomposition of \(xn+1\) into pair-wise addition and exhibits the \(x\)-dependence of reference patterns. Section 4 formulates the carry problem and its resolution by scanning. Section 5 establishes the structural privilege of \(3n+1\) and the limitation theorem for the 16 predicates; &sect;5.7 presents the complete finite case analysis (&sect;5.7.1&ndash;5.7.6), including the DFST permutation property, the four-phase closure of the one-step map, and the structural impossibility of divergence via exhaustive scan and re-pairing transition tables. Section 6 discusses the m4&harr;m6 exchange principle under division by 2. Section 7 provides a methodological note. Section 8 applies the framework to cycle analysis. Section 9 presents discussion and open problems. Section 10 states the conclusion.</p>

<!-- ============ SECTION 2 ============ -->
<div class="page-break"></div>
<h1>2. Pair Predicate System</h1>

<p>This section rigorously defines the 2-bit pair decomposition of natural numbers and the system of 16 Boolean predicates defined thereon. We show that m4 and m6 form a basis, and confirm the completeness and per-pair independence of the system.</p>

<h2>2.1 Two-Bit Pair Decomposition</h2>

<div class="theorem">
<span class="theorem-title">Definition 2.1 (Even-digit padding).</span> For a positive integer \(n\), write its binary representation as \(\beta(n) = d_{L-1} d_{L-2} \cdots d_1 d_0\), where \(d_{L-1} = 1\) (most significant bit) and \(L = \lfloor \log_2 n \rfloor + 1\). When \(L\) is odd, prepend a single zero to make the digit count even:

$$
\hat{\beta}(n) = \begin{cases} \beta(n) & \text{if } L \text{ is even} \\ 0\beta(n) & \text{if } L \text{ is odd} \end{cases}
$$

Denote the padded digit count by \(2k\). Then \(k = \lceil L/2 \rceil\) is the <i>pair count</i>.
</div>

<div class="theorem">
<span class="theorem-title">Definition 2.2 (Pair sequence).</span> Group the padded binary representation \(\hat{\beta}(n) = s_1 s_2 \cdots s_{2k}\) into consecutive 2-bit pairs from the left:

$$
P(n) = \bigl((a_0, b_0),\, (a_1, b_1),\, \ldots,\, (a_{k-1}, b_{k-1})\bigr)
$$

where \(a_i = s_{2i+1}\) and \(b_i = s_{2i+2}\) (1-indexed). That is, \(a_i\) is the left bit and \(b_i\) is the right bit of each pair.
</div>

<p><b>Example 2.1.</b> \(n = 27 = 11011_2\) &rarr; padding: \(011011\) &rarr; pairs: \(((0,1),(1,0),(1,1))\). Pair count \(k=3\).</p>

<p><b>Example 2.2.</b> \(n = 17 = 10001_2\) &rarr; padding: \(010001\) &rarr; pairs: \(((0,1),(0,0),(0,1))\). Pair count \(k=3\).</p>

<div class="theorem">
<span class="theorem-title">Definition 2.3 (Zipper structure and reconstruction).</span> To reconstruct the original binary representation from the pair sequence \(P(n)\), interleave the left and right bits:

$$
\hat{\beta}(n) = a_0\, b_0\, a_1\, b_1\, \cdots\, a_{k-1}\, b_{k-1}
$$

We call this interleaving the <i>zipper structure</i>. Reconstruction is unique: removing the leading-zero padding recovers \(n\) uniquely.
</div>

<h2>2.2 Definition of m4 and m6</h2>

<div class="theorem">
<span class="theorem-title">Definition 2.4 (Projections m4, m6).</span> For the pair sequence \(P(n) = ((a_0, b_0), \ldots, (a_{k-1}, b_{k-1}))\), define two bit strings:

$$
\text{m4}(n) = (a_0, a_1, \ldots, a_{k-1})
$$
$$
\text{m6}(n) = (b_0, b_1, \ldots, b_{k-1})
$$

m4 is the left-bit projection (LEFT) and m6 is the right-bit projection (RIGHT) of each pair.
</div>

<div class="theorem">
<span class="theorem-title">Proposition 2.1 (Reconstruction).</span> The number \(n\) is uniquely reconstructed from the pair \((\text{m4}(n), \text{m6}(n))\).
<div class="derivation"><i>Derivation.</i> The zipper structure recovers \(\hat{\beta}(n)\), and removal of the leading zero uniquely determines \(n\).</div>
</div>

<p><b>Example 2.3.</b> \(n=27\): m4 \(= (0,1,1)\), m6 \(= (1,0,1)\). Zipper: \(0\,1\,1\,0\,1\,1 = 011011_2 = 27\). &#10003;</p>

<h2>2.3 The 16 Predicates</h2>

<p>There are \(2^{2^2} = 16\) Boolean functions of two inputs, forming a complete system. For each pair \((a_i, b_i)\), we define the 16 predicates m1&ndash;m16 as follows.</p>

<div class="theorem">
<span class="theorem-title">Definition 2.5 (The 16 predicates).</span>

<table>
<tr><th>Pred.</th><th>Name</th><th>Definition \(f(a,b)\)</th><th>Truth values (0,0)(0,1)(1,0)(1,1)</th></tr>
<tr><td>m1</td><td>FALSE</td><td>0</td><td>0 0 0 0</td></tr>
<tr><td>m2</td><td>AND</td><td>\(a \wedge b\)</td><td>0 0 0 1</td></tr>
<tr><td>m3</td><td>L&gt;R</td><td>\(a \wedge \neg b\)</td><td>0 0 1 0</td></tr>
<tr><td>m4</td><td>LEFT</td><td>\(a\)</td><td>0 0 1 1</td></tr>
<tr><td>m5</td><td>R&gt;L</td><td>\(\neg a \wedge b\)</td><td>0 1 0 0</td></tr>
<tr><td>m6</td><td>RIGHT</td><td>\(b\)</td><td>0 1 0 1</td></tr>
<tr><td>m7</td><td>XOR</td><td>\(a \oplus b\)</td><td>0 1 1 0</td></tr>
<tr><td>m8</td><td>OR</td><td>\(a \vee b\)</td><td>0 1 1 1</td></tr>
<tr><td>m9</td><td>NOR</td><td>\(\neg a \wedge \neg b\)</td><td>1 0 0 0</td></tr>
<tr><td>m10</td><td>XNOR</td><td>\(\neg(a \oplus b)\)</td><td>1 0 0 1</td></tr>
<tr><td>m11</td><td>NOT_R</td><td>\(\neg b\)</td><td>1 0 1 0</td></tr>
<tr><td>m12</td><td>R&rarr;L</td><td>\(a \vee \neg b\)</td><td>1 0 1 1</td></tr>
<tr><td>m13</td><td>NOT_L</td><td>\(\neg a\)</td><td>1 1 0 0</td></tr>
<tr><td>m14</td><td>L&rarr;R</td><td>\(\neg a \vee b\)</td><td>1 1 0 1</td></tr>
<tr><td>m15</td><td>NAND</td><td>\(\neg(a \wedge b)\)</td><td>1 1 1 0</td></tr>
<tr><td>m16</td><td>TRUE</td><td>1</td><td>1 1 1 1</td></tr>
</table>
</div>

<p>Each predicate is applied bitwise to the pair sequence of \(n\):</p>

$$
\text{m}_j(n) = \bigl(f_j(a_0, b_0),\, f_j(a_1, b_1),\, \ldots,\, f_j(a_{k-1}, b_{k-1})\bigr)
$$

<p><b>Remark (on the role of the complete system).</b> In the subsequent analysis, only a handful of these 16 predicates&mdash;most notably m2 (AND), m7 (XOR), m4 (LEFT), m6 (RIGHT), and m9 (NOR)&mdash;appear explicitly in the main results. The reader may therefore wonder why all 16 are catalogued here. The reason is that the completeness of the system is indispensable for the <i>exhaustive verification</i> carried out in Section 5. To establish Theorem C, we must show that <i>no</i> pair of predicates from the full 16-predicate space can express the carry structure of \(xn+1\) for \(x \geq 5\). This impossibility claim requires testing all \(\binom{16}{2} \times \{\text{AND}, \text{OR}, \text{XOR}\} = 360\) candidate combinations (and indeed the full 784-combination search described in &sect;5.5), which is only meaningful when the predicate space is verifiably complete. Without defining the entire system, one could not rule out the possibility that some overlooked predicate might succeed where the obvious ones fail. In a sense, the predicates that go unused in our theorems earn their place by <i>failing</i> the exhaustive search&mdash;their collective failure is precisely what certifies that the structural closure of \(3n+1\) (Theorem B) is unique. We ask the reader's indulgence for this apparent redundancy; it is, in fact, the backbone of the impossibility argument.</p>

<h2>2.4 Basis Theorem</h2>

<div class="theorem">
<span class="theorem-title">Theorem 2.1 (m4/m6 basis).</span> All 16 predicates m1&ndash;m16 can be expressed by bitwise Boolean operations on m4 and m6.

<p><i>Derivation.</i> We give the expression for each predicate directly:</p>

<table>
<tr><th>Predicate</th><th>Expression in m4/m6</th></tr>
<tr><td>m1</td><td>\(\mathbf{0}\) (constant zero)</td></tr>
<tr><td>m2</td><td>m4 AND m6</td></tr>
<tr><td>m3</td><td>m4 AND (NOT m6)</td></tr>
<tr><td>m4</td><td>m4 (basis)</td></tr>
<tr><td>m5</td><td>(NOT m4) AND m6</td></tr>
<tr><td>m6</td><td>m6 (basis)</td></tr>
<tr><td>m7</td><td>m4 XOR m6</td></tr>
<tr><td>m8</td><td>m4 OR m6</td></tr>
<tr><td>m9</td><td>(NOT m4) AND (NOT m6)</td></tr>
<tr><td>m10</td><td>NOT (m4 XOR m6)</td></tr>
<tr><td>m11</td><td>NOT m6</td></tr>
<tr><td>m12</td><td>m4 OR (NOT m6)</td></tr>
<tr><td>m13</td><td>NOT m4</td></tr>
<tr><td>m14</td><td>(NOT m4) OR m6</td></tr>
<tr><td>m15</td><td>NOT (m4 AND m6)</td></tr>
<tr><td>m16</td><td>\(\mathbf{1}\) (constant one)</td></tr>
</table>

<p>All operations are applied bitwise. &#9633;</p>
</div>

<p><b>Remark 2.1.</b> The choice of basis is not unique. For instance, \(\{\text{m3}(a \wedge \neg b),\; \text{m6}(b)\}\) or \(\{\text{m4}(a),\; \text{m8}(a \vee b)\}\) also generate all 16 predicates. However, m4/m6 is the unique basis pair that directly preserves the numerical information of \(n\), requiring only the zipper structure to reconstruct \(n\) with no additional operations (direct reconstructibility). Other basis pairs can also reconstruct \(n\)&mdash;for example, the complement pair \((\text{m13}, \text{m11}) = (\neg a, \neg b)\) recovers \(n\) via bitwise negation, and \((\text{m13}, \text{m6}) = (\neg a, b)\) via negation of the left bits alone&mdash;but all such pairs require additional logical operations.</p>

<p>Note that not every pair of predicates forms a basis. For example, \(\{\text{m2}(\text{AND}),\; \text{m7}(\text{XOR})\}\) are both symmetric in \((a,b)\), meaning \(f(a,b) = f(b,a)\). Since any Boolean composition of symmetric functions remains symmetric, this pair can only generate the 8 symmetric predicates (m1, m2, m7, m8, m9, m10, m15, m16) and cannot produce asymmetric predicates such as \(\text{m4}(a,b) = a\).</p>

<h2>2.5 Per-Pair Independence</h2>

<div class="theorem">
<span class="theorem-title">Definition 2.6 (Per-pair independence).</span> A function \(g: \{0,1\}^{2k} \to \{0,1\}^k\) is <i>per-pair independent</i> if the \(i\)-th component of the output depends only on the \(i\)-th pair \((a_i, b_i)\) of the input:

$$
g(n)_i = h(a_i, b_i) \quad \text{for some } h: \{0,1\}^2 \to \{0,1\}
$$
</div>

<div class="theorem">
<span class="theorem-title">Proposition 2.2.</span> All 16 predicates m1&ndash;m16 are per-pair independent.
<div class="derivation"><i>Derivation.</i> By Definition 2.5, each \(f_j(a_i, b_i)\) is a function of \((a_i, b_i)\) alone.</div>
</div>

<div class="theorem">
<span class="theorem-title">Proposition 2.3 (Closure).</span> The bitwise AND, OR, XOR, and NOT of per-pair independent functions are again per-pair independent.
<div class="derivation"><i>Derivation.</i> If \(g_1(n)_i = h_1(a_i, b_i)\) and \(g_2(n)_i = h_2(a_i, b_i)\), then \((g_1 \text{ AND } g_2)(n)_i = h_1(a_i, b_i) \wedge h_2(a_i, b_i)\) depends only on \((a_i, b_i)\). The other operations are analogous.</div>
</div>

<div class="theorem">
<span class="theorem-title">Corollary 2.1.</span> Any Boolean composition of m1&ndash;m16 is per-pair independent and cannot express correlations between positions \(i\) and \(j\) (\(i \neq j\)).
</div>

<p>This property is used essentially in Section 5 to establish that the carry structure of \(5n+1\) cannot be described by the 16 predicates.</p>

<h2>2.6 Complement Pairs</h2>

<p>The 16 predicates possess a natural symmetry.</p>

<div class="theorem">
<span class="theorem-title">Definition 2.7 (Complement pair).</span> Predicates \(\text{m}_j\) and \(\text{m}_{17-j}\) are called a complement pair. They satisfy \(\text{m}_j(a,b) + \text{m}_{17-j}(a,b) = 1\).
</div>

<table>
<tr><th>Pair</th><th>Predicate</th><th>Complement</th><th>Type</th></tr>
<tr><td>1</td><td>m1 (FALSE)</td><td>m16 (TRUE)</td><td>Constant</td></tr>
<tr><td>2</td><td>m2 (AND)</td><td>m15 (NAND)</td><td>Logical</td></tr>
<tr><td>3</td><td>m3 (L&gt;R)</td><td>m14 (L&rarr;R)</td><td>Implication</td></tr>
<tr><td>4</td><td>m4 (LEFT)</td><td>m13 (NOT_L)</td><td>Projection</td></tr>
<tr><td>5</td><td>m5 (R&gt;L)</td><td>m12 (R&rarr;L)</td><td>Implication</td></tr>
<tr><td>6</td><td>m6 (RIGHT)</td><td>m11 (NOT_R)</td><td>Projection</td></tr>
<tr><td>7</td><td>m7 (XOR)</td><td>m10 (XNOR)</td><td>Exclusive</td></tr>
<tr><td>8</td><td>m8 (OR)</td><td>m9 (NOR)</td><td>Logical</td></tr>
</table>

<div class="theorem">
<span class="theorem-title">Proposition 2.4.</span> \(\text{m}_j(n) = \neg\, \text{m}_{17-j}(n)\) holds for all \(n\).
<div class="derivation"><i>Derivation.</i> Verify \(f_j(a,b) + f_{17-j}(a,b) = 1\) for each row of the truth table.</div>
</div>

<h2>2.7 Summary of This Section</h2>

<p>Established results:</p>

<p>1. A natural number \(n\) is uniquely decomposed into a 2-bit pair sequence \(P(n)\), and is completely reconstructed from m4 (left-bit string) and m6 (right-bit string).</p>

<p>2. The 16 two-input Boolean functions on pairs \((a_i, b_i)\) form a complete system, all expressible as bitwise operations on m4 and m6.</p>

<p>3. All 16 predicates are per-pair independent, and this property is preserved under Boolean composition. Consequently, correlations between distinct pair positions cannot be described within the 16-predicate framework.</p>

<p>4. The 16 predicates form 8 complement pairs, with predicate numbers \(j\) and \(17-j\) paired.</p>

<p>Section 3 derives how \(xn+1\)-type maps are described on this predicate system.</p>

<!-- ============ SECTION 3 ============ -->
<div class="page-break"></div>
<h1>3. Decomposition of \(xn+1\)</h1>

<p>This section decomposes the Collatz-type map \(xn+1\) into pair-wise addition. We show that the shift amount \(s = \log_2(x-1)\) determines the reference pattern on the pair structure, and derive the cases \(x=3\) and \(x=5\) in detail.</p>

<h2>3.1 Decomposition Principle</h2>

<div class="theorem">
<span class="theorem-title">Proposition 3.1 (Additive decomposition).</span> For a positive odd number \(n\) and parameter \(x\):

$$
xn + 1 = (x-1)n + n + 1
$$

The term \((x-1)n\) corresponds to a left shift of the binary representation of \(n\).

<div class="derivation"><i>Derivation.</i> When \(x-1\) is a power of 2, \((x-1)n = 2^s n\) is exactly an \(s\)-bit left shift of \(n\). This paper treats the case \(x \in \{3, 5, 9, 17, \ldots\}\) where \(x-1\) is a power of 2.</div>
</div>

<p><b>Remark 3.1.</b> When \(x-1\) is not a power of 2 (e.g., \(x=7\), \(x-1=6=2 \cdot 3\)), additional additions beyond a simple shift arise. The framework is in principle extensible, but for clarity we focus on \(x-1 = 2^s\). The primary objects of study are \(x=3\) (\(s=1\)) and \(x=5\) (\(s=2\)).</p>

<h2>3.2 Shift and Pair Structure</h2>

<p>Let \(P(n) = ((a_0, b_0), \ldots, (a_{k-1}, b_{k-1}))\) be the pair sequence of \(n\), with corresponding binary representation \(\hat{\beta}(n) = a_0\, b_0\, a_1\, b_1\, \cdots\, a_{k-1}\, b_{k-1}\). The binary representation of \(2^s n\) appends \(s\) zeros at the end.</p>

<p><b>Case \(s=2\) (\(x=5\), \(4n\)):</b></p>

$$
P(4n) = ((a_0, b_0),\, (a_1, b_1),\, \ldots,\, (a_{k-1}, b_{k-1}),\, (0, 0))
$$

<p>A zero pair \((0,0)\) is appended. <b>Pair boundaries are preserved.</b></p>

$$
\text{m4}(4n) = (a_0, a_1, \ldots, a_{k-1}, 0) = \text{m4}(n) \| 0
$$
$$
\text{m6}(4n) = (b_0, b_1, \ldots, b_{k-1}, 0) = \text{m6}(n) \| 0
$$

<p>where \(\|\) denotes bit-string concatenation.</p>

<p><b>Case \(s=1\) (\(x=3\), \(2n\)):</b></p>

$$
\hat{\beta}(2n) = a_0\, b_0\, a_1\, b_1\, \cdots\, a_{k-1}\, b_{k-1}\, 0
$$

<p>The digit count becomes odd, so a leading zero is prepended:</p>

$$
\hat{\beta}(2n)_{\text{padded}} = 0\, a_0\, b_0\, a_1\, b_1\, \cdots\, a_{k-1}\, b_{k-1}\, 0
$$

<p>Grouping into pairs:</p>

$$
P(2n) = ((0, a_0),\, (b_0, a_1),\, (b_1, a_2),\, \ldots,\, (b_{k-1}, 0))
$$

<p><b>Pair boundaries shift by 1 bit.</b> As a result:</p>

$$
\text{m4}(2n) = (0, b_0, b_1, \ldots, b_{k-1}) = 0 \| \text{m6}(n)
$$
$$
\text{m6}(2n) = (a_0, a_1, \ldots, a_{k-1}, 0) = \text{m4}(n) \| 0
$$

<div class="theorem">
<span class="theorem-title">Proposition 3.2 (m4/m6 crossover under \(2n\)).</span> \(\text{m4}(2n)\) equals \(\text{m6}(n)\) with a leading zero prepended, and \(\text{m6}(2n)\) equals \(\text{m4}(n)\) with a trailing zero appended. That is, the \(2n\) operation swaps the roles of m4 and m6.
</div>

<h2>3.3 Pair Addition Formulation</h2>

<p>We describe \(xn + 1 = 2^s n + n + 1\) as addition over pair sequences. Below we use LSB (least significant pair) ordering. Let the pair sequence of \(n\) in LSB order be \((a_0, b_0), (a_1, b_1), \ldots\)</p>

<p>At pair position \(i\), the contribution from \(n\) is \((a_i, b_i)\), and the contribution from \(2^s n\) is determined by the shift amount. Addition at each pair position proceeds in two stages: right bit (m6) then left bit (m4).</p>

<div class="theorem">
<span class="theorem-title">Definition 3.1 (Two-stage pair addition).</span> At pair position \(i\):

<p><b>m6-stage (right bit):</b></p>
$$
\text{sum}_{R,i} = r_i^{(6)} + b_i + c_{\text{in},i}
$$

<p>where \(r_i^{(6)}\) is the right bit of \(2^s n\) at pair position \(i\), and \(c_{\text{in},i}\) is the input carry to pair \(i\).</p>

$$
\text{new\_m6}_i = \text{sum}_{R,i} \bmod 2, \quad c_{\text{mid},i} = \lfloor \text{sum}_{R,i} / 2 \rfloor
$$

<p><b>m4-stage (left bit):</b></p>
$$
\text{sum}_{L,i} = r_i^{(4)} + a_i + c_{\text{mid},i}
$$

<p>where \(r_i^{(4)}\) is the left bit of \(2^s n\) at pair position \(i\).</p>

$$
\text{new\_m4}_i = \text{sum}_{L,i} \bmod 2, \quad c_{\text{out},i} = \lfloor \text{sum}_{L,i} / 2 \rfloor
$$

<p><b>Carry propagation:</b> \(c_{\text{in},0} = 1\) (effect of +1), \(c_{\text{in},i+1} = c_{\text{out},i}\).</p>
</div>

<h2>3.4 Reference Pattern for \(x=5\)</h2>

<p>In \(5n+1 = 4n + n + 1\), the term \(4n\) is a 1-pair shift (&sect;3.2), so at pair position \(i\):</p>

$$
r_i^{(4)} = a_{i-1}, \quad r_i^{(6)} = b_{i-1} \quad (a_{-1} = b_{-1} = 0)
$$

<div class="theorem">
<span class="theorem-title">Proposition 3.3 (Reference pattern for \(5n+1\)).</span> In the pair addition for \(5n+1\):

$$
\text{m6-stage inputs}: (b_{i-1},\, b_i) \quad \text{&mdash; adjacent m6 bits}
$$
$$
\text{m4-stage inputs}: (a_{i-1},\, a_i) \quad \text{&mdash; adjacent m4 bits}
$$

<div class="derivation"><i>Derivation.</i> Substitute \(r_i^{(6)} = b_{i-1}\) into the m6-stage: \(\text{sum}_{R,i} = b_{i-1} + b_i + c_{\text{in},i}\). Substitute \(r_i^{(4)} = a_{i-1}\) into the m4-stage: \(\text{sum}_{L,i} = a_{i-1} + a_i + c_{\text{mid},i}\).</div>
</div>

<p><b>Remark 3.2.</b> For \(5n+1\), both the m6-stage and the m4-stage have isomorphic reference patterns (adjacent same-type reference). This is because \(s=2\) is even (&sect;3.6 generalizes).</p>

<h2>3.5 Reference Pattern for \(x=3\)</h2>

<p>In \(3n+1 = 2n + n + 1\), the term \(2n\) is a 1-bit shift. By &sect;3.2, and tracking the pair boundary shift precisely in LSB order:</p>

$$
r_i^{(6)} = a_{i-1} \quad (a_{-1} = 0), \qquad r_i^{(4)} = b_i
$$

<div class="theorem">
<span class="theorem-title">Proposition 3.4 (Reference pattern for \(3n+1\)).</span> In the pair addition for \(3n+1\):

$$
\text{m6-stage inputs}: (a_{i-1},\, b_i) \quad \text{&mdash; cross-reference between m4 of the previous pair and m6 of the current pair}
$$
$$
\text{m4-stage inputs}: (b_i,\, a_i) = (a_i,\, b_i) \quad \text{&mdash; within the current pair (order is immaterial by commutativity)}
$$

<div class="derivation"><i>Derivation.</i> Substitute \(r_i^{(6)} = a_{i-1}\) into the m6-stage: \(\text{sum}_{R,i} = a_{i-1} + b_i + c_{\text{in},i}\). Substitute \(r_i^{(4)} = b_i\) into the m4-stage: \(\text{sum}_{L,i} = b_i + a_i + c_{\text{mid},i} = a_i + b_i + c_{\text{mid},i}\).</div>
</div>

<p><b>Key observation.</b> The m4-stage inputs \((a_i, b_i)\) are precisely pair \(i\) of \(n\) itself. This coincidence is the foundation of Theorem B in Section 5.</p>

<h2>3.6 General Reference Patterns</h2>

<p>The parity of the shift amount \(s\) qualitatively determines the reference pattern structure.</p>

<div class="theorem">
<span class="theorem-title">Proposition 3.5 (Classification of reference patterns).</span> For \(x - 1 = 2^s\):

<p><b>When \(s\) is even (\(s = 2t\)):</b> The shift corresponds to \(t\) full pairs. Pair boundaries are preserved.</p>

$$
r_i^{(4)} = a_{i-t}, \quad r_i^{(6)} = b_{i-t}
$$

<p>The m6-stage references m6 bits and the m4-stage references m4 bits (<b>isomorphic reference</b>).</p>

<p><b>When \(s\) is odd (\(s = 2t+1\)):</b> The shift is \(t\) pairs plus 1 bit, and pair boundaries shift by 1 bit.</p>

$$
r_i^{(4)} = b_{i-t-1}, \quad r_i^{(6)} = a_{i-t}
$$

<p>The m6-stage references m4-derived bits and the m4-stage references m6-derived bits (<b>cross-reference</b>).</p>
</div>

<p><b>Table 3.1: Principal reference patterns.</b></p>

<table>
<tr><th>\(x\)</th><th>\(s\)</th><th>Pair shift</th><th>Boundary</th><th>m6-stage input</th><th>m4-stage input</th><th>Type</th></tr>
<tr><td>3</td><td>1</td><td>0+1bit</td><td>shifted</td><td>\((a_{i-1}, b_i)\)</td><td>\((a_i, b_i)\)</td><td>cross + intra-pair</td></tr>
<tr><td>5</td><td>2</td><td>1 pair</td><td>preserved</td><td>\((b_{i-1}, b_i)\)</td><td>\((a_{i-1}, a_i)\)</td><td>isomorphic adjacent</td></tr>
<tr><td>9</td><td>3</td><td>1+1bit</td><td>shifted</td><td>\((a_{i-2}, b_i)\)</td><td>\((a_i, b_{i-1})\)</td><td>cross + distant</td></tr>
<tr><td>17</td><td>4</td><td>2 pairs</td><td>preserved</td><td>\((b_{i-2}, b_i)\)</td><td>\((a_{i-2}, a_i)\)</td><td>isomorphic distant</td></tr>
</table>

<h2>3.7 Worked Example: \(n=27\) under \(5n+1\)</h2>

<p>\(n=27\): m4 \(= (0,1,1)\), m6 \(= (1,0,1)\). LSB order: \(a = (1,1,0)\), \(b = (1,0,1)\).</p>

<p><b>Pair 0 (LSB, \(i=0\)):</b></p>
$$
\text{m6-stage}: b_{-1} + b_0 + c_{\text{in}} = 0 + 1 + 1 = 2 \;\Rightarrow\; \text{new\_m6}_0 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4-stage}: a_{-1} + a_0 + c_{\text{mid}} = 0 + 1 + 1 = 2 \;\Rightarrow\; \text{new\_m4}_0 = 0,\; c_{\text{out}} = 1
$$

<p><b>Pair 1 (\(i=1\)):</b></p>
$$
\text{m6-stage}: b_0 + b_1 + 1 = 1 + 0 + 1 = 2 \;\Rightarrow\; \text{new\_m6}_1 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4-stage}: a_0 + a_1 + 1 = 1 + 1 + 1 = 3 \;\Rightarrow\; \text{new\_m4}_1 = 1,\; c_{\text{out}} = 1
$$

<p><b>Pair 2 (\(i=2\)):</b></p>
$$
\text{m6-stage}: b_1 + b_2 + 1 = 0 + 1 + 1 = 2 \;\Rightarrow\; \text{new\_m6}_2 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4-stage}: a_1 + a_2 + 1 = 1 + 0 + 1 = 2 \;\Rightarrow\; \text{new\_m4}_2 = 0,\; c_{\text{out}} = 1
$$

<p><b>Overflow pair (\(i=3\)):</b></p>
$$
\text{m6-stage}: b_2 + 0 + 1 = 1 + 0 + 1 = 2 \;\Rightarrow\; \text{new\_m6}_3 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4-stage}: a_2 + 0 + 1 = 0 + 0 + 1 = 1 \;\Rightarrow\; \text{new\_m4}_3 = 1,\; c_{\text{out}} = 0
$$

<p>Result (LSB order): \(((0,0),(1,0),(0,0),(1,0))\) &rarr; MSB order: \(((1,0),(0,0),(1,0),(0,0))\)</p>

$$
5 \times 27 + 1 = 136 = 10001000_2 \quad \checkmark
$$

<h2>3.8 Worked Example: \(n=27\) under \(3n+1\)</h2>

<p>Same \(n=27\): LSB order: \(a = (1,1,0)\), \(b = (1,0,1)\).</p>

<p><b>Pair 0 (\(i=0\)):</b></p>
$$
\text{m6-stage}: a_{-1} + b_0 + c_{\text{in}} = 0 + 1 + 1 = 2 \;\Rightarrow\; \text{new\_m6}_0 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4-stage}: a_0 + b_0 + c_{\text{mid}} = 1 + 1 + 1 = 3 \;\Rightarrow\; \text{new\_m4}_0 = 1,\; c_{\text{out}} = 1
$$

<p><b>Pair 1 (\(i=1\)):</b></p>
$$
\text{m6-stage}: a_0 + b_1 + 1 = 1 + 0 + 1 = 2 \;\Rightarrow\; \text{new\_m6}_1 = 0,\; c_{\text{mid}} = 1
$$
$$
\text{m4-stage}: a_1 + b_1 + 1 = 1 + 0 + 1 = 2 \;\Rightarrow\; \text{new\_m4}_1 = 0,\; c_{\text{out}} = 1
$$

<p><b>Pair 2 (\(i=2\)):</b></p>
$$
\text{m6-stage}: a_1 + b_2 + 1 = 1 + 1 + 1 = 3 \;\Rightarrow\; \text{new\_m6}_2 = 1,\; c_{\text{mid}} = 1
$$
$$
\text{m4-stage}: a_2 + b_2 + 1 = 0 + 1 + 1 = 2 \;\Rightarrow\; \text{new\_m4}_2 = 0,\; c_{\text{out}} = 1
$$

<p><b>Overflow pair (\(i=3\)):</b></p>
$$
\text{m6-stage}: a_2 + 0 + 1 = 0 + 0 + 1 = 1 \;\Rightarrow\; \text{new\_m6}_3 = 1,\; c_{\text{mid}} = 0
$$
$$
\text{m4-stage}: 0 + 0 + 0 = 0 \;\Rightarrow\; \text{new\_m4}_3 = 0,\; c_{\text{out}} = 0
$$

<p>Result (LSB order): \(((1,0),(0,0),(0,1),(0,1))\) &rarr; MSB order: \(((0,1),(0,1),(0,0),(1,0))\)</p>

$$
3 \times 27 + 1 = 82 = 01010010_2 \quad \checkmark
$$

<h2>3.9 Summary of This Section</h2>

<p>1. Decomposing \(xn+1 = (x-1)n + n + 1\), the term \((x-1)n\) is an \(s = \log_2(x-1)\)-bit left shift, and the parity of \(s\) determines whether pair boundaries are preserved or shifted.</p>

<p>2. Addition at pair position \(i\) has a two-stage structure (m6-stage and m4-stage), with each stage's inputs described as references to m4/m6 bits of \(n\).</p>

<p>3. For \(x=5\) (\(s=2\), even): isomorphic adjacent reference of m6&ndash;m6 and m4&ndash;m4. For \(x=3\) (\(s=1\), odd): cross-reference of m4&rarr;m6 and m6&rarr;m4, with the m4-stage inputs coinciding with the current pair \((a_i, b_i)\) itself.</p>

<p>4. The multiplication \(xn\) is never explicitly performed. The shift of \((x-1)n\) is absorbed into index offsets of the reference pattern, and all operations reduce to bit references and 1-bit additions (with carry propagation).</p>

<!-- ============ SECTION 4 ============ -->
<div class="page-break"></div>
<h1>4. The Carry Problem and Its Resolution</h1>

<p>The previous section derived the two-stage pair addition structure. This section formulates the carry propagation structure, shows that it can be resolved by sequential scanning, and that parallelization is possible.</p>

<h2>4.1 The Problem</h2>

<p>The output of pair position \(i\) depends on the input carry \(c_{\text{in},i}\), which equals the output carry \(c_{\text{out},i-1}\) of pair \(i-1\), which in turn depends on pair \(i-2\), and so on. This chain runs from LSB (pair 0) to MSB:</p>

$$
c_{\text{in},0} = 1 \;\xrightarrow{\text{pair }0}\; c_{\text{out},0} = c_{\text{in},1} \;\xrightarrow{\text{pair }1}\; c_{\text{out},1} = c_{\text{in},2} \;\xrightarrow{\text{pair }2}\; \cdots
$$

<p>Within each pair, two stages of carry exist:</p>

$$
c_{\text{in},i} \;\xrightarrow{\text{m6-stage}}\; c_{\text{mid},i} \;\xrightarrow{\text{m4-stage}}\; c_{\text{out},i}
$$

<p>Therefore, to determine the output bits (new m4\(_i\), new m6\(_i\)) of pair \(i\), in principle all carries from pair 0 through pair \(i-1\) must be settled.</p>

<p><b>Question.</b> Is this sequential dependence essential? Can the carry at each pair be expressed in "closed form" from the m4/m6 bit strings?</p>

<h2>4.2 Local Carry Classification (GPK)</h2>

<p>Despite the sequential carry dependence, the <i>behavior of each pair with respect to carry</i> can be classified independently of the carry value.</p>

<div class="theorem">
<span class="theorem-title">Definition 4.1 (GPK classification).</span> For two bits \(p, q \in \{0,1\}\) and an input carry \(c \in \{0,1\}\), the carry output of the addition \(p + q + c\) is \(\lfloor(p+q+c)/2\rfloor\). We classify:

<ul>
<li><b>Generate (G):</b> \(p + q = 2\) (i.e., \(p = q = 1\)). Carry output is 1 regardless of \(c\).</li>
<li><b>Propagate (P):</b> \(p + q = 1\) (i.e., \(p \neq q\)). Carry output equals \(c\).</li>
<li><b>Kill (K):</b> \(p + q = 0\) (i.e., \(p = q = 0\)). Carry output is 0 regardless of \(c\).</li>
</ul>

<p>In Boolean predicates:</p>
$$G(p,q) = p \wedge q = \text{AND}(p,q)$$
$$P(p,q) = p \oplus q = \text{XOR}(p,q)$$
$$K(p,q) = \neg p \wedge \neg q = \text{NOR}(p,q)$$

<p>\(G, P, K\) are mutually exclusive and exhaustive.</p>
</div>

<p><b>Remark 4.0.</b> The GPK classification is not introduced for the first time in this paper. It is the standard technique for classifying carry behavior at each digit of carry-lookahead adders [6], with over half a century of history. Our contribution is to apply this classification to the pair addition of Collatz-type maps and to show that for \(3n+1\), the GPK coincides with the intra-pair predicates m2/m7/m9 of \(n\).</p>

<h2>4.3 GPK of Each Stage</h2>

<p>Based on the reference patterns of Section 3, we describe the GPK of each stage.</p>

<p><b>m6-stage GPK:</b></p>
$$
G_{\text{mid}}[i] = \text{AND}(r_i^{(6)},\, b_i), \quad P_{\text{mid}}[i] = \text{XOR}(r_i^{(6)},\, b_i)
$$

<p><b>m4-stage GPK:</b></p>
$$
G_{\text{out}}[i] = \text{AND}(r_i^{(4)},\, a_i), \quad P_{\text{out}}[i] = \text{XOR}(r_i^{(4)},\, a_i)
$$

<p><b>For \(x=5\):</b></p>
$$
G_{\text{mid}}[i] = b_{i-1} \wedge b_i, \quad P_{\text{mid}}[i] = b_{i-1} \oplus b_i
$$
$$
G_{\text{out}}[i] = a_{i-1} \wedge a_i, \quad P_{\text{out}}[i] = a_{i-1} \oplus a_i
$$

<p><b>For \(x=3\):</b></p>
$$
G_{\text{mid}}[i] = a_{i-1} \wedge b_i, \quad P_{\text{mid}}[i] = a_{i-1} \oplus b_i
$$
$$
G_{\text{out}}[i] = a_i \wedge b_i, \quad P_{\text{out}}[i] = a_i \oplus b_i
$$

<h2>4.4 Serial Composition of GPK Across Two Stages</h2>

<p>The m6-stage and m4-stage are connected in series (the carry output of the m6-stage becomes the carry input to the m4-stage). Serial composition yields the overall GPK for pair \(i\).</p>

<div class="theorem">
<span class="theorem-title">Proposition 4.1 (Serial composition).</span> When two GPK stages \((G_1, P_1)\) and \((G_2, P_2)\) are connected in series (output of stage 1 feeds stage 2), the overall GPK is:

$$
G_{12} = G_2 \vee (P_2 \wedge G_1), \quad P_{12} = P_2 \wedge P_1
$$

<div class="derivation"><i>Derivation.</i> Case analysis on carry input \(c\). If \(G_2 = 1\): stage 2 generates, output is 1. If \(G_2 = 0, P_2 = 1\): stage 2 passes through stage 1's output, which is 1 if \(G_1 = 1\), \(c\) if \(P_1 = 1\), or 0 if \(K_1 = 1\). If \(K_2 = 1\): output is 0. Overall Generate occurs when \(G_2 \vee (P_2 \wedge G_1)\). Overall Propagate occurs when \(P_2 \wedge P_1\).</div>
</div>

<div class="theorem">
<span class="theorem-title">Definition 4.2 (Pair GPK).</span> The overall GPK for pair position \(i\):

$$
G_i = G_{\text{out}}[i] \vee (P_{\text{out}}[i] \wedge G_{\text{mid}}[i]), \quad P_i = P_{\text{out}}[i] \wedge P_{\text{mid}}[i]
$$
</div>

<h2>4.5 Carry Resolution by Scanning</h2>

<p>Once the local GPK is computed for all pairs, carry determination reduces to a simple scan from the LSB.</p>

<div class="theorem">
<span class="theorem-title">Algorithm 4.1 (Carry scan).</span>
<pre>
Input:  Pair GPK sequence (G_0, P_0), ..., (G_{k-1}, P_{k-1})
        Initial carry c_0 = 1

c &larr; 1
for i = 0 to k-1:
    c_in[i] &larr; c
    c &larr; G_i OR (P_i AND c)
</pre>
</div>

<div class="theorem">
<span class="theorem-title">Proposition 4.2.</span> Algorithm 4.1 determines all pair input carries in \(O(k)\) time.
<div class="derivation"><i>Derivation.</i> The loop runs \(k\) times; each iteration involves constant-time Boolean operations.</div>
</div>

<p><b>Output computation after carry determination:</b></p>

<p>For each pair \(i\), once \(c_{\text{in},i}\) is known:</p>

$$
c_{\text{mid},i} = G_{\text{mid}}[i] \vee (P_{\text{mid}}[i] \wedge c_{\text{in},i})
$$
$$
\text{new\_m6}_i = r_i^{(6)} \oplus b_i \oplus c_{\text{in},i}
$$
$$
\text{new\_m4}_i = r_i^{(4)} \oplus a_i \oplus c_{\text{mid},i}
$$

<p>This is also computed independently per pair in \(O(1)\).</p>

<h2>4.6 Cost of Local GPK Computation</h2>

<p><b>Key observation.</b> Computing local GPK values \(G_{\text{mid}}[i], P_{\text{mid}}[i], G_{\text{out}}[i], P_{\text{out}}[i]\) requires only <b>referencing m4/m6 bits and taking AND/XOR</b>. The reference targets differ by \(x\) (Table 3.1), but the type and count of operations are identical.</p>

<ul>
<li>\(x=3\): References m4 bits at positions \(i\) and \(i-1\), and m4/m6 bits at position \(i\).</li>
<li>\(x=5\): References m4 bits at positions \(i\) and \(i-1\) (m4 with m4), and m6 bits at positions \(i\) and \(i-1\) (m6 with m6).</li>
<li>In all cases, <b>each pair's local GPK is obtained in \(O(1)\) without additional arithmetic</b>.</li>
</ul>

<p>Therefore, computing local GPK for all pairs is \(O(k)\), and the subsequent scan is also \(O(k)\), so complete carry determination is achieved in \(O(k)\) time.</p>

<h2>4.7 Parallelization via GPK Tree</h2>

<p>The scan is \(O(k)\) time but inherently sequential. In parallel computation environments, binary tree composition of GPK values compresses this to \(O(\log k)\) depth.</p>

<div class="theorem">
<span class="theorem-title">Proposition 4.3 (Associativity of GPK composition).</span> GPK composition (the rule of Proposition 4.1) is associative.

<div class="derivation"><i>Derivation.</i> For three stages \(A, B, C\):
$$G_{(AB)C} = G_C \vee (P_C \wedge G_B) \vee (P_C \wedge P_B \wedge G_A)$$
$$G_{A(BC)} = (G_C \vee (P_C \wedge G_B)) \vee ((P_C \wedge P_B) \wedge G_A) = G_C \vee (P_C \wedge G_B) \vee (P_C \wedge P_B \wedge G_A)$$
Both coincide. For \(P\): \(P_{(AB)C} = P_C \wedge P_B \wedge P_A = P_{A(BC)}\).</div>
</div>

<div class="theorem">
<span class="theorem-title">Algorithm 4.2 (GPK tree composition).</span>
<pre>
Input:  Pair GPK sequence (G_0, P_0), ..., (G_{k-1}, P_{k-1})
Output: Prefix GPK: (G_{0..j}, P_{0..j}) for all j

Level 0: Each pair's (G_i, P_i)

Level 1: Compose adjacent pairs
  (G_{01}, P_{01}), (G_{23}, P_{23}), ...

Level 2: Compose further
  (G_{0123}, P_{0123}), ...

... completes in log_2(k) levels
</pre>
</div>

<div class="theorem">
<span class="theorem-title">Proposition 4.4.</span> GPK tree composition completes \(O(k)\) total work in \(O(\log k)\) depth. Each level uses only AND and OR operations.
<div class="derivation"><i>Derivation.</i> At each level \(l\) of the binary tree, \(k/2^l\) compositions are performed, each involving a constant number of AND/OR operations. The total number of levels is \(\lceil \log_2 k \rceil\).</div>
</div>

<p><b>Remark 4.1.</b> The GPK tree is an optimization for parallel computation and is not required for correctness verification. The sequential scan (Algorithm 4.1) determines all carries in \(O(k)\) time.</p>

<h2>4.8 Worked Example: \(n=27\), \(x=5\) Carry Determination</h2>

<p>We revisit the example of &sect;3.7 from the GPK perspective.</p>

<p>\(n=27\), m4 \(= (0,1,1)\), m6 \(= (1,0,1)\). LSB order: \(a = (1,1,0)\), \(b = (1,0,1)\).</p>

<p><b>Local GPK computation:</b></p>

<table>
<tr><th>Pair \(i\)</th><th>\(b_{i-1}\)</th><th>\(b_i\)</th><th>\(G_{\text{mid}}\)</th><th>\(P_{\text{mid}}\)</th><th>\(a_{i-1}\)</th><th>\(a_i\)</th><th>\(G_{\text{out}}\)</th><th>\(P_{\text{out}}\)</th><th>\(G_i\)</th><th>\(P_i\)</th></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>2</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
</table>

<p>GPK sequence (from LSB): <b>P, G, P</b></p>

<p><b>Scan:</b></p>

<table>
<tr><th>Step</th><th>\(c_{\text{in}}\)</th><th>GPK</th><th>\(c_{\text{out}}\)</th><th>Interpretation</th></tr>
<tr><td>\(i=0\)</td><td>1</td><td>P</td><td>1</td><td>Propagates initial carry 1</td></tr>
<tr><td>\(i=1\)</td><td>1</td><td>G</td><td>1</td><td>Self-generates (independent of \(c_{\text{in}}\))</td></tr>
<tr><td>\(i=2\)</td><td>1</td><td>P</td><td>1</td><td>Propagates carry 1</td></tr>
</table>

<p>All pairs have \(c_{\text{in}} = 1\). Consistent with the step-by-step computation of &sect;3.7.</p>

<p><b>Structural interpretation.</b> Since pair 1 is Generate, even if pair 0 had killed the carry, carry would still reach pair 2. GPK describes the "terrain" of carry propagation, and the initial value \(c_0 = 1\) flows over this terrain.</p>

<h2>4.9 Worked Example: \(n=27\), \(x=3\) Carry Determination</h2>

<p>\(n=27\), LSB order: \(a = (1,1,0)\), \(b = (1,0,1)\).</p>

<p><b>Local GPK computation (\(3n+1\) reference pattern):</b></p>

<table>
<tr><th>Pair \(i\)</th><th>\(a_{i-1}\)</th><th>\(b_i\)</th><th>\(G_{\text{mid}}\)</th><th>\(P_{\text{mid}}\)</th><th>\(a_i\)</th><th>\(b_i\)</th><th>\(G_{\text{out}}\)</th><th>\(P_{\text{out}}\)</th><th>\(G_i\)</th><th>\(P_i\)</th></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>2</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
</table>

<p>Note: The m4-stage \(G_{\text{out}}, P_{\text{out}}\) are AND, XOR of \((a_i, b_i)\), which is none other than m2, m7 of \(n\).</p>

<p>\(n=27\) pairs (LSB order): \((1,1), (1,0), (0,1)\)</p>
<ul>
<li>m2(AND): \(1, 0, 0\) &rarr; \(G_{\text{out}} = 1, 0, 0\) &#10003;</li>
<li>m7(XOR): \(0, 1, 1\) &rarr; \(P_{\text{out}} = 0, 1, 1\) &#10003;</li>
</ul>

<p>GPK sequence (from LSB): <b>G, P, G</b></p>

<p><b>Scan:</b></p>

<table>
<tr><th>Step</th><th>\(c_{\text{in}}\)</th><th>GPK</th><th>\(c_{\text{out}}\)</th></tr>
<tr><td>\(i=0\)</td><td>1</td><td>G</td><td>1</td></tr>
<tr><td>\(i=1\)</td><td>1</td><td>P</td><td>1</td></tr>
<tr><td>\(i=2\)</td><td>1</td><td>G</td><td>1</td></tr>
</table>

<p>All pairs have \(c_{\text{in}} = 1\). Consistent with the step-by-step computation of &sect;3.8.</p>

<h2>4.10 Answer to the Question of &sect;4.1</h2>

<p>We organize the answer to the question posed in &sect;4.1: "Is the sequential dependence of carry essential?"</p>

<p><b>Answer 1 (Computational).</b> The local GPK of each pair is obtained in \(O(1)\) by merely referencing m4/m6 bits. Subsequent carry determination completes in a single \(O(k)\) scan. The multiplication \(xn\) is absorbed into reference index shifts and does not appear at the scan stage.</p>

<p><b>Answer 2 (Structural).</b> While the carry <i>values</i> are determined sequentially, each pair's <i>behavior</i> with respect to carry (whether G, P, or K) is independent of the carry value. Thus, "what the carry does" is determined locally; only "how far the carry reaches" is a global question.</p>

<p><b>Answer 3 (Parallelization).</b> The global propagation can also be compressed to \(O(\log k)\) depth via GPK tree composition. This is the same principle as carry-lookahead adders [6], and associativity (Proposition 4.3) guarantees its correctness.</p>

<h2>4.11 Summary of This Section</h2>

<p>1. Carry propagation reduces to GPK (Generate/Propagate/Kill) classification of each pair. GPK is computed by AND and XOR alone, reading bits according to the reference pattern (Table 3.1).</p>

<p>2. Once all GPK values are known, a single \(O(k)\) scan from the LSB determines all carries. The multiplication \(xn\) is absorbed at the reference pattern stage; the scan consists only of AND/OR. Overall complexity is \(O(k)\).</p>

<p>3. When parallelization is needed, binary tree composition of GPK achieves \(O(\log k)\) depth (GPK tree).</p>

<p>4. The reference targets of local GPK differ between \(x=3\) and \(x=5\), but the <b>computational structure is identical</b>.</p>

<!-- ============ SECTION 5 ============ -->
<div class="page-break"></div>
<h1>5. The Structural Privilege of \(3n+1\)</h1>

<p>This section is the core of the paper. We establish that the m4-stage carry structure of \(3n+1\) coincides with intra-pair predicates of \(n\) (Theorem B), and that this property is exclusive to \(x=3\) (Theorem C), using the per-pair independence of the 16 predicates.</p>

<h2>5.1 Theorem B: m4-Stage Coincidence</h2>

<div class="theorem">
<span class="theorem-title">Theorem 5.1 (Theorem B: m4-stage coincidence for \(3n+1\)).</span> In the pair addition for \(3n+1\), the Generate and Propagate of the m4-stage coincide with predicates m2(AND) and m7(XOR) of \(n\), at every pair position. That is, for any odd \(n\) and LSB-ordered pair position \(i\) (\(0 \leq i \leq k-1\)):

$$
G_{\text{out}}[i] = \text{m2}(n)_i = a_i \wedge b_i
$$
$$
P_{\text{out}}[i] = \text{m7}(n)_i = a_i \oplus b_i
$$

<div class="derivation"><i>Derivation.</i> By Proposition 3.4, the m4-stage inputs for \(3n+1\) are \((r_i^{(4)}, a_i) = (b_i, a_i)\). By commutativity:
$$G_{\text{out}}[i] = \text{AND}(b_i, a_i) = a_i \wedge b_i = \text{m2}(n)_i$$
$$P_{\text{out}}[i] = \text{XOR}(b_i, a_i) = a_i \oplus b_i = \text{m7}(n)_i$$
These are exactly the definitions of m2 and m7.</div>
</div>

<div class="theorem">
<span class="theorem-title">Corollary 5.1.</span> For \(3n+1\), the m4-stage Kill coincides with m9(NOR):
$$K_{\text{out}}[i] = \neg a_i \wedge \neg b_i = \text{m9}(n)_i$$
<div class="derivation"><i>Derivation.</i> Since \(G, P, K\) are mutually exclusive and exhaustive, \(K = \neg G \wedge \neg P = \neg(a_i \wedge b_i) \wedge \neg(a_i \oplus b_i)\). By truth table, this is true only when \(a_i = b_i = 0\), matching the definition of m9(NOR).</div>
</div>

<p><b>Interpretation.</b> Restating Theorem 5.1:</p>

<ul>
<li>Pair \((a_i, b_i) = (1,1)\) &rarr; m2=1 &rarr; the m4-stage <b>generates</b> carry</li>
<li>Pair \((a_i, b_i) \in \{(0,1),(1,0)\}\) &rarr; m7=1 &rarr; the m4-stage <b>propagates</b> carry</li>
<li>Pair \((a_i, b_i) = (0,0)\) &rarr; m9=1 &rarr; the m4-stage <b>kills</b> carry</li>
</ul>

<p>The m4-stage carry landscape of \(3n+1\) is completely determined by "reading" the pair type of \(n\). The predicates m2, m7, m9 from the 16-predicate system of Section 2 literally describe the carry dynamics of \(3n+1\).</p>

<h2>5.2 The m6-Stage</h2>

<p>In contrast to the m4-stage, the m6-stage does <i>not</i> coincide with intra-pair predicates of \(n\).</p>

<div class="theorem">
<span class="theorem-title">Proposition 5.1.</span> The m6-stage GPK of \(3n+1\) is:
$$G_{\text{mid}}[i] = a_{i-1} \wedge b_i, \quad P_{\text{mid}}[i] = a_{i-1} \oplus b_i$$

This is a cross-reference between the m4 bit at position \(i-1\) and the m6 bit at position \(i\), and cannot be determined from a single pair position.
</div>

<p><b>Remark 5.1.</b> The overall pair GPK \(G_i = G_{\text{out}}[i] \vee (P_{\text{out}}[i] \wedge G_{\text{mid}}[i])\) contains the m6-stage cross-reference term, so even for \(3n+1\), the <i>overall</i> pair GPK is not per-pair independent. However, the fact that the m4-stage is per-pair independent means that the "upper stage" of the carry structure is directly readable from the predicate table of \(n\).</p>

<h2>5.3 Theorem C: Limitation of the 16 Predicates</h2>

<div class="theorem">
<span class="theorem-title">Definition 5.1.</span> A function \(f: \mathbb{N}_{\text{odd}} \to \{0,1\}^k\) is <i>16-predicate representable</i> if it can be expressed as a finite bitwise Boolean composition of m1&ndash;m16. By Corollary 2.1, every 16-predicate representable function is per-pair independent.
</div>

<div class="theorem">
<span class="theorem-title">Theorem 5.2 (Theorem C: Limitation of the 16 predicates).</span> For \(x \geq 5\) (\(x - 1\) a power of 2), the m4-stage GPK \((G_{\text{out}}, P_{\text{out}})\) of \(xn+1\) is not 16-predicate representable.

<div class="derivation"><i>Derivation.</i> Two steps.

<p><b>Step 1: Identifying the reference structure.</b> For \(x = 5\), the m4-stage inputs are \((a_{i-1}, a_i)\) (Proposition 3.3):</p>
$$G_{\text{out}}[i] = a_{i-1} \wedge a_i, \quad P_{\text{out}}[i] = a_{i-1} \oplus a_i$$
<p>This depends simultaneously on positions \(i-1\) and \(i\).</p>

<p><b>Step 2: Contradiction with per-pair independence.</b> By contradiction. Suppose \((G_{\text{out}}[0], G_{\text{out}}[1], \ldots)\) is 16-predicate representable. By Corollary 2.1, it must be per-pair independent: there exists \(h: \{0,1\}^2 \to \{0,1\}\) such that \(G_{\text{out}}[i] = h(a_i, b_i)\) for all \(i\) and all \(n\). But \(G_{\text{out}}[i] = a_{i-1} \wedge a_i\) depends on \(a_{i-1}\). Fixing \(a_i = 1, b_i = 1\):</p>

<ul>
<li>\(a_{i-1} = 0\) gives \(G_{\text{out}}[i] = 0\)</li>
<li>\(a_{i-1} = 1\) gives \(G_{\text{out}}[i] = 1\)</li>
</ul>

<p>Despite \((a_i, b_i) = (1,1)\) being identical, \(G_{\text{out}}[i]\) varies with \(a_{i-1}\). No function \(h\) of \((a_i, b_i)\) alone can capture this variation. Contradiction.</p>
</div>
</div>

<h2>5.4 Exhaustive Verification</h2>

<p>We supplement the derivation of Theorem 5.2 with a concrete counterexample.</p>

<div class="theorem">
<span class="theorem-title">Proposition 5.2 (Exhaustive non-coincidence).</span> For \(n = 31\), the overall pair GPK \((G_i)\) of \(5n+1\) does not coincide with any of the 784 combinations: 16 single predicates plus \(16 \times 16 \times 3 = 768\) binary combinations (AND, OR, XOR of any two predicates).

<div class="derivation"><i>Verification.</i> \(n = 31 = 011111_2\), pairs \(((0,1),(1,1),(1,1))\), \(k=3\).

<p>LSB order: \(a = (1,1,0)\), \(b = (1,1,1)\).</p>

<p>Overall GPK for \(5n+1\) (MSB order): \(G = (1, 1, 0)\), \(P = (0, 0, 1)\).</p>

<p>The 16-predicate values for \(n=31\) (MSB order, duplicates removed):</p>

$$
\{(0,0,0),\; (0,1,1),\; (1,0,0),\; (1,1,1)\}
$$

<p>Since pairs 1 and 2 are both \((1,1)\), any per-pair independent function must give the same output at both positions. Therefore, the 3-bit patterns attainable by any Boolean composition of the 16 predicates are limited to those with equal second and third components.</p>

<p>However, \(G = (1, 1, 0)\) has second component 1 and third component 0, violating this constraint.</p>

<p>All <b>784 combinations</b> were verified computationally; none match. &#9633;</p>
</div>
</div>

<p><b>Remark 5.2.</b> The essence of Proposition 5.2 is the consequence of per-pair independence that "identical pairs can only produce identical outputs." Because GPK depends on relationships between adjacent pairs, even identical pairs can have different GPK values if their neighboring pairs differ. This is precisely the information that is in principle indescribable within the 16-predicate framework.</p>

<h2>5.5 Classification Theorem</h2>

<div class="theorem">
<span class="theorem-title">Theorem 5.3 (Classification Theorem).</span> For parameters \(x\) with \(x - 1 = 2^s\), the m4-stage GPK of \(xn+1\) is 16-predicate representable if and only if \(s = 1\) (i.e., \(x = 3\)).

<div class="derivation"><i>Derivation.</i>

<p><b>(\(s = 1\)):</b> By Theorem 5.1, \(G_{\text{out}} = \text{m2}\), \(P_{\text{out}} = \text{m7}\). &#10003;</p>

<p><b>(\(s = 2\), \(x = 5\)):</b> m4-stage inputs are \((a_{i-1}, a_i)\). Not representable by Theorem 5.2. &#10007;</p>

<p><b>(\(s \geq 3\)):</b> The reference distance is \(\lfloor s/2 \rfloor \geq 1\) pairs. The same argument as Theorem 5.2 (dependence on \(a_{i-t}\) with \(t \geq 1\)) contradicts per-pair independence. &#10007;</p>

<p>Therefore \(s = 1\) is the only representable case.</p>
</div>
</div>

<div class="theorem">
<span class="theorem-title">Corollary 5.2.</span> \(x = 3\) is the <b>unique</b> \(xn+1\)-type parameter for which the m4-stage carry structure can be read as intra-pair predicates of \(n\).
</div>

<h2>5.6 Structural Interpretation</h2>

<p><b>Why only \(s=1\) is special.</b> In \(xn+1 = 2^s n + n + 1\), the term \(2^s n\) is an \(s\)-bit left shift. The pair structure has width 2 bits, so:</p>

<ul>
<li>\(s = 1\) (less than pair width): The shift swaps m4 and m6 roles but the <b>reference stays within the same pair</b>. \(r_i^{(4)} = b_i\) is the right bit of position \(i\) itself.</li>
<li>\(s = 2\) (equal to pair width): \(r_i^{(4)} = a_{i-1}\) references the previous pair. Inter-pair correlation is unavoidable.</li>
<li>\(s \geq 3\) (exceeds pair width): Even more distant pair correlations.</li>
</ul>

$$
\underbrace{\text{Descriptive power of 16 predicates}}_{\text{intra-pair information (position-independent)}} \quad \text{vs} \quad \underbrace{\text{Requirements of the map}}_{\text{inter-position information (shift-dependent)}}
$$

<p>Only when \(s = 1\) do the requirements fall within the descriptive power.</p>

<p><b>Relation to the Collatz conjecture.</b> Regarding why the Collatz conjecture is formulated for \(3n+1\), the Classification Theorem (5.3) offers the following structural explanation: \(x = 3\) is the unique parameter for which part of the carry structure can be read directly as internal information of \(n\) within the predicate space. This transparency has a direct structural consequence: the m4-stage carry mechanism deterministically annihilates the conditions required for sustained trajectory growth (Proposition 5.4, Remark 5.5). The closed, finite, scale-invariant GPK system of \(3n+1\) cannot maintain the Generate-dominant configurations necessary for divergence.</p>

<h2>5.7 Structural Consequence: Complete Finite Case Analysis</h2>

<p>The structural closure established in Theorem 5.1 has a direct deterministic consequence for the trajectory behavior of \(3n+1\). In this section, we derive this consequence through a <b>complete finite case analysis</b> of the scan transition and re-pairing operations, using the standard GPK (Generate/Propagate/Kill) classification that has been the foundation of carry-lookahead adder design for over half a century [6, 7, 8].</p>

<h3>5.7.1 Complete Scan Transition Table</h3>

<p>For \(x=3\) (\(s=1\), odd), at pair position \(i\) in LSB order, the input state is completely described by three variables:</p>

<ul>
<li><b>Pair type</b> \((a_i, b_i) \in \{(0,0), (0,1), (1,0), (1,1)\}\) &mdash; 4 values</li>
<li><b>Input carry</b> \(c_{\text{in}} \in \{0, 1\}\) &mdash; 2 values</li>
<li><b>Previous left bit</b> \(a_{i-1} \in \{0, 1\}\) &mdash; 2 values (with \(a_{-1} = 0\))</li>
</ul>

<p>Total: \(4 \times 2 \times 2 = 16\) patterns. For each pattern, the output is uniquely determined by the reference pattern of \(3n+1\) (Proposition 3.4):</p>

$$\text{sum}_R = a_{i-1} + b_i + c_{\text{in}}, \quad \text{new\_m6}_i = \text{sum}_R \bmod 2, \quad c_{\text{mid}} = \lfloor \text{sum}_R / 2 \rfloor$$
$$\text{sum}_L = b_i + a_i + c_{\text{mid}}, \quad \text{new\_m4}_i = \text{sum}_L \bmod 2, \quad c_{\text{out}} = \lfloor \text{sum}_L / 2 \rfloor$$

<p><b>Table 5.1: Complete scan transition table for \(3n+1\).</b></p>

<table>
<tr><th>#</th><th>Input \((a,b)\)</th><th>GPK</th><th>\(c_{\text{in}}\)</th><th>\(a_{i-1}\)</th><th>sum\(_R\)</th><th>new m6</th><th>\(c_{\text{mid}}\)</th><th>sum\(_L\)</th><th>new m4</th><th>\(c_{\text{out}}\)</th><th>Output</th><th>Out GPK</th></tr>
<tr><td>1</td><td>(0,0)</td><td>K</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,0)</td><td>K</td></tr>
<tr><td>2</td><td>(0,0)</td><td>K</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,1)</td><td>P</td></tr>
<tr><td>3</td><td>(0,0)</td><td>K</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>(0,1)</td><td>P</td></tr>
<tr><td>4</td><td>(0,0)</td><td>K</td><td>1</td><td>1</td><td>2</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>(1,0)</td><td>P</td></tr>
<tr><td>5</td><td>(0,1)</td><td>P</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
<tr><td>6</td><td>(0,1)</td><td>P</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>(0,0)</td><td>K</td></tr>
<tr><td>7</td><td>(0,1)</td><td>P</td><td>1</td><td>0</td><td>2</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>(0,0)</td><td>K</td></tr>
<tr><td>8</td><td>(0,1)</td><td>P</td><td>1</td><td>1</td><td>3</td><td>1</td><td>1</td><td>2</td><td>0</td><td>1</td><td>(0,1)</td><td>P</td></tr>
<tr><td>9</td><td>(1,0)</td><td>P</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>(1,0)</td><td>P</td></tr>
<tr><td>10</td><td>(1,0)</td><td>P</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
<tr><td>11</td><td>(1,0)</td><td>P</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
<tr><td>12</td><td>(1,0)</td><td>P</td><td>1</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>(0,0)</td><td>K</td></tr>
<tr><td>13</td><td>(1,1)</td><td>G</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>2</td><td>0</td><td>1</td><td>(0,1)</td><td>P</td></tr>
<tr><td>14</td><td>(1,1)</td><td>G</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>3</td><td>1</td><td>1</td><td>(1,0)</td><td>P</td></tr>
<tr><td>15</td><td>(1,1)</td><td>G</td><td>1</td><td>0</td><td>2</td><td>0</td><td>1</td><td>3</td><td>1</td><td>1</td><td>(1,0)</td><td>P</td></tr>
<tr><td>16</td><td>(1,1)</td><td>G</td><td>1</td><td>1</td><td>3</td><td>1</td><td>1</td><td>3</td><td>1</td><td>1</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
</table>

<p>All 16 entries are derived from the five-line arithmetic above, which is itself a direct consequence of the algebraic identity \(3n+1 = 2n + n + 1\).</p>

<p><b>Remark.</b> The scan defines a <i>deterministic finite state transducer</i> (DFST) with state \((c_{\text{in}}, a_{i-1}) \in \{0,1\}^2\) (4 states), input alphabet \(\{(0,0), (0,1), (1,0), (1,1)\}\) (4 symbols), and deterministic output. The initial state is \((c_{\text{in}}, a_{i-1}) = (1, 0)\) (the +1 effect and boundary condition). Each output \((c_{\text{out}}, \text{new\_m4})\) uniquely determines the next state.</p>

<p><b>Remark (DFST permutation property).</b> For each of the four DFST states, the map from input pair type to output pair type is a <i>permutation</i> of \(\{K, P(0,1), P(1,0), G\}\):</p>

<table>
<tr><th>State \((c_{\text{in}}, a_{i-1})\)</th><th>K\(\to\)</th><th>P(0,1)\(\to\)</th><th>P(1,0)\(\to\)</th><th>G\(\to\)</th></tr>
<tr><td>(0, 0)</td><td>K</td><td>G</td><td>P(1,0)</td><td>P(0,1)</td></tr>
<tr><td>(0, 1)</td><td>P(0,1)</td><td>K</td><td>G</td><td>P(1,0)</td></tr>
<tr><td>(1, 0)</td><td>P(0,1)</td><td>K</td><td>G</td><td>P(1,0)</td></tr>
<tr><td>(1, 1)</td><td>P(1,0)</td><td>P(0,1)</td><td>K</td><td>G</td></tr>
</table>

<p>Each row contains exactly one occurrence of each pair type. This is not assumed but directly verified from Table 5.1. The permutation property means that the scan, viewed as a local transformation at each pair position, preserves the multiplicity of pair types: it does not structurally favor any type over others. Note that states (0,1) and (1,0) induce the same permutation.</p>

<h3>5.7.2 Structural Properties from the Scan Table</h3>

<div class="theorem">
<span class="theorem-title">Lemma 5.1 (G-block entry elimination).</span>
<p>(a) The only scan case where a G-input produces a G-output is Case 16, which requires \(c_{\text{in}} = 1\) and \(a_{i-1} = 1\).</p>
<p>(b) The <b>leftmost</b> G-block's leading G-position is always converted to P in the scan output.</p>
<p>(c) When carry from a G-block propagates rightward through a P(1,0) bridge, each P(1,0) position is converted to K(0,0) (Case 12), destroying the bridge.</p>

<div class="derivation"><i>Derivation.</i>
(a) Direct inspection of Table 5.1: only Case 16 maps G-input to G-output, requiring both \(c_{\text{in}} = 1\) and \(a_{i-1} = 1\).

<p>(b) At the leading position of the leftmost G-block, the predecessor is either the boundary (\(a_{-1} = 0\), Case 16 fails), K (\(c_{\text{out}} = 0\), Case 16 fails), or P(0,1) (\(a_{i-1} = 0\), Case 16 fails). If the predecessor is P(1,0) with \(c_{\text{in}} = 1\), the carry must originate from an earlier G-block&mdash;but no earlier G-block exists. Therefore, the leftmost G-block's leading G is converted to P (Cases 13, 14, or 15).</p>

<p>(c) P(1,0) with \(c_{\text{in}} = 1\) and \(a_{i-1} = 1\) (from a preceding G or P(1,0)) triggers Case 12: output K(0,0), \(c_{\text{out}} = 1\). The carry passes through, but the bridge position is destroyed.</p></div>
</div>

<p><b>Consequence (left-to-right consumption).</b> A non-leftmost G-block may temporarily retain its leading G if an unbroken P(1,0) bridge delivers carry from a preceding G-block (Case 16 at the entry). However, such a bridge is simultaneously converted to K(0,0) by part (c). By Lemma 5.5 (below), the K barrier persists through re-pairing. Therefore, when the leftmost G-block is fully consumed, the carry supply to the next G-block is severed, and that block becomes the new leftmost&mdash;its leading G then subject to part (b). G-blocks are consumed sequentially from left to right.</p>

<p><b>Example.</b> For \(n = 1003 = 1111101011_2\), pairs (LSB): G, P(1,0), P(1,0), G, G. The scan converts G-block 1's leading G to P (Case 15), the P(1,0) bridge to K (Case 12&times;2), while G-block 2's leading G is preserved (Case 16). However, the bridge is now K(0,0), so at the next step, G-block 2's leading G is subject to part (b). Total G-count: 3 &rarr; 2.</p>

<div class="theorem">
<span class="theorem-title">Lemma 5.2 (Impossibility of K\(\to\)G).</span> No Kill position in the input can produce a Generate position in the output.

<div class="derivation"><i>Derivation.</i> Cases 1&ndash;4 of Table 5.1 cover all four contexts for K-input \((0,0)\). The outputs are K(0,0), P(0,1), P(0,1), and P(1,0) respectively. None is G(1,1).</div>
</div>

<div class="theorem">
<span class="theorem-title">Lemma 5.3 (P\(\to\)G constraint).</span> The only cases producing G-output from P-input are Cases 5, 10, and 11. In all three cases, \(c_{\text{out}} = 0\).

<div class="derivation"><i>Derivation.</i> Inspection of P-input rows (Cases 5&ndash;12) in Table 5.1. Cases producing G-output: Case 5 (P(0,1), \(c_{\text{in}}=0, a_{i-1}=0\)), Case 10 (P(1,0), \(c_{\text{in}}=0, a_{i-1}=1\)), Case 11 (P(1,0), \(c_{\text{in}}=1, a_{i-1}=0\)). All have \(c_{\text{out}} = 0\).</div>
</div>

<p><b>Remark (Case 10 chaining).</b> A consecutive run of P(1,0) inputs can trigger a chain of Case 10 applications: each produces G-output with \(c_{\text{out}} = 0\) and \(\text{new\_m4} = 1\), providing \(a_{i-1} = 1\) and \(c_{\text{in}} = 0\) for the next position. Thus P(1,0) runs of length \(M\) can produce G-blocks of length \(M\) in the output. However: (i) this consumes \(M\) P-positions from the input, (ii) all generated G-positions have \(c_{\text{out}} = 0\), so the resulting G-block carries no internal carry chain, and (iii) at the next scan step, Lemma 5.1(b) applies when this new G-block is the leftmost, or the left-to-right consumption mechanism governs its lifetime.</p>

<div class="theorem">
<span class="theorem-title">Lemma 5.4 (Carry output of G-positions).</span> For all four G-input cases (Cases 13&ndash;16), \(c_{\text{out}} = 1\).

<div class="derivation"><i>Derivation.</i> Direct inspection of Table 5.1, Cases 13&ndash;16. This is a computational confirmation of the Generate property: \(G_{\text{out}} = a_i \wedge b_i = 1 \wedge 1 = 1\), which produces \(c_{\text{out}} = 1\) unconditionally, regardless of \(c_{\text{in}}\) or \(a_{i-1}\).</div>
</div>

<h3>5.7.3 Re-pairing Transition Table</h3>

<p>After computing \(3n+1\), the division by \(2^d\) removes \(d\) trailing zeros. When \(d\) is odd, the remaining bit string requires re-pairing with a 1-bit boundary shift (&sect;6). Each new pair is formed from the left bit of one old pair and the right bit of the adjacent old pair:</p>

$$\text{new\_m6}'_i = \text{old\_m4}_A, \quad \text{new\_m4}'_i = \text{old\_m6}_B$$

<p>where \(A\) and \(B\) are adjacent pairs in the scan output. (When \(d\) is even, pairs are preserved and no re-pairing occurs.)</p>

<p><b>Table 5.2: Re-pairing transition table (\(d\) odd).</b></p>

<table>
<tr><th>#</th><th>Pair A</th><th>A GPK</th><th>Pair B</th><th>B GPK</th><th>new m6'</th><th>new m4'</th><th>New pair</th><th>New GPK</th></tr>
<tr><td>R1</td><td>(0,0)</td><td>K</td><td>(0,0)</td><td>K</td><td>0</td><td>0</td><td>(0,0)</td><td>K</td></tr>
<tr><td>R2</td><td>(0,0)</td><td>K</td><td>(0,1)</td><td>P</td><td>0</td><td>1</td><td>(1,0)</td><td>P</td></tr>
<tr><td>R3</td><td>(0,0)</td><td>K</td><td>(1,0)</td><td>P</td><td>0</td><td>0</td><td>(0,0)</td><td>K</td></tr>
<tr><td>R4</td><td>(0,0)</td><td>K</td><td>(1,1)</td><td>G</td><td>0</td><td>1</td><td>(1,0)</td><td>P</td></tr>
<tr><td>R5</td><td>(0,1)</td><td>P</td><td>(0,0)</td><td>K</td><td>0</td><td>0</td><td>(0,0)</td><td>K</td></tr>
<tr><td>R6</td><td>(0,1)</td><td>P</td><td>(0,1)</td><td>P</td><td>0</td><td>1</td><td>(1,0)</td><td>P</td></tr>
<tr><td>R7</td><td>(0,1)</td><td>P</td><td>(1,0)</td><td>P</td><td>0</td><td>0</td><td>(0,0)</td><td>K</td></tr>
<tr><td>R8</td><td>(0,1)</td><td>P</td><td>(1,1)</td><td>G</td><td>0</td><td>1</td><td>(1,0)</td><td>P</td></tr>
<tr><td>R9</td><td>(1,0)</td><td>P</td><td>(0,0)</td><td>K</td><td>1</td><td>0</td><td>(0,1)</td><td>P</td></tr>
<tr><td>R10</td><td>(1,0)</td><td>P</td><td>(0,1)</td><td>P</td><td>1</td><td>1</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
<tr><td>R11</td><td>(1,0)</td><td>P</td><td>(1,0)</td><td>P</td><td>1</td><td>0</td><td>(0,1)</td><td>P</td></tr>
<tr><td>R12</td><td>(1,0)</td><td>P</td><td>(1,1)</td><td>G</td><td>1</td><td>1</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
<tr><td>R13</td><td>(1,1)</td><td>G</td><td>(0,0)</td><td>K</td><td>1</td><td>0</td><td>(0,1)</td><td>P</td></tr>
<tr><td>R14</td><td>(1,1)</td><td>G</td><td>(0,1)</td><td>P</td><td>1</td><td>1</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
<tr><td>R15</td><td>(1,1)</td><td>G</td><td>(1,0)</td><td>P</td><td>1</td><td>0</td><td>(0,1)</td><td>P</td></tr>
<tr><td>R16</td><td>(1,1)</td><td>G</td><td>(1,1)</td><td>G</td><td>1</td><td>1</td><td><b>(1,1)</b></td><td><b>G</b></td></tr>
</table>

<p>New G is produced if and only if \(\text{m4}_A = 1\) and \(\text{m6}_B = 1\) (Cases R10, R12, R14, R16). Note that this requires pair A to have left bit 1 (i.e., A is P(1,0) or G(1,1)) and pair B to have right bit 1 (i.e., B is P(0,1) or G(1,1)).</p>

<h3>5.7.4 Lemmas from the Re-pairing Table</h3>

<div class="theorem">
<span class="theorem-title">Lemma 5.5 (G-block non-mergeability).</span> Two G-blocks separated by one or more non-G pairs in the scan output remain separated after re-pairing (\(d\) odd). The separating barrier may shift position but does not vanish.

<div class="derivation"><i>Derivation.</i> Consider two G-blocks separated by a single P. If P = P(0,1): the G&ndash;P boundary gives \((\text{m6}_P, \text{m4}_G) = (1, 1) = G\), but the P&ndash;G boundary gives \((\text{m6}_G, \text{m4}_P) = (1, 0) = P\). The barrier shifts left but persists. If P = P(1,0): the G&ndash;P boundary gives P, the P&ndash;G boundary gives G. The barrier shifts right but persists. For separations of \(k \geq 2\) non-G pairs, the argument extends: at each boundary, since non-G pairs have at least one bit equal to 0 (P has \(a \oplus b = 1\); K has \(a = b = 0\)), the re-pairing formula \((\text{m4}_A, \text{m6}_B)\) cannot produce \((1,1)\) at every boundary position. At least one P barrier remains.</div>
</div>

<div class="theorem">
<span class="theorem-title">Lemma 5.6 (G-block tail growth bound).</span> Under re-pairing (\(d\) odd), a G-block can extend by at most 1 position at its tail.

<div class="derivation"><i>Derivation.</i> Let the last G-position of a block be at position \(k\), with successor pair [next]. Under re-pairing, the new pair at position \(k\) is \((\text{m6}_{\text{next}}, \text{m4}_G) = (\text{m6}_{\text{next}}, 1)\). This is G iff \(\text{m6}_{\text{next}} = 1\), i.e., [next] is P(0,1) or G(1,1) &mdash; a tail extension of +1. However, the new pair at position \(k+1\) is \((\text{m6}_{\text{next}+1}, \text{m4}_{\text{next}})\). If [next] = P(0,1), then \(\text{m4}_{\text{next}} = 0\), so the new pair has \(\text{m4}' = 0\), which cannot be G. The tail extension is bounded at 1. The tail extension requires the specific configuration [next] = P(0,1), which is consumed in the process and unavailable at the next step. For the leftmost G-block whose leading G is always eliminated (Lemma 5.1(b)), the net change per step is at most \(0\) (\(-1\) head + at most \(+1\) tail).</div>
</div>

<p><b>Remark (Integrated G-block lifecycle).</b> For the <b>leftmost</b> G-block of initial length \(L\), combining the scan transition (Lemma 5.1(b)) with the re-pairing transition (Lemma 5.6), the net G-count change in a single step depends on the parity of \(d\) and the type of the head conversion:</p>

<ul>
<li><b>\(d\) even:</b> Scan converts the leading G to P (\(-1\)). No re-pairing occurs. G&ndash;G boundaries are preserved. Net change: \(-1\).</li>
<li><b>\(d\) odd, head converted to P(0,1):</b> Scan produces P(0,1) followed by \((L-1)\) G-positions. Re-pairing at the P(0,1)&ndash;G boundary gives Case R8: \((\text{m4}_A, \text{m6}_B) = (0, 1) \to P\), destroying one additional G-position. G&ndash;G internal boundaries give Case R16 (G preserved). Net change: \(-2\).</li>
<li><b>\(d\) odd, head converted to P(1,0):</b> Scan produces P(1,0) followed by \((L-1)\) G-positions. Re-pairing at the P(1,0)&ndash;G boundary gives Case R12: \((\text{m4}_A, \text{m6}_B) = (1, 1) \to G\), recovering the boundary. Net change: \(-1\).</li>
</ul>

<p>The most typical case&mdash;G-block preceded by K(0,0), giving \(P_{\text{head}} = P(0,1)\) via Case 13&mdash;yields \(-2\) per step. In all cases, the leftmost G-block loses at least one G per step. A leftmost G-block of initial length \(L\) is therefore fully consumed in at most \(L\) steps. (Non-leftmost G-blocks may temporarily retain their leading G via carry from the left; see Lemma 5.1(a) and the left-to-right consumption mechanism.)</p>

<div class="theorem">
<span class="theorem-title">Lemma 5.7 (Isolated G lifetime).</span> An isolated G-block (length 1) that is the leftmost G-block, or whose predecessor is K or P(0,1), is converted to P at the next scan step. An isolated G receiving carry via a P(1,0) bridge from a preceding G-block may survive that step, but the bridge is destroyed (Lemma 5.1(c)), and the isolated G is converted once the carry supply is severed.

<div class="derivation"><i>Derivation.</i> An isolated G consists entirely of its leading position. When the conditions for Lemma 5.1(b) are met (leftmost, or no carry from the left), the leading G is converted to P. When carry arrives via P(1,0) bridge, Case 16 preserves the G, but the bridge is simultaneously converted to K(0,0) (Lemma 5.1(c)). At the subsequent step, the K barrier blocks carry, and Lemma 5.1(b) applies.</div>
</div>

<p><b>Remark (P\(\to\)G products under re-pairing).</b> When \(d\) is odd, an isolated G (length 1) produced by a P\(\to\)G transition (Lemma 5.3) undergoes re-pairing with its neighbors. Let A be the predecessor pair and C the successor pair in the scan output. The re-pairing creates two new boundary pairs:</p>

<ul>
<li>A&ndash;G boundary: \(\text{new\_m4}' = \text{m6}_G = 1\), \(\text{new\_m6}' = \text{m4}_A\). New pair is G iff \(\text{m4}_A = 1\) (A is P(1,0) or G).</li>
<li>G&ndash;C boundary: \(\text{new\_m6}' = \text{m4}_G = 1\), \(\text{new\_m4}' = \text{m6}_C\). New pair is G iff \(\text{m6}_C = 1\) (C is P(0,1) or G).</li>
</ul>

<p>An isolated G can thus expand to at most 2 G-positions under re-pairing, or vanish entirely, depending on the neighbor pair types. Crucially, all P\(\to\)G outputs have \(c_{\text{out}} = 0\) (Lemma 5.3), so the successor pair is computed with \(c_{\text{in}} = 0\). This carry severance prevents P\(\to\)G products from initiating new carry chains, structurally limiting their ability to seed large G-blocks.</p>

<h3>5.7.5 The Division Exponent and Growth</h3>

<div class="theorem">
<span class="theorem-title">Lemma 5.8 (\(d = 1\) iff pair 0 is G).</span> For odd \(n\), in the scan output (LSB order), \(d = 1\) if and only if the input pair at position 0 is G(1,1).

<div class="derivation"><i>Derivation.</i> For odd \(n\), \(b_0 = 1\) (the least significant bit is 1), so pair 0 is either G(1,1) or P(0,1). The scan initial state is \((c_{\text{in}}, a_{i-1}) = (1, 0)\). If pair 0 = G(1,1): Case 15 applies, output = (1,0), trailing bits = \(\ldots 10\), so \(d = 1\). If pair 0 = P(0,1): Case 7 applies, output = (0,0), trailing bits = \(\ldots 00\), so \(d \geq 2\).</div>
</div>

<p><b>Remark (General division exponent formula).</b> For odd \(n\), the full division exponent \(d\) is determined by the input pair sequence as follows. Let \(j \geq 0\) be the number of leading P(0,1) pairs (i.e., pairs 0 through \(j-1\) are all P(0,1), and pair \(j\) is the first non-P(0,1) pair). Then:</p>
<ul>
<li>If pair \(j\) is G(1,1): \(d = 2j + 1\) (odd)</li>
<li>If pair \(j\) is K(0,0) or P(1,0): \(d = 2j\) (even, with \(j \geq 1\))</li>
</ul>
<p><i>Derivation.</i> By the DFST initial state \((c_{\text{in}}, a_{i-1}) = (1, 0)\): input P(0,1) at pair 0 triggers Case 7, producing output K(0,0) with \((c_{\text{out}}, \text{new\_m4}) = (1, 0)\), maintaining the DFST in state \((1, 0)\). Each subsequent P(0,1) repeats Case 7, extending the trailing-zero output by two bits per pair. When the first non-P(0,1) pair is reached at position \(j\) in DFST state \((1, 0)\): K(0,0) triggers Case 3 (output P(0,1), first non-zero bit at position \(2j\), so \(d = 2j\)); P(1,0) triggers Case 11 (output G(1,1), first non-zero bit at position \(2j\), so \(d = 2j\)); G(1,1) triggers Case 15 (output P(1,0) with bits \((\text{m6}, \text{m4}) = (0, 1)\), first non-zero bit at position \(2j+1\), so \(d = 2j+1\)). For \(j = 0\) with pair 0 = G: Case 15 gives \(d = 1\), recovering Lemma 5.8.</p>

<p><b>Remark (Expected division exponent under uniform distribution).</b> If pair types are independently and uniformly distributed (each of \(\{K, P(0,1), P(1,0), G\}\) with probability \(1/4\), subject to the constraint that pair 0 of odd \(n\) has \(b_0 = 1\), giving equal probability \(1/2\) to G and P(0,1) at pair 0), the d-formula yields \(E[d] = 2\) by geometric series evaluation. The net expected bit change per step is \(\log_2 3 - E[d] \approx 1.585 - 2 = -0.415\) bits, consistent with the known contraction rate of Collatz trajectories. By the DFST permutation property, the scan does not structurally bias the output toward any particular pair type, so the uniform distribution assumption is self-consistent at the single-step level.</p>

<p><b>Remark (\(d=1\) re-pairing lifecycle).</b> When \(d = 1\) (pair 0 = G, Case 15 output = P(1,0)), the division removes only bit 0, and re-pairing produces new pairs: \(\text{new pair } i = (\text{old\_m6}_{i+1},\, \text{old\_m4}_i)\). Since the scan output has \(\text{m4}_0 = 1\) (from Case 15), \(\text{new pair } 0 = (\text{old\_m6}_1,\, 1)\). If the original pair 1 was also G (within the same G-block), then \(\text{old\_m6}_1 = 1\), giving new pair 0 = G(1,1). Thus \(d = 1\) can recur at the next step. However, the G-block loses at least 1 G per step (integrated lifecycle above), so \(d = 1\) persists for at most \(L\) consecutive steps, where \(L\) is the initial G-block length containing pair 0. When \(\text{old\_m6}_1 \neq 1\) (pair 1 is K or P(1,0)), new pair 0 = P(0,1), and \(d \geq 2\) at the next step. This is consistent with the arithmetic bound of Corollary 5.3.</p>

<p><b>Growth condition.</b> Each step of \(3n+1\) adds \(\log_2 3 \approx 1.585\) bits and removes \(d\) bits. Net bit growth is positive only when \(d = 1\). By Lemma 5.8, sustained growth requires pair 0 to be G(1,1) at every step. Pair 0, as the leftmost pair, is always in or to the left of the leftmost G-block. By Lemma 5.1(b), the leftmost G-block's leading G is eliminated at each scan step; by Lemma 5.6, its net length change is at most \(0\). The leftmost G-block containing pair 0 is therefore consumed in finite time, after which \(d \geq 2\) and the trajectory contracts.</p>

<div class="theorem">
<span class="theorem-title">Corollary 5.3 (Arithmetic bound on consecutive \(d=1\)).</span> Let \(n\) be odd and let \(n_0 = n,\; n_{j+1} = (3n_j + 1)/2^{d_j}\) be the odd-to-odd trajectory. If \(d_j = 1\) for \(L\) consecutive steps \(j = 0, 1, \ldots, L-1\), then \(n \equiv 2^{L+1} - 1 \pmod{2^{L+1}}\), i.e., the lowest \(L+1\) bits of \(n\) are all 1.
</div>

<div class="derivation"><i>Derivation.</i> By induction on \(L\). <b>Base case</b> (\(L=1\)): By Lemma 5.8, \(d_0 = 1\) iff pair 0 of \(n\) is G(1,1), i.e., \((a_0, b_0) = (1,1)\). Since \(n\) is odd, \(b_0 = 1\), and the condition is \(a_0 = 1\), meaning the lowest two bits are 11, so \(n \equiv 3 \pmod{4}\).

<p><b>Inductive step</b>: Suppose \(L\) consecutive \(d=1\) steps require \(n \equiv 2^{L+1} - 1 \pmod{2^{L+1}}\). For \(L+1\) consecutive steps, we additionally need \(d_1 = 1\) for \(n_1 = (3n+1)/2\). By Lemma 5.8, \(n_1 \equiv 3 \pmod{4}\), i.e., \((3n+1)/2 \equiv 3 \pmod{4}\). This gives \(3n+1 \equiv 6 \pmod{8}\), hence \(n \equiv 7 \pmod{8}\), meaning the lowest 3 bits are 111. Continuing, \(L+1\) consecutive \(d=1\) requires \(n \equiv 2^{L+2} - 1 \pmod{2^{L+2}}\).</p></div>

<p><b>Consequence.</b> Since \(n\) is a finite natural number with at most \(\lfloor \log_2 n \rfloor + 1\) bits, the maximum number of consecutive \(d = 1\) steps starting from \(n\) is at most \(\lfloor \log_2 n \rfloor\). This is an <i>independent</i> arithmetic derivation of the finiteness of \(d = 1\) streaks, requiring only modular arithmetic&mdash;no GPK analysis, no transition tables, no G-block dynamics. The fact that two entirely different methods (GPK structural analysis and modular arithmetic) reach the same conclusion reinforces the robustness of the result.</p>

<h3>5.7.6 Proposition 5.4: Complete Derivation</h3>

<div class="theorem">
<span class="theorem-title">Proposition 5.4 (Self-annihilation of G-dominance).</span> In the GPK system of \(3n+1\), the <b>activation condition</b> for carry generation (G-dominance, i.e., high concentration of \((1,1)\)-pairs) and the <b>activation result</b> (carry-induced destruction of G-blocks) are inseparably coupled within the same algebraic identity. No configuration can maintain G-dominance indefinitely.
</div>

<p><i>Derivation.</i> The result follows from Lemmas 5.1&ndash;5.8, which are derived exhaustively from Tables 5.1 and 5.2.</p>

<p><b>Step 1: Inseparable coupling.</b> Maintaining G-dominance requires a high concentration of \((1,1)\)-pairs. By Theorem 5.1, each \((1,1)\)-pair is assigned Generate. By Lemma 5.4, every G-position outputs \(c_{\text{out}} = 1\) unconditionally (all four G-cases in Table 5.1 confirm this). This carry enters the output bit formula as an XOR operand, deterministically transforming the output pair types at G-block boundaries. By Lemma 5.1(b), the leftmost G-block's leading G is always converted to P. By Lemma 5.1(c), any P(1,0) bridge carrying this carry to subsequent G-blocks is simultaneously destroyed (converted to K). This coupling&mdash;(1,1)-pairs produce G, G produces carry, carry destroys G and the bridges connecting G-blocks&mdash;is a direct consequence of the identity \(3n+1 = 2n + n + 1\) and cannot be circumvented within the closed system.</p>

<p><b>Step 2: Left-to-right G-block consumption.</b> G-blocks are consumed sequentially from left to right:</p>
<ul>
<li>Lemma 5.1(b): The leftmost G-block's leading G is eliminated at each scan step (\(-1\) per step)</li>
<li>Lemma 5.6: Tail extension bounded at \(+1\) per re-pairing; for the leftmost block, net change \(\leq 0\)</li>
<li>Lemma 5.1(c): P(1,0) bridges between G-blocks are converted to K during carry propagation</li>
<li>Lemma 5.5: K barriers persist through re-pairing, so G-blocks cannot merge</li>
<li>When the leftmost G-block is fully consumed, the K barrier severs carry to the next G-block, which becomes the new leftmost and begins its own consumption</li>
</ul>

<p>The leftmost G-block of initial length \(L\) has a finite lifetime bounded by \(L\) (net change \(\leq 0\) per step). Non-leftmost blocks may be temporarily preserved by carry from the left, but the bridge destruction ensures that each block eventually becomes the leftmost. The total consumption time for all G-blocks is finite.</p>

<p><b>Carry asymmetry bridge.</b> A natural question arises: even though each individual G-block has a finite lifetime, could P&rarr;G transitions continuously replenish the G supply, maintaining G-dominance indefinitely? The carry structure of Table 5.1 rules this out through an asymmetry between destruction and creation.</p>

<p><i>Destruction chains.</i> When the leftmost G-block's leading G is consumed (Lemma 5.1(b)), the output carry is \(c_{\text{out}} = 1\) (Lemma 5.4: all four G-input cases produce \(c_{\text{out}} = 1\)). This carry does not stop at the consumed position. It flows rightward into the next position as \(c_{\text{in}} = 1\). If that next position is a P(1,0) bridge connecting two G-blocks, the carry converts it to K(0,0) (Lemma 5.1(c), Table 5.1 Case 12), producing another \(c_{\text{out}} = 1\) that propagates further. The newly created K barrier then permanently severs the carry connection to subsequent G-blocks (Lemma 5.5). In this way, a single consumption event at the G-block head cascades rightward: it eliminates one G, destroys the bridge, and isolates the next G-block&mdash;all from one carry chain.</p>

<p><i>Creation does not chain.</i> In contrast, when a P position is converted to G (Cases 5, 10, 11), the output carry is \(c_{\text{out}} = 0\) (Lemma 5.3). This means the newly created G produces no carry that flows to its right neighbor. The next position receives \(c_{\text{in}} = 0\) from this event and is structurally unaffected by it. The creation is a local, one-position event with no rightward propagation. Furthermore, Case 10 chaining&mdash;the only mechanism that creates a G-block of length \(M\) from \(M\) consecutive P(1,0) positions&mdash;consumes those \(M\) P-positions as fuel. This fuel is removed from the pair sequence in the same step and is not regenerated.</p>

<p>This asymmetry is summarized as follows: each G-destruction event produces \(c_{\text{out}} = 1\), which cascades into bridge destruction and carry severance affecting multiple downstream positions. Each G-creation event produces \(c_{\text{out}} = 0\), affecting only the single position where the creation occurs and consuming P-fuel in the process. Both facts are per-case readings from Table 5.1, not quantitative estimates. Since destruction cascades while creation does not, P&rarr;G generation cannot systematically compensate for the left-to-right consumption process.</p>

<p><b>Step 3: New G-generation is structurally bounded.</b> Given this carry asymmetry, new G-positions arise only from P\(\to\)G transitions (Lemma 5.3: Cases 5, 10, 11) and re-pairing (Table 5.2: Cases R10, R12, R14, R16). By Lemma 5.2, K\(\to\)G is impossible. The P\(\to\)G transitions all produce \(c_{\text{out}} = 0\) (Lemma 5.3), meaning newly generated G-blocks carry no internal carry chain. Case 10 chaining can convert a P(1,0) run of length \(M\) into a G-block of length \(M\), but this consumes \(M\) P-positions from the input. The same Lemmas 5.1&ndash;5.7 apply to these newly created G-blocks: they have finite lifetime and cannot merge with existing blocks.</p>

<p><b>Dimensional separation.</b> The DFST permutation property (&sect;5.7.1) ensures that for each fixed DFST state, the map from input pair type to output pair type is a bijection on \(\{K, P(0,1), P(1,0), G\}\). However, the DFST state \((c_{\text{in}}, a_{i-1})\) varies by position, determined by the carry chain and the preceding input. Different positions therefore undergo different permutations, and global type counts are <i>not</i> preserved. For example, two consecutive G-inputs at positions 0 and 1 yield P(1,0) and G respectively (states (1,0) and (1,1)), reducing the G-count from 2 to 1. This is precisely the mechanism of Lemma 5.1(b): the leftmost G-block's leading G is systematically converted to P.</p>

<p>A natural question remains: even though G-blocks are consumed at the left, could P\(\to\)G transitions elsewhere sustain enough G-positions to continually replenish pair 0 = G? The growth condition \(d = 1\) requires pair 0 = G(1,1) (Lemma 5.8)&mdash;a <i>positional</i> condition on a specific location, not a condition on aggregate G-count. The G-block degradation established by Lemmas 5.1&ndash;5.7 operates in this positional dimension: head elimination, bridge destruction, non-mergeability, and tail growth bounds concern the spatial structure of consecutive G-positions. The aggregate number of G-positions elsewhere is structurally irrelevant to whether pair 0 is G. Once the leftmost G-block containing pair 0 is consumed, the condition pair 0 = G is lost regardless of how many G-positions exist at other locations.</p>

<p><b>Re-pairing pathway containment.</b> After division by \(2^d\), when \(d\) is odd, re-pairing reassigns pair boundaries (Table 5.2), which can place G at the new pair 0 through mechanical re-indexing rather than type redistribution. However, any G-block at pair 0 arising from re-pairing is subject to the full structural constraint set: finite lifetime (Lemmas 5.1(b), 5.6, 5.7), non-mergeability (Lemma 5.5), and the inseparable coupling of Step 1. Each such G-block is consumed in at most \(L'\) steps (its initial length), after which \(d \geq 2\) and the trajectory contracts. Re-pairing provides no escape from the consumption process; it merely initiates a new finite episode, each terminated by contraction.</p>

<p><b>Step 4: Four-phase closure.</b> The one-step map \(T(n) = (3n+1)/2^d\) decomposes into four phases, each operating on the same closed set of four pair types \(\{(0,0), (0,1), (1,0), (1,1)\}\) with three GPK classes \(\{G, P, K\}\):</p>
<ol>
<li><b>Scan</b> (carry propagation): A deterministic finite-state transducer with 4 states, governed by Table 5.1 (16 cases). The DFST permutation property ensures that each state maps the four input types to a permutation of the four output types.</li>
<li><b>Division exponent determination</b>: The value \(d\) is a deterministic function of the scan output pair sequence, given by the formula in &sect;5.7.5 (the number of leading P(0,1) pairs and the type of the first non-P(0,1) pair).</li>
<li><b>Trailing zero removal</b> (\(\div 2^d\)): Removes \(\lfloor d/2 \rfloor\) trailing K(0,0) pairs and, when \(d\) is odd, one additional bit that triggers re-pairing. The removed pairs are all K(0,0) (trailing zeros); the remaining pair types are preserved.</li>
<li><b>Re-pairing</b> (when \(d\) is odd): Governed by Table 5.2 (16 cases). New pair types are determined by adjacent old pairs through the formula \(\text{new\_m6}' = \text{m4}_A\), \(\text{new\_m4}' = \text{m6}_B\).</li>
</ol>
<p>No phase introduces pair types or GPK classes outside the established sets. The associative composition rule \(G \circ X = G\), \(K \circ X = K\), \(P \circ X = X\) [6, 7, 8] is preserved throughout. The output \(n'\) has a new pair sequence from the same four types, and its GPK is determined by the same algebraic identity (Theorem 5.1). Both finite tables (16 + 16 cases) are exhaustive enumerations derived from the identity \(3n+1 = 2n + n + 1\) and the exchange principle of &sect;6, requiring no assumptions beyond elementary arithmetic.</p>

<p><b>Step 5: Scale invariance.</b> The per-pair determination of the m4-stage GPK (Theorem 5.1) is an algebraic identity, not a finite verification. It holds for all \(n \in \mathbb{N}\), at every bit-length. The 16-pattern scan table (Table 5.1) and the 16-pattern re-pairing table (Table 5.2) are exhaustive: they cover every possible input state. Lemmas 5.1&ndash;5.8 are logical consequences of these tables and therefore hold universally. A divergent trajectory passes through numbers of unbounded bit-length; at every such number, the same inseparable coupling applies. For \(x \geq 5\), per-pair determination fails (Theorem 5.3), and the above coupling is not guaranteed.</p>

<p><b>Conclusion.</b> G-dominance requires \((1,1)\)-pairs; \((1,1)\)-pairs unconditionally generate carry; carry eliminates the leftmost G-block's leading position and destroys the P-bridges connecting G-blocks. G-blocks are consumed left-to-right within this closed algebraic structure, at every scale. No configuration within this closed system can maintain G-dominance indefinitely. &square;</p>

<div class="theorem">
<span class="theorem-title">Remark 5.5 (Structural impossibility of divergence).</span> Sustained trajectory growth requires \(d = 1\) at most steps (since \(\log_2 3 \approx 1.585\) bits are added and \(d\) bits removed per step). By Lemma 5.8, \(d = 1\) requires pair 0 to be G(1,1). Pair 0, as the leftmost pair, is always in or to the left of the leftmost G-block. By Lemma 5.1(b), the leftmost G-block's leading G is eliminated at each scan step; by Lemma 5.6, its net length change is \(\leq 0\). The leftmost G-block containing pair 0 is therefore consumed in finite time, after which pair 0 is no longer G and \(d \geq 2\). New G-blocks created by P\(\to\)G transitions (Lemma 5.3) or by re-pairing (Table 5.2) also enter the left-to-right consumption process (Proposition 5.4, dimensional separation and re-pairing pathway containment). Therefore, the condition required for sustained growth (\(d = 1\) indefinitely) is structurally unattainable.
<p>Corollary 5.3 provides an independent confirmation: \(L\) consecutive \(d = 1\) steps require \(n \equiv 2^{L+1} - 1 \pmod{2^{L+1}}\), bounding the maximum streak by \(\lfloor \log_2 n \rfloor\). This arithmetic constraint, derived purely from modular arithmetic, is entirely independent of the GPK analysis yet yields the same conclusion.</p>
<p>This is not a probabilistic argument. Each step in the chain&mdash;\(d = 1 \Leftrightarrow\) pair 0 = G (Lemma 5.8), leftmost G-block consumption (Lemma 5.1(b)), bridge destruction (Lemma 5.1(c)), P\(\to\)G bounded generation (Lemma 5.3), non-mergeability (Lemma 5.5)&mdash;is a deterministic consequence of the 16-pattern exhaustive case analysis, derived from the algebraic identity \(3n+1 = 2n + n + 1\). The arithmetic bound of Corollary 5.3 serves as a cross-verification from an entirely different method.</p>
</div>

<div class="theorem">
<span class="theorem-title">Remark 5.6 (P\(\to\)G feedback containment).</span> The P\(\to\)G transitions (Cases 5, 10, 11) can temporarily increase the G-count in one step (e.g., \(n = 10495\): G-ratio 50% \(\to\) 71%). This fluctuation is structurally contained: (i) all newly created G-blocks enter the left-to-right consumption process (Lemma 5.1(b), 5.7); (ii) P\(\to\)G generation consumes P-positions, reducing the fuel for future P\(\to\)G; (iii) G-blocks cannot merge (Lemma 5.5), preventing accumulation; (iv) the same inseparable coupling (Proposition 5.4) applies to every new G-block at every scale. Bounded fluctuations within a closed, scale-invariant system do not constitute divergence.
</div>

<div class="theorem">
<span class="theorem-title">Remark 5.7 (Contrast with \(x \geq 5\)).</span> For \(x \geq 5\), the m4-stage GPK is not per-pair determined (Theorem 5.3). The DFST state space grows exponentially with the shift parameter \(s = \log_2(x-1)\): the reference distance spans \(\lfloor s/2 \rfloor\) pairs, requiring tracking of distant pair information. This enlarged state space admits configurations where carry structure depends on inter-pair correlations that escape the structural constraints of Lemmas 5.1&ndash;5.8. This is consistent with the known existence of non-trivial cycles for \(5n+1\) [2]: the carry structure of \(5n+1\) admits stable configurations that the 2-bit observation space cannot resolve or constrain.
</div>

<h2>5.8 Numerical Verification</h2>

<p><b>Verification of Theorem B.</b> For the 50 odd numbers \(n = 1, 3, 5, \ldots, 99\) and large values \(n = 127, 255, 511, 1023, 4095, 8191, 65535, 99991, 999999\), the coincidence of the m4-stage \(G_{\text{out}}[i]\) with \(\text{m2}(n)_i\), and \(P_{\text{out}}[i]\) with \(\text{m7}(n)_i\) for \(3n+1\) was verified computationally. Full agreement for all numbers.</p>

<p><b>Verification of Theorem C.</b> In addition to the exhaustive 784-way matching for \(n = 31\), the same matching was performed for \(n = 7, 13, 19, 27, 43, 83\). For \(n = 27, 43\), some predicate combinations coincidentally match (due to the arrangement of pair values), but for \(n = 31\), complete non-coincidence holds. Theorem C is an existence statement; a single counterexample suffices.</p>

<h2>5.9 Summary of This Section</h2>

<p>1. <b>Theorem B (5.1):</b> The m4-stage GPK of \(3n+1\) coincides with m2(AND)/m7(XOR)/m9(NOR) of \(n\). Reading the pair type of \(n\) determines carry generation, propagation, and absorption.</p>

<p>2. <b>Theorem C (5.2):</b> For \(x \geq 5\), the m4-stage GPK is not 16-predicate representable. The per-pair independence barrier makes inter-pair correlations inherently inexpressible. Supplemented by exhaustive 784-way verification for \(n=31\).</p>

<p>3. <b>Classification Theorem (5.3):</b> m4-stage GPK closes within intra-pair predicates only for \(x=3\). The map \(3n+1\) is the unique Collatz-type map whose carry structure is "transparent" in the 16-predicate space.</p>

<!-- ============ SECTION 6 ============ -->
<div class="page-break"></div>
<h1>6. Division by 2 as Exchange</h1>

<p>After computing \(xn+1\), repeated division by 2 is required to reach the next odd number. This section shows that this operation is described as a role exchange between m4 and m6 within our framework.</p>

<h2>6.1 Trailing Zeros and 2-adic Valuation</h2>

<div class="theorem">
<span class="theorem-title">Definition 6.1.</span> The 2-adic valuation \(v_2(m)\) of a positive integer \(m\) is the exponent of the largest power of 2 dividing \(m\):
$$v_2(m) = \max\{d \in \mathbb{N} : 2^d \mid m\}$$
In binary, \(v_2(m)\) equals the number of trailing zeros.
</div>

<p>Setting \(d = v_2(xn+1)\), the next odd number is \(n' = (xn+1)/2^d\).</p>

<h2>6.2 Bit-Level Operation of \(\div 2\)</h2>

<p>In binary, \(m/2\) removes the least significant bit (a right shift by 1). When \(m\) is even, the LSB is 0 and no information is lost. Dividing by \(2^d\) removes \(d\) trailing zero bits&mdash;all carrying zero information.</p>

<div class="theorem">
<span class="theorem-title">Proposition 6.1.</span> The binary representation of \(m/2^d\) (where \(2^d \mid m\)) is obtained by removing the \(d\) trailing zeros from the binary representation of \(m\). No information is lost.
</div>

<h2>6.3 Effect on Pair Structure</h2>

<p>Consider the conversion from the pair representation of \(m = xn+1\) to that of \(n' = m/2^d\).</p>

<p>Let the binary representation of \(m\) be \(\hat{\beta}(m) = s_1 s_2 \cdots s_{2l}\) (even-digit padded). Since the trailing \(d\) bits are all zeros:</p>

$$
\hat{\beta}(m) = s_1 s_2 \cdots s_{2l-d} \underbrace{0 \cdots 0}_{d}
$$

<p>Removing the trailing \(d\) bits yields the bit string of \(m/2^d\):</p>

$$
\beta(m/2^d) = s_1 s_2 \cdots s_{2l-d}
$$

<p>This string is then even-digit padded and grouped into pairs. <b>The parity of \(d\) determines how pair boundaries shift.</b></p>

<p><b>When \(d\) is even:</b> Removing \(d = 2q\) bits removes \(q\) complete pairs. Pair boundaries are preserved. The remaining pair sequence coincides with the first \(l-q\) pairs of \(m\).</p>

$$
P(m/2^d) = ((s_1, s_2), (s_3, s_4), \ldots, (s_{2l-d-1}, s_{2l-d}))
$$

<p>The m4/m6 correspondence is maintained.</p>

<p><b>When \(d\) is odd:</b> Removing \(d = 2q+1\) bits removes \(q\) pairs plus 1 bit. The remaining bit string has odd length, requiring a leading-zero pad:</p>

$$
\hat{\beta}(m/2^d) = 0\, s_1\, s_2\, \cdots\, s_{2l-d}
$$

<p>The padding causes the original pair \((s_1, s_2)\) to be regrouped as \((0, s_1)\) and \((s_2, s_3)\). <b>This corresponds to swapping the roles of m4 and m6.</b></p>

<h2>6.4 The m4&harr;m6 Exchange Theorem</h2>

<div class="theorem">
<span class="theorem-title">Theorem 6.1 (Exchange principle of \(\div 2\)).</span> In the conversion from the pair sequence of \(m\) to that of \(m/2^d\):

<ul>
<li>When \(d\) is even: the m4/m6 correspondence is <b>maintained</b>.</li>
<li>When \(d\) is odd: the m4/m6 correspondence is <b>exchanged</b>.</li>
</ul>

<p>More precisely, letting the MSB-side pair sequence of \(m\) be \((\alpha_0, \beta_0), (\alpha_1, \beta_1), \ldots\), the re-pairing after removing the trailing \(d\) bits gives:</p>

$$
d \text{ even}: \quad \text{m4}(n')_j = \alpha_j, \quad \text{m6}(n')_j = \beta_j
$$
$$
d \text{ odd}: \quad \text{m4}(n')_j \sim \beta_j, \quad \text{m6}(n')_j \sim \alpha_{j+1}
$$

<p>where \(\sim\) denotes correspondence up to padding and boundary effects.</p>

<div class="derivation"><i>Derivation.</i> When \(d\) is even, the \(d\) removed bits constitute an even number of pairs, preserving pair boundaries. When \(d\) is odd, the remaining bit string has odd length; the leading-zero padding shifts all bits by one position within their pairs. Bits formerly in left positions move to right positions and vice versa.</div>
</div>

<h2>6.5 Worked Examples</h2>

<p><b>Example 6.1 (\(d=3\), odd: exchange).</b> \(5 \times 27 + 1 = 136 = 10001000_2\). Pairs: \(((1,0),(0,0),(1,0),(0,0))\). m4 \(= (1,0,1,0)\), m6 \(= (0,0,0,0)\).</p>

<p>\(v_2(136) = 3\). \(136/8 = 17 = 10001_2\). Padded: \(010001\). Pairs: \(((0,1),(0,0),(0,1))\). m4' \(= (0,0,0)\), m6' \(= (1,0,1)\).</p>

<p>\(d=3\) (odd) &rarr; exchange occurs. The non-zero pattern of m4 of 136 corresponds to m6' of 17.</p>

<p><b>Example 6.2 (\(d=1\), odd: exchange).</b> \(3 \times 27 + 1 = 82 = 01010010_2\). Pairs: \(((0,1),(0,1),(0,0),(1,0))\). m4 \(= (0,0,0,1)\), m6 \(= (1,1,0,0)\).</p>

<p>\(v_2(82) = 1\). \(82/2 = 41 = 101001_2\). Pairs: \(((1,0),(1,0),(0,1))\). m4' \(= (1,1,0)\), m6' \(= (0,0,1)\).</p>

<p>\(d=1\) (odd) &rarr; exchange.</p>

<p><b>Example 6.3 (\(d=2\), even: maintained).</b> \(n = 7 = 111_2\). Even-digit padding: \(0111_2\). Pairs: \(((0,1),(1,1))\). m4 \(= (0,1)\), m6 \(= (1,1)\).</p>

<p>\(5 \times 7 + 1 = 36 = 100100_2\). Pairs: \(((1,0),(0,1),(0,0))\).</p>

<p>\(v_2(36) = 2\) (even). Division process:</p>
<pre>
36 &divide; 2 = 18    (100100 &rarr; 10010)    &larr; pair boundaries shift by 1 bit
18 &divide; 2 = 9     (10010 &rarr; 1001)      &larr; pair boundaries return to original
</pre>

<p>\(n' = 9 = 1001_2\). Pairs: \(((1,0),(0,1))\). m4' \(= (1,0)\), m6' \(= (0,1)\).</p>

<p>\(d=2\) (even) &rarr; two right shifts restore pair boundaries to original positions. m4 remains m4, m6 remains m6. <b>No exchange.</b></p>

<table>
<tr><th>Item</th><th>Example 6.1 (\(n=27\))</th><th>Example 6.3 (\(n=7\))</th></tr>
<tr><td>\(5n+1\)</td><td>136</td><td>36</td></tr>
<tr><td>\(d\)</td><td>3 (odd)</td><td>2 (even)</td></tr>
<tr><td>Pair boundary</td><td>shifted</td><td>restored</td></tr>
<tr><td>m4&harr;m6</td><td><b>Exchanged</b></td><td><b>Maintained</b></td></tr>
</table>

<h2>6.6 Information Preservation Principle</h2>

<div class="theorem">
<span class="theorem-title">Proposition 6.2.</span> In one step \(T(n) = (xn+1)/2^d\) of a Collatz-type map, the bit information of the input \(n\) is transformed as follows:

<p>1. <b>Pair addition</b> (&sect;3&ndash;4): New m4/m6 are generated via bit references and carry propagation. The bit count increases by at most a constant.</p>
<p>2. <b>Trailing-zero removal</b>: Bits carrying zero information are removed. No information is lost.</p>
<p>3. <b>Re-pairing</b>: Depending on the parity of \(d\), the m4&harr;m6 correspondence is maintained or exchanged.</p>
</div>

<p>In particular, \(\div 2\) is <b>positional relocation</b> of information (swapping left/right roles within pairs), not <b>destruction</b> of information.</p>

<p><b>Remark 6.1.</b> The increase and decrease of digit count is directly related to convergence/divergence of the map. The result \(xn+1\) is larger than \(n\) (bit count may increase), but \(\div 2^d\) reduces the bit count. If \(d\) is sufficiently large, the digit count decreases and the trajectory "shrinks." The balance of this digit-count variation is the core of the Collatz conjecture, but this paper does not address this question.</p>

<h2>6.7 The Map \(T\) in m4/m6 Representation</h2>

<p>Integrating the above, the odd-to-odd map \(T: n \mapsto n'\) is described as a transformation on (m4, m6) space:</p>

$$
T: (\text{m4}(n),\, \text{m6}(n)) \;\longrightarrow\; (\text{m4}(n'),\, \text{m6}(n'))
$$

<p>This transformation consists of three phases:</p>

<p><b>Phase 1 (Pair addition):</b></p>
$$
(\text{m4}(n),\, \text{m6}(n)) \;\xrightarrow{\text{reference + carry scan}}\; (\text{m4}(xn\!+\!1),\, \text{m6}(xn\!+\!1))
$$

<p><b>Phase 2 (Tail removal):</b></p>
$$
(\text{m4}(xn\!+\!1),\, \text{m6}(xn\!+\!1)) \;\xrightarrow{\text{remove trailing zero-pairs}}\; \text{shortened pair sequence}
$$

<p><b>Phase 3 (Exchange decision):</b></p>
$$
\text{shortened pair sequence} \;\xrightarrow{d \bmod 2}\; \begin{cases} (\text{m4}',\, \text{m6}') & d \text{ even: maintained} \\ (\text{m6}',\, \text{m4}') & d \text{ odd: exchanged} \end{cases}
$$

<h2>6.8 Determination of \(d\)</h2>

<p>The trailing-zero count \(d\) can also be read directly from the pair addition result.</p>

<div class="theorem">
<span class="theorem-title">Proposition 6.3.</span> In the pair addition result (LSB order), \(d\) equals the number of trailing zero bits. Counting \(q\) consecutive \((0,0)\) pairs from the LSB, then checking the right bit of the next pair: if it is 0, then \(d = 2q + 1\); if it is 1, then \(d = 2q\).
</div>

<h2>6.9 Summary of This Section</h2>

<p>1. Repeated division by 2 removes trailing zero bits (carrying zero information); no information is lost.</p>

<p>2. Re-pairing after removal: the parity of \(d\) determines whether the m4/m6 correspondence is maintained (even) or exchanged (odd).</p>

<p>3. The map \(T: n \mapsto n'\) is described as a closed three-phase transformation on (m4, m6) space: pair addition &rarr; tail removal &rarr; exchange decision.</p>

<p>4. The value of \(d\) itself is readable directly from the pair addition result, requiring no additional computation.</p>

<!-- ============ SECTION 7 ============ -->
<div class="page-break"></div>
<h1>7. Methodological Note</h1>

<p>An earlier version of this paper included numerical trajectory data as an appendix, with GPK statistics computed across Collatz trajectories. The verification tool employed a stopping-time algorithm&mdash;the standard optimisation in which the trajectory of \(n\) is terminated once \(T^k(n) < n\), on the grounds that all smaller integers have already been verified for convergence. While this early termination is correct for convergence verification, it truncates the trajectory before reaching 1, and the GPK distribution statistics collected from such truncated trajectories carry a systematic bias: the tail segment of the trajectory (from the stopping-time threshold down to 1) is absent, distorting the measured G/P/K ratios. This error was identified during the process of improving the verification tool.</p>

<p>In the course of re-examining the numerical results, it became clear that no numerical data is required. Every claim in this paper&mdash;the per-pair determination of the m4-stage GPK (Theorem 5.1), the uniqueness of \(x = 3\) (Theorem 5.3), the self-annihilation of G-dominance (Proposition 5.4), and the structural impossibility of divergence (Remark 5.5)&mdash;follows from the algebraic identity \(3n+1 = 2n + n + 1\) and the closure of the GPK operator space.</p>

<p>These are not finite verifications extrapolated to general claims. The identity \(3n+1 = 2n + n + 1\) holds simultaneously for all \(n \in \mathbb{N}\) by algebraic necessity. The per-pair determination derived from this identity (Theorem 5.1) is therefore not a pattern observed in data but a structural property that admits no exceptions at any scale. The scale-invariance argument of Proposition 5.4 requires no numerical support: it follows from the fact that the per-pair determination is an established algebraic identity, not a finite verification. For this reason, the numerical appendix has been removed entirely.</p>

<p>In this revised version (v2), the derivation of Proposition 5.4 has been strengthened by the complete enumeration of two finite transition tables: the 16-pattern scan transition table (Table 5.1) and the 16-pattern re-pairing transition table (Table 5.2). These tables exhaustively cover every possible input state of the \(3n+1\) scan and every adjacent-pair combination under re-pairing. Lemmas 5.1&ndash;5.8 are logical consequences of these tables, derived by inspection of the 16 + 16 cases. The GPK classification itself&mdash;Generate, Propagate, Kill&mdash;is the standard technique for carry behavior classification in carry-lookahead adders, with over half a century of history [6, 7, 8]. Our contribution is not the GPK framework, but its application to Collatz-type maps and the discovery that for \(x = 3\), the inseparable coupling between activation condition and activation result is verifiable by exhaustive finite case analysis.</p>


<!-- ============ SECTION 8 ============ -->
<div class="page-break"></div>
<h1>8. Cycle Analysis via m4/m6</h1>

<p>As an application of the unified algorithm, we analyze the known cycles of \(5n+1\) in m4/m6 space. We draw structural comparisons with \(3n+1\) and demonstrate the perspective that m4/m6 representation provides for cycle research.</p>

<h2>8.1 Known Cycles of \(5n+1\)</h2>

<p>The following non-trivial cycles of \(5n+1\) are known [2]:</p>

<p><b>Cycle A (2 elements):</b> \(1 \to 3 \to 1\)</p>
<p><b>Cycle B (3 elements):</b> \(13 \to 33 \to 83 \to 13\)</p>
<p><b>Cycle C (3 elements):</b> \(27 \to 17 \to 43 \to 27\)</p>

<h2>8.2 m4/m6 Trajectory of Cycle A</h2>

<table>
<tr><th>Step</th><th>\(n\)</th><th>Binary</th><th>m4</th><th>m6</th><th>\(5n+1\)</th><th>\(d\)</th><th>Exchange</th></tr>
<tr><td>0</td><td>1</td><td>01</td><td>(0)</td><td>(1)</td><td>6</td><td>1</td><td>&#8644;</td></tr>
<tr><td>1</td><td>3</td><td>11</td><td>(1)</td><td>(1)</td><td>16</td><td>4</td><td>&mdash;</td></tr>
<tr><td>&rarr;</td><td>1</td><td>01</td><td>(0)</td><td>(1)</td><td></td><td></td><td></td></tr>
</table>

<p><b>Observation.</b> m6 is fixed at \((1)\) throughout. Only m4 oscillates \(0 \to 1 \to 0\). The values of \(d\) alternate between 1 and 4, and exchange occurs every other step.</p>

<h2>8.3 m4/m6 Trajectory of Cycle B</h2>

<table>
<tr><th>Step</th><th>\(n\)</th><th>Binary</th><th>m4</th><th>m6</th><th>\(5n+1\)</th><th>\(d\)</th><th>Exchange</th></tr>
<tr><td>0</td><td>13</td><td>1101</td><td>(1,0)</td><td>(1,1)</td><td>66</td><td>1</td><td>&#8644;</td></tr>
<tr><td>1</td><td>33</td><td>100001</td><td>(1,0,0)</td><td>(0,0,1)</td><td>166</td><td>1</td><td>&#8644;</td></tr>
<tr><td>2</td><td>83</td><td>01010011</td><td>(0,0,0,1)</td><td>(1,1,0,1)</td><td>416</td><td>5</td><td>&#8644;</td></tr>
<tr><td>&rarr;</td><td>13</td><td>1101</td><td>(1,0)</td><td>(1,1)</td><td></td><td></td><td></td></tr>
</table>

<p><b>Observation.</b> The pair count varies as \(2 \to 3 \to 4 \to 2\). From 13 to 33, the pair count increases; the large \(d=5\) at \(83 \to 13\) sharply reduces it back. All values of \(d\) are odd, causing m4&harr;m6 exchange at every step.</p>

<h2>8.4 m4/m6 Trajectory of Cycle C</h2>

<table>
<tr><th>Step</th><th>\(n\)</th><th>Binary</th><th>m4</th><th>m6</th><th>\(5n+1\)</th><th>\(d\)</th><th>Exchange</th></tr>
<tr><td>0</td><td>27</td><td>011011</td><td>(0,1,1)</td><td>(1,0,1)</td><td>136</td><td>3</td><td>&#8644;</td></tr>
<tr><td>1</td><td>17</td><td>010001</td><td>(0,0,0)</td><td>(1,0,1)</td><td>86</td><td>1</td><td>&#8644;</td></tr>
<tr><td>2</td><td>43</td><td>101011</td><td>(1,0,1)</td><td>(0,1,1)</td><td>216</td><td>3</td><td>&#8644;</td></tr>
<tr><td>&rarr;</td><td>27</td><td>011011</td><td>(0,1,1)</td><td>(1,0,1)</td><td></td><td></td><td></td></tr>
</table>

<p><b>Observation.</b> The pair count remains fixed at \(k=3\) throughout. The values of \(d\) alternate as 3, 1, 3, with exchange at every step.</p>

<p>A notable feature: m4(27) \(= (0,1,1)\) equals m6(43) \(= (0,1,1)\), and m6(27) \(= (1,0,1)\) equals m4(43) \(= (1,0,1)\). That is, 27 and 43 have their m4 and m6 completely swapped.</p>

<h2>8.5 Structural Features Common to the Cycles</h2>

<p><b>(1) Periodicity of exchange.</b> In all three cycles, steps with odd \(d\) appear, triggering m4&harr;m6 exchange. In Cycles B and C, exchange occurs at every step.</p>

<p><b>(2) Pair-count variation patterns.</b> Cycle C has fixed pair count (\(k=3\)); Cycle B has variable pair count (\(k = 2 \to 3 \to 4 \to 2\)). In variable-count cycles, a "compression step" with large \(d\) (e.g., \(d=5\) in Cycle B) sharply reduces the pair count.</p>

<p><b>(3) m4/m6 symmetry.</b> As seen with 27 and 43 in Cycle C, elements within a cycle may exhibit a symmetric relationship where m4 and m6 are interchanged. This is a structural consequence of accumulated exchange operations.</p>

<h2>8.6 Comparison with the \(3n+1\) Cycle</h2>

<p>The only known cycle of \(3n+1\) is the trivial cycle \(1 \to 1\) (\(3 \times 1 + 1 = 4\), \(d=2\)). The Collatz conjecture asserts this is the unique cycle.</p>

<table>
<tr><th></th><th>\(n\)</th><th>m4</th><th>m6</th><th>\(3n+1\)</th><th>\(d\)</th><th>Exchange</th><th>\(n'\)</th></tr>
<tr><td></td><td>1</td><td>(0)</td><td>(1)</td><td>4</td><td>2</td><td>&mdash;</td><td>1</td></tr>
</table>

<p>\(d=2\) (even), so no exchange occurs. m4 \(= (0)\) and m6 \(= (1)\) form a fixed point.</p>

<p><b>Structural comparison:</b></p>
<ul>
<li>5n+1: Multiple cycles, variable pair counts, frequent m4&harr;m6 exchange.</li>
<li>3n+1: Unique cycle (conjectured), \(d=2\) fixed point, no exchange.</li>
</ul>

<p>The fact that the trivial cycle of \(3n+1\) is a fixed point in m4/m6 space is consistent with the "structural privilege" of &sect;5. That m4-stage GPK can be read directly as m2/m7 (Theorem 5.1) means the map transforms the pair structure of \(n\) "transparently," providing a structural reason why complex cycles may be difficult to form.</p>

<h2>8.7 Observation Resolution: Why 5n+1 Admits Cycles</h2>

<p>The structural difference between \(3n+1\) and \(5n+1\) can be reformulated as a question of <i>observation resolution</i>. For a Collatz-type map with parameter \(x = 2^s + 1\), the multiplication \(xn + 1\) involves a shift of \(s\) bits. The m4-stage carry at pair position \(i\) depends on the input at positions within distance \(\lfloor s/2 \rfloor\) pairs. We say that the carry structure <i>closes at resolution \(w\)</i> if a window of \(w\) bits suffices to determine the carry classification at each position from the input alone.</p>

<p>For \(3n+1\) (\(s = 1\)), the shift is 1 bit, which is less than the pair width of 2 bits. The m4-stage inputs at each pair position are \((b_i, a_i)\)&mdash;both bits from the same pair (Proposition 3.4). The carry classification is therefore per-pair determined: it closes at resolution 2. This is the content of Theorem 5.1.</p>

<p>For \(5n+1\) (\(s = 2\)), the shift equals the pair width. The m4-stage inputs become \((a_{i-1}, a_i)\), spanning two adjacent pairs (Proposition 3.3). The carry classification depends on inter-pair correlations that the 2-bit observation space cannot express (Theorem 5.2). The structural closure fails, and the GPK system does not constrain trajectory behavior in the same way.</p>

<p>This suggests a geometric condition for closure: <b>the carry structure of \(xn+1\) closes at 2-bit resolution if and only if the shift \(s\) is strictly less than the pair width</b>. For \(s \geq 2\), a wider observation window may restore closure. The conjectured minimum resolutions are:</p>

<table>
<tr><th>Parameter \(x\)</th><th>Shift \(s\)</th><th>Minimum window (conjectured)</th><th>Status</th></tr>
<tr><td>3</td><td>1</td><td>2 bits</td><td><b>Closed</b> (Theorem 5.1)</td></tr>
<tr><td>5</td><td>2</td><td>4 bits?</td><td>Open</td></tr>
<tr><td>9</td><td>3</td><td>6 bits?</td><td>Open</td></tr>
<tr><td>\(2^s + 1\)</td><td>\(s\)</td><td>\(2s\) bits?</td><td>Open</td></tr>
</table>

<p>The existence of non-trivial cycles for \(5n+1\) (Cycles B and C above) is consistent with this picture: the 2-bit observation space lacks the resolution to capture the carry mechanism that would constrain trajectories. Whether a 4-bit observation space provides structural closure for \(5n+1\)&mdash;and whether the known cycles become structurally visible within that space&mdash;is the central open question connecting cycle analysis to the observation framework.</p>

<h2>8.8 Formulation of Cycle Conditions</h2>

<div class="theorem">
<span class="theorem-title">Definition 8.1.</span> A sequence of odd numbers \(n_0, n_1, \ldots, n_{p-1}\) forms a cycle of period \(p\) if \(T(n_i) = n_{i+1 \bmod p}\) holds for all \(i\).
</div>

<p>In m4/m6 space, this translates to the following conditions.</p>

<div class="theorem">
<span class="theorem-title">Proposition 8.1 (m4/m6 cycle conditions).</span> Necessary conditions for \(\{n_0, \ldots, n_{p-1}\}\) to form a cycle of \(5n+1\):

<p><b>(i) Pair-count condition:</b> \(\sum_{i=0}^{p-1} (\delta_i - d_i) = 0\), where \(\delta_i\) is the bit increase from addition at step \(i\) and \(d_i\) is the trailing-zero count. The cycle returns to its starting bit length.</p>

<p><b>(ii) Exchange condition:</b> The total \(d\)-sum must be such that after \(p\) steps, the m4/m6 correspondence returns to its original state.</p>

<p><b>(iii) Bit-pattern condition:</b> Composing \(p\) steps of the scan must reproduce the original m4/m6 pattern.</p>
</div>

<p>Conditions (i) and (ii) follow from the definition of cycles and the exchange principle of &sect;6. Condition (iii) is the explicit composition of scans; its closed-form description is a topic for future work.</p>

<p><b>Verification.</b> Cycle C (\(27 \to 17 \to 43 \to 27\)): \(d = (3, 1, 3)\). \(\sum d_i = 7\) (odd), which appears to violate condition (ii).</p>

<p>However, bit removal such as \(d=3\) involves re-arrangement of pair boundaries, and the determination of exchange depends not on the simple sum of \(d \bmod 2\) but on the consistency of the entire bit string at each step. Condition (ii) requires a more precise formulation that accounts for boundary shifts during re-pairing. This refinement is left for future work.</p>

<h2>8.9 Summary of This Section</h2>

<p>1. The three known cycles of \(5n+1\) have been completely described in m4/m6 space, including the m4/m6 transitions, GPK classifications, \(d\) values, and exchange occurrences at each step.</p>

<p>2. Common structural features have been extracted: periodicity of exchange, pair-count variation patterns, and m4/m6 symmetric relationships between cycle elements.</p>

<p>3. The trivial cycle of \(3n+1\) (\(n=1\)) has been confirmed as a fixed point in m4/m6 space, and structural comparisons with \(5n+1\) have been drawn.</p>

<p>4. The structural difference between \(3n+1\) and \(5n+1\) has been reformulated as observation resolution: 2-bit resolution suffices for \(3n+1\) (shift \(s=1 < 2\)) but not for \(5n+1\) (shift \(s=2\)). Whether higher-resolution windows restore closure for \(x \geq 5\) is an open question (&sect;8.7).</p>

<p>5. Cycle conditions in m4/m6 space have been formulated. While refinement remains for future work, the pair-count and exchange conditions provide necessary conditions.</p>

<!-- ============ SECTION 9 ============ -->
<div class="page-break"></div>
<h1>9. Discussion</h1>

<h2>9.1 Relation to Prior Work</h2>

<p><b>Relation to the Syracuse function.</b> The Syracuse function \(T(n) = (3n+1)/2^{v_2(3n+1)}\) [1] elides even steps and defines the odd-to-odd map in a single expression. However, it does not penetrate the internal structure of \(3n+1\), and the value of \(v_2\) can only be known after computation. Our m4/m6 scan yields the same result as \(T(n)\), but in the process obtains the carry structure (GPK classification) of each pair as a by-product. The Syracuse function is a <i>definition</i> of the map; the m4/m6 scan is a <i>decomposition</i> of the map.</p>

<p><b>Relation to binary analysis.</b> Binary-based analysis of Collatz maps by Wirsching [3] and Lagarias [1] treats \(3n+1\) as \(2n + n + 1\) and tracks bit-string changes. Our approach extends this direction but differs in the following respects:</p>

<ul>
<li>Decomposition into 2-bit pairs and the introduction of the 16-predicate system uses the <i>pair type</i> (4 kinds) rather than individual bits as the basic unit. This allows carry behavior to be described as a function of pair type.</li>
<li>The choice of the m4/m6 basis ensures that the map is described as a closed transformation on (m4, m6) space.</li>
<li>The completeness and per-pair independence of the 16 predicates provides tools for establishing both positive results (Theorem 5.1) and negative results (Theorem 5.2): "what is expressible and what is not."</li>
</ul>

<p><b>Relation to carry-lookahead adders.</b> The GPK decomposition of &sect;4 is based on the same principle as carry-lookahead technology introduced by Bedrij [6]. Our contribution is to connect this technology to the carry structure of Collatz-type maps and to show that the GPK classification is interpretable as pair predicates (specifically m2/m7). This bridges a standard technique from computer science to a problem in number theory.</p>

<h2>9.2 Novelty of This Paper</h2>

<p><b>(1) The m4/m6 pair-projection framework.</b> We decomposed natural numbers into 2-bit pairs and defined a predicate system with m4/m6 as basis. We established completeness of the 16 predicates, reconstruction from the basis, and per-pair independence.</p>

<p><b>(2) Decomposition of \(xn+1\) into bit scanning.</b> We showed that the odd-to-odd transition of \(xn+1\) is computable by an m4/m6 bit scan. The multiplication \(xn\) is decomposed into the shift of \((x-1)n\) as reference index offsets; the scan stage involves only intra-pair 1-bit additions.</p>

<p><b>(3) Derivation of the structural privilege of \(3n+1\).</b> We established that for \(x=3\), the m4-stage GPK coincides with m2/m7 (Theorem 5.1), and that for \(x \geq 5\), this coincidence is impossible in principle (Theorem 5.2). The Classification Theorem (5.3) shows that \(x=3\) is the unique parameter for which the m4-stage carry structure closes within the 16-predicate space. This m4-stage closure enables the complete scan dynamics to be captured by a 16-pattern finite-state transducer whose input alphabet is derived from the predicate pair types.</p>

<p><b>(4) Exchange principle of \(\div 2\).</b> We showed that the \(\div 2\) operation is described as an m4&harr;m6 role exchange (Theorem 6.1).</p>

<p><b>(5) Unified algorithm.</b> We formulated an algorithm that accommodates arbitrary \(xn+1\) by swapping only the reference pattern (Algorithm 7.1).</p>

<h2>9.3 Computational Verification</h2>

<p>Using our implementation of Algorithm 7.1, we measured GPK distributions for \(x=3, 5, 17\) under uniform conditions. For each odd \(n \leq 10^7\), the stopping-time method (iteration until \(n' < n\), maximum 500 steps) was applied, aggregating GPK over all steps. The results are shown in Table 9.1.</p>

<p><b>Methodological note.</b> The stopping-time method terminates each trajectory upon reaching a value below the starting point. This systematically truncates the descent phase&mdash;where G-dominance has already been depleted&mdash;and may overestimate G-ratios in the collected statistics. The values in Table 9.1 should therefore be read as qualitative illustrations of inter-\(x\) structural differences, not as precise measurements of steady-state GPK distributions. The structural arguments of &sect;5.7, which derive all conclusions from finite case analysis of Tables 5.1 and 5.2, do not depend on these numerical values.</p>

<p><b>Table 9.1.</b> GPK distribution comparison for Collatz-type maps \(T(n)=(xn+1)/2^d\) (\(n \leq 10^7\), max_steps = 500).</p>

<table>
<tr><th></th><th>\(3n+1\) (\(s=1\))</th><th>\(5n+1\) (\(s=2\))</th><th>\(17n+1\) (\(s=4\))</th></tr>
<tr><td>Odd numbers verified</td><td>4,999,999</td><td>4,999,999</td><td>4,999,999</td></tr>
<tr><td>All converge</td><td><b>Yes</b></td><td>No</td><td>No</td></tr>
<tr><td>Max stopping time</td><td>155</td><td>490</td><td>18</td></tr>
<tr><td>Avg steps/number</td><td>3.5</td><td>179</td><td>456</td></tr>
<tr><td>G (Generate) %</td><td><b>38.41</b></td><td>36.91</td><td>37.26</td></tr>
<tr><td>P (Propagate) %</td><td><b>28.32</b></td><td>25.45</td><td>25.09</td></tr>
<tr><td>K (Kill) %</td><td><b>33.26</b></td><td>37.64</td><td>37.65</td></tr>
<tr><td>\(G/K\) ratio</td><td><b>1.15</b></td><td>0.98</td><td>0.99</td></tr>
<tr><td>Max carry chain length</td><td>19</td><td>61</td><td>74</td></tr>
</table>

<p><b>Observation 1: \(G/K\) asymmetry is unique to \(x=3\).</b> For \(x=3\), \(G/K \approx 1.15\) is clearly asymmetric, whereas for \(x=5\) and \(x=17\), \(G/K \approx 0.98\)&ndash;\(0.99\) is nearly symmetric. By Theorem B, the GPK for \(x=3\) coincides with the intra-pair predicates of \(n\) (\(G = \text{m2}\), \(P = \text{m7}\), \(K = \text{m9}\)), so the bias in bit patterns of odd numbers is directly reflected in the GPK distribution. For \(x \geq 5\), GPK depends on inter-pair correlations (Theorem C), mixing the input structure and homogenizing toward \(G \approx K\).</p>

<p><b>Observation 2: \(P \approx 25\%\) is common for \(x \geq 5\).</b> For \(x=5\), \(P = 25.45\%\); for \(x=17\), \(P = 25.09\%\)&mdash;both near \(1/4\). This is not coincidental. For \(x \geq 5\), Propagate in the serial composition of m4-stage and m6-stage arises independently: \(P \approx P_{\text{m4}} \cdot P_{\text{m6}} \approx 1/2 \times 1/2 = 1/4\). For \(x=3\), \(P = 28.32\%\) is higher because the m4-stage input is the pair itself \((b_i, a_i)\), creating correlation with the m6-stage.</p>

<p><b>Observation 3: Carry chain length increases with \(s\).</b> Maximum carry chain length is 19 for \(x=3\) (\(s=1\)), 61 for \(x=5\) (\(s=2\)), and 74 for \(x=17\) (\(s=4\)). For \(x=3\), GPK is determined by intra-pair predicates, so Kill occurrences correspond directly to the input bit pattern, keeping chains short. For \(x \geq 5\), carry structure diffuses across pairs, and Kill occurrences decouple from input structure, allowing longer Propagate chains.</p>

<h2>9.4 Limitations of This Paper</h2>

<p>Limitations that should be stated frankly:</p>

<p><b>(1) Divergence vs. convergence.</b> Proposition 5.4, supported by Lemmas 5.1&ndash;5.8 derived from the exhaustive 16 + 16 case analysis (Tables 5.1 and 5.2), establishes that G-dominance self-annihilates through the inseparable coupling of activation condition and activation result within the closed GPK system. The one-step map decomposes into four phases (scan, \(d\)-determination, trailing zero removal, re-pairing), each structurally closed within the same four pair types, as confirmed by the complete enumeration of Tables 5.1 and 5.2. The DFST permutation property (&sect;5.7.1) further shows that the scan preserves the multiplicity of pair types across DFST states, and the expected division exponent under uniform distribution is \(E[d] = 2 > \log_2 3\), giving net contraction (&sect;5.7.5). However, the structural impossibility of divergence does not by itself establish convergence to 1; the exclusion of non-trivial cycles requires additional analysis (&sect;8).</p>

<p><b>(2) Incompleteness of cycle conditions.</b> The cycle conditions formulated in &sect;8 are necessary conditions only; sufficient conditions have not been obtained. A complete cycle analysis requires understanding the \(p\)-step composition of m4/m6 patterns, and may benefit from the structural analysis of \(5n+1\) cycles (&sect;8.1&ndash;8.5) as a comparative framework. This is the principal remaining open problem.</p>

<p><b>(3) Cases where \(x-1\) is not a power of 2.</b> Extension to \(x = 7, 11, 13, \ldots\) is in principle possible but adds complexity as additional addition stages arise. This paper does not treat these cases.</p>

<h2>9.5 The Role of "Tool" versus "Result"</h2>

<p>The present paper establishes the structural closure of \(3n+1\) within the 2-bit pair predicate system and derives its consequences. The m4-stage carry structure is fully determined by intra-pair predicates (Theorem 5.1), and this closure is unique to \(x = 3\) (Theorem 5.3). The m4-stage closure determines the input alphabet (four pair types) of a deterministic finite-state transducer that captures the complete scan dynamics, including the m6-stage inter-pair contributions. Within this closed finite-state system, Proposition 5.4 establishes that the mechanism deterministically prevents trajectory divergence.</p>

<h2>9.6 Future Directions</h2>

<p><b>(1) m4/m6 characterization of cycles.</b> Refine the cycle conditions of &sect;8 to derive conditions for non-existence/existence of non-trivial cycles from periodicity of m4/m6 patterns. The structural analysis of \(5n+1\) cycles (&sect;8.1&ndash;8.5), particularly the m4&harr;m6 symmetric relationships observed in Cycle C, may provide structural constraints applicable to the \(3n+1\) case.</p>

<p><b>(2) Dynamical system on m4/m6 space.</b> Formulate \(T: (\text{m4}, \text{m6}) \to (\text{m4}', \text{m6}')\) as a dynamical system and study attractor structure. Showing that the fixed point \((\text{m4}, \text{m6}) = ((0), (1))\) is a global attractor would be equivalent to the Collatz conjecture.</p>

<p><b>(3) Pattern analysis of GPK sequences.</b> Analyze how the m2/m7/m9 bit string of \(n\) is transformed by one step of the scan under \(3n+1\). In particular, how the positions of m9 (Kill, pair \((0,0)\)) evolve along the trajectory governs the reach of carry propagation.</p>

<p><b>(4) Higher-resolution observation spaces.</b> The observation resolution framework (&sect;8.7) reformulates the structural difference between \(3n+1\) and \(x \geq 5\) as a geometric condition: the shift \(s\) versus the observation window width. The central open question is whether a 4-bit observation space provides structural closure for \(5n+1\) (\(s = 2\)), and more generally whether \(2s\)-bit windows suffice for \(x = 2^s + 1\). If closure at the appropriate resolution implies the same structural consequences as for \(3n+1\), this would connect the observation framework to the dynamical differences between convergent and non-convergent Collatz-type maps. The m4&harr;m6 symmetric exchange observed in Cycle C of \(5n+1\) (&sect;8.4) may provide structural constraints visible within a higher-resolution space.</p>

<h2>9.7 Summary of This Section</h2>

<p>This paper has decomposed Collatz-type maps in the framework of a 2-bit pair predicate system, established three foundational theorems (m4-stage coincidence, 16-predicate limitation, Classification Theorem), and derived a structural consequence: within the closed GPK system unique to \(x = 3\), Generate-dominant configurations self-annihilate through the carry mechanism they produce (Proposition 5.4), establishing that no trajectory of \(3n+1\) can diverge. The principal remaining open question is the exclusion of non-trivial cycles (&sect;8, &sect;9.6).</p>

<!-- ============ SECTION 10 ============ -->
<div class="page-break"></div>
<h1>10. Conclusion</h1>

<p>This paper introduced a predicate system based on 2-bit pair decomposition of natural numbers and performed a structural decomposition of Collatz-type maps \(T(n) = (xn+1)/2^d\). We summarize the main results.</p>

<h2>10.1 Summary of Main Results</h2>

<p><b>Result 1: Establishment of the pair predicate system (&sect;2).</b> We decomposed the binary representation of \(n\) into 2-bit pairs and defined a system of 16 Boolean predicates with the left-bit projection m4(LEFT) and right-bit projection m6(RIGHT) as basis. We established completeness, reconstruction from the basis, and per-pair independence.</p>

<p><b>Result 2: Reduction of \(xn+1\) to bit scanning (&sect;3, &sect;4, &sect;7).</b> In the decomposition \(xn+1 = (x-1)n + n + 1\), the left shift of \((x-1)n\) determines reference patterns on the pair structure. Addition at each pair position has a two-stage structure (m6 and m4), and carries are determined by a single \(O(k)\) scan from the LSB. This yields the Unified Algorithm (Algorithm 7.1), which accommodates different parameters \(x\) by simply swapping reference patterns.</p>

<p><b>Result 3: The structural privilege of \(3n+1\) (&sect;5).</b> This is the core result of the paper.</p>

<ul>
<li><b>Theorem B (Theorem 5.1):</b> For \(x=3\), the m4-stage Generate coincides with m2(AND), Propagate with m7(XOR), and Kill with m9(NOR), at every pair position. Carry generation, propagation, and absorption are determined merely by reading the pair type of \(n\).</li>
<li><b>Theorem C (Theorem 5.2):</b> For \(x \geq 5\), the m4-stage GPK cannot be expressed by any Boolean composition of the 16 predicates. This is due to the principled incompatibility between the per-pair independence of the 16 predicates and the inter-position correlations demanded by the map.</li>
<li><b>Classification Theorem (Theorem 5.3):</b> The m4-stage GPK closes within intra-pair predicates only for \(x = 3\). The map \(3n+1\) is the unique Collatz-type map whose carry structure is "transparent" in the 16-predicate space.</li>
<li><b>Proposition 5.4 (Self-annihilation of G-dominance):</b> Within the closed GPK system, Generate-dominant configurations deterministically self-annihilate through the carry propagation they produce. The one-step map decomposes into four phases (scan, \(d\)-determination, trailing zero removal, re-pairing), each structurally closed within the same four pair types. This is derived via exhaustive finite case analysis: a 16-pattern scan transition table (Table 5.1) and a 16-pattern re-pairing transition table (Table 5.2) yield Lemmas 5.1&ndash;5.8, which collectively establish the inseparable coupling of activation condition (G-dominance) and activation result (G-block destruction). The DFST permutation property confirms that no phase structurally biases pair type distribution. Combined with Remark 5.5, this establishes that divergence of \(3n+1\) trajectories is structurally impossible.</li>
</ul>

<p><b>Result 4: Exchange principle of \(\div 2\) (&sect;6).</b> We showed that the \(\div 2\) operation is described as an exchange of the roles of m4 and m6 (Theorem 6.1). The parity of \(d\) determines whether exchange occurs. Information is preserved; \(\div 2\) is positional relocation.</p>

<h2>10.2 Significance</h2>

<p>The results of this paper provide a new perspective on Collatz-type maps.</p>

<p>First, <b>structural decomposition of multiplication</b>. The arithmetic operation \(xn+1\) has been decomposed into bit reference patterns and carry scanning. The value of \(x\) is absorbed as a shift of reference indices and does not appear in the scan stage. While shift+add is equivalent to multiplication at the binary level, our method transparently describes the internal mechanism at the pair level, making the carry structure (GPK) directly observable.</p>

<p>Second, <b>identification of the singularity of \(3n+1\)</b>. To the question "why \(3n+1\)?" this paper presents a structural answer. \(x=3\) is the unique parameter for which the shift amount is less than the pair width, causing the addition to fold back within the pair. As a result, the carry structure is described directly by the intra-pair predicates m2/m7/m9 of \(n\). This "transparency" cannot hold for \(x \geq 5\) in principle.</p>

<p>Third, <b>explicit statement of limitations</b>. The per-pair independence of the 16 predicates is both the strength and the limitation of this framework. Inter-pair correlations&mdash;information that carry propagation of Collatz-type maps essentially requires&mdash;lie outside the 16 predicates. Describing them requires either extending the framework (introducing inter-pair predicates) or employing dynamic operations (scanning). This paper adopted the latter.</p>

<h2>10.3 Outlook</h2>

<p>Proposition 5.4 establishes that no trajectory of \(3n+1\) can diverge. The principal remaining question is:</p>

<ul>
<li>Refining cycle conditions to establish the non-existence of non-trivial cycles (&sect;8, &sect;9.6(1)). The m4/m6 framework provides the structural tools (&sect;8.8), and the comparative analysis of \(5n+1\) cycles (&sect;8.1&ndash;8.5) offers concrete structural constraints.</li>
</ul>

<p>This is the gap between structural impossibility of divergence and the full Collatz conjecture (convergence of all trajectories to 1).</p>

<h2>10.4 Closing</h2>

<p>The Collatz conjecture has resisted resolution for over 80 years despite its elementary formulation. This paper establishes, through the 2-bit pair predicate system, that \(3n+1\) is the unique Collatz-type map whose carry structure closes within intra-pair predicates, and that this closure deterministically prevents trajectory divergence (Proposition 5.4). The full conjecture&mdash;that all trajectories converge to 1&mdash;additionally requires excluding non-trivial cycles, which remains an open problem addressable through the cycle analysis framework of &sect;8.</p>

<p>The author has not proved anything. The 2-bit pair decomposition is a standard grouping of binary digits. The GPK classification is a half-century-old technique from carry-lookahead adder design. The algebraic identity \(3n+1 = 2n + n + 1\) is elementary. Every derivation in this paper consists of substituting known values into known structures and recording what follows. If the structural descriptions presented here have any value, it belongs to the generations of researchers across number theory, computer arithmetic, dynamical systems, and combinatorics whose accumulated work made these observations possible. This paper merely directed an existing lens at an existing problem, revealing structures that may pave the way for further insights.</p>

<!-- ============ REFERENCES ============ -->
<div class="page-break"></div>
<h1>References</h1>

<p>[1] J. C. Lagarias, "The 3x+1 problem and its generalizations," <i>American Mathematical Monthly</i>, vol. 92, no. 1, pp. 3&ndash;23, 1985.</p>

<p>[2] R. K. Guy, <i>Unsolved Problems in Number Theory</i>, 3rd ed. New York: Springer, 2004.</p>

<p>[3] G. J. Wirsching, <i>The Dynamical System Generated by the 3n+1 Function</i>, Lecture Notes in Mathematics, vol. 1681. Berlin: Springer, 1998.</p>

<p>[4] R. Terras, "A stopping time problem on the positive integers," <i>Acta Arithmetica</i>, vol. 30, pp. 241&ndash;252, 1976.</p>

<p>[5] C. J. Everett, "Iteration of the number-theoretic function f(2n)=n, f(2n+1)=3n+2," <i>Advances in Mathematics</i>, vol. 25, pp. 42&ndash;45, 1977.</p>

<p>[6] O. J. Bedrij, "Carry-select adder," <i>IRE Transactions on Electronic Computers</i>, vol. EC-11, no. 3, pp. 340&ndash;346, 1962.</p>

<p>[7] P. M. Kogge and H. S. Stone, "A parallel algorithm for the efficient solution of a general class of recurrence equations," <i>IEEE Transactions on Computers</i>, vol. C-22, no. 8, pp. 786&ndash;793, 1973.</p>

<p>[8] R. P. Brent and H. T. Kung, "A regular layout for parallel adders," <i>IEEE Transactions on Computers</i>, vol. C-31, no. 3, pp. 260&ndash;264, 1982.</p>

<!-- ============ APPENDIX ============ -->
<hr>
<h1>Appendix (Overview)</h1>

<p>The complete version of this paper includes the following appendices.</p>

<p><b>Appendix A: Complete Definition Table of the 16 Predicates.</b> Definitions of m1&ndash;m16, truth tables, expressions in m4/m6, and complement pair correspondences are listed.</p>

<p><b>Appendix B: Complete Computation Trace for \(n=27\).</b> For each step of the \(5n+1\) cycle \(27 \to 17 \to 43 \to 27\), the reference bits, local GPK, carry values, and output bits at every pair position are enumerated. A similar trace is given for the \(3n+1\) trajectory of \(n=27\) (until reaching \(n=1\)).</p>

<p><b>Appendix C: Formal Definition of GPK Tree Composition.</b> Complete derivation of associativity (Proposition 4.3), pseudocode for the binary tree composition algorithm, and complexity analysis.</p>

<p><b>Appendix D: General Derivation of Reference Patterns.</b> General formula for reference bits \((r_i^{(4)}, r_i^{(6)})\) as a function of shift amount \(s\). Discussion of extension to cases where \(x-1\) is not a power of 2.</p>

<p><b>Appendix E: Verification Code.</b> Python implementation of the Unified Algorithm (Algorithm 7.1). Verification scripts confirming agreement with arithmetic computation for \(3n+1\) and \(5n+1\). Exhaustive matching scripts for all 784 predicate combinations (verification of Theorem C).</p>

<hr>
<p style="text-align:center; color:#666; font-size:9pt; margin-top:20pt;">
    Generated: February 2026 (v2)
</p>

</div><!-- end .paper -->
</body>
</html>
