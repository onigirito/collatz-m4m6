<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>collatz-m4m6 Performance Analysis Report</title>
<style>
  body {
    font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
    max-width: 960px;
    margin: 0 auto;
    padding: 2rem;
    line-height: 1.8;
    color: #222;
    background: #fafafa;
  }
  h1 {
    font-size: 1.6rem;
    border-bottom: 3px solid #333;
    padding-bottom: 0.5rem;
    margin-top: 2rem;
  }
  h2 {
    font-size: 1.3rem;
    border-left: 4px solid #4a7c59;
    padding-left: 0.8rem;
    margin-top: 2.5rem;
  }
  h3 {
    font-size: 1.1rem;
    color: #4a7c59;
    margin-top: 2rem;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    margin: 1.2rem 0;
    font-size: 0.92rem;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 0.5rem 0.8rem;
    text-align: left;
  }
  th {
    background: #e8efe8;
    font-weight: 600;
  }
  td.num {
    text-align: right;
    font-family: "Consolas", "Source Code Pro", monospace;
  }
  .meta {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 2rem;
  }
  code {
    font-family: "Consolas", "Source Code Pro", monospace;
    background: #eee;
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    font-size: 0.9em;
  }
  .highlight {
    background: #ffffcc;
    padding: 0.1rem 0.3rem;
  }
  .box {
    background: #f0f5f0;
    border: 1px solid #c5d5c5;
    border-radius: 6px;
    padding: 1rem 1.5rem;
    margin: 1.2rem 0;
  }
  .box-warn {
    background: #fff8f0;
    border: 1px solid #e0c8a0;
  }
  .gpk-stat {
    font-family: "Consolas", "Source Code Pro", monospace;
    font-size: 0.95rem;
    line-height: 2;
  }
  footer {
    margin-top: 3rem;
    padding-top: 1rem;
    border-top: 1px solid #ccc;
    color: #888;
    font-size: 0.85rem;
  }
</style>
</head>
<body>

<h1>collatz-m4m6 Performance Analysis Report</h1>
<p class="meta">
  Structural analysis of the speed gap between pair predicate decomposition scan and u128 direct arithmetic<br>
  2026-02-08 &nbsp;|&nbsp; v0.2.0 &nbsp;|&nbsp; Rust (edition 2021)
</p>

<!-- ========== Section 1 ========== -->
<h2>1. Summary</h2>
<p>
  collatz-m4m6 is an analysis tool based on the m4/m6 pair predicate decomposition
  of the Collatz-type map T(n) = (xn+1)/2<sup>d</sup>.
  In v0.2.0, we introduced a <code>Vec&lt;u64&gt;</code> packed-bit representation and
  a Kogge-Stone parallel prefix scan, achieving a significant structural improvement
  over the sequential scan of the initial v0.1.
</p>
<p>
  However, in measured range verification (sweep) speed,
  u128 direct arithmetic achieves approximately <strong>440 million nums/s</strong>,
  while processing via pair scan is several orders of magnitude slower.
  This report analyzes the structural causes of this speed gap
  and discusses the computational significance and future prospects of pair predicate decomposition.
</p>

<!-- ========== Section 2 ========== -->
<h2>2. Measured Benchmarks</h2>

<h3>2.1 3n+1 Range Verification (50M odd numbers, n &le; 99,999,999, max_steps=1000)</h3>
<p>
  Intel Core i7-12650H (Alder Lake, 10C/16T), 64GB DDR5 environment.
  Measured under 4 conditions: Phase 1 (u128 direct arithmetic) ON/OFF and GPK statistics collection ON/OFF.
</p>
<table>
  <tr><th>Condition</th><th>Elapsed Time</th><th>Speed (nums/s)</th><th>GPK</th><th>Phase1</th></tr>
  <tr><td>u128 only</td><td class="num">0.113s</td><td class="num">~442,000,000</td><td>OFF</td><td>ON</td></tr>
  <tr><td>u128 + GPK statistics</td><td class="num">2.243s</td><td class="num">~22,300,000</td><td>ON</td><td>ON</td></tr>
  <tr><td>Packed only</td><td class="num">9.516s</td><td class="num">~5,250,000</td><td>OFF</td><td>OFF</td></tr>
  <tr><td>Packed + GPK statistics</td><td class="num">12.546s</td><td class="num">~3,990,000</td><td>ON</td><td>OFF</td></tr>
</table>
<p>
  The speed gap between u128 only (0.113s) and Packed only (9.516s) is approximately 84x.
  For 3n+1, nearly all numbers complete within u128 Phase 1, so this gap directly manifests.
  The difference between GPK ON/OFF for u128 is approximately 20x.
</p>

<h3>2.2 5n+1 Range Verification (50K odd numbers, n &le; 99,999, max_steps=1000)</h3>
<p>
  5n+1 contains divergent sequences, so there exist numbers that do not reach a stopping time. Measured under the same 4 conditions.
</p>
<table>
  <tr><th>Condition</th><th>Elapsed Time</th><th>Speed (nums/s)</th><th>GPK</th><th>Phase1</th></tr>
  <tr><td>u128 only</td><td class="num">1.667s</td><td class="num">~30,000</td><td>OFF</td><td>ON</td></tr>
  <tr><td>u128 + GPK statistics</td><td class="num">3.555s</td><td class="num">~14,100</td><td>ON</td><td>ON</td></tr>
  <tr><td>Packed only</td><td class="num">2.118s</td><td class="num">~23,600</td><td>OFF</td><td>OFF</td></tr>
  <tr><td>Packed + GPK statistics</td><td class="num">3.995s</td><td class="num">~12,500</td><td>ON</td><td>OFF</td></tr>
</table>
<p>
  For 5n+1, divergence causes bit length to grow, overflowing u128,
  making the benefit of Phase 1 limited.
  The gap between u128 only (1.667s) and Packed only (2.118s) narrows to 1.27x.
</p>

<h3>2.3 Comparison of Per-Step Instruction Counts</h3>
<p>
  The following shows a comparison of instruction counts per step, normalized to 128-bit width.
</p>
<table>
  <tr><th>Operation</th><th>Instructions / 128bit</th><th>Memory Access</th><th>Branching</th></tr>
  <tr><td>u128 (MUL+ADD+TZCNT+SHR)</td><td class="num">4</td><td>None (register-only)</td><td>None</td></tr>
  <tr><td>BigUint (multi-precision multiply)</td><td class="num">~6</td><td>Vec&lt;u64&gt; heap</td><td>Loop control</td></tr>
  <tr><td>Packed scan (Kogge-Stone)</td><td class="num">~25</td><td>Vec&lt;u64&gt; &times;2 heap</td><td>Word loop</td></tr>
</table>

<!-- ========== Section 3 ========== -->
<h2>3. Structural Reasons Why u128 Is Overwhelmingly Faster</h2>

<h3>3.1 The Hardware Multiplier Barrier</h3>
<p>
  u128 arithmetic is executed directly by the CPU's hardware multiplier circuit.
  Intel Alder Lake's integer multiplication pipeline completes 64bit&times;64bit in 3&ndash;4 clock cycles,
  storing the 128-bit result in a register pair.
  This operation involves no memory access whatsoever and no branches that stall the pipeline.
</p>
<p>
  This is a hardware optimization born from semiconductor design investments on the scale of tens of billions of dollars,
  and it is fundamentally impossible for software-based bit operations to compete on the same level.
</p>

<h3>3.2 The Special Nature of the Collatz Map: Large Number &times; Small Constant</h3>
<p>
  The Collatz-type map is T(n) = (xn+1)/2<sup>d</sup>,
  where x is a small constant such as 3, 5, or 9.
  This corresponds to the multiplication pattern of "large integer &times; small constant,"
  which is the simplest case in multi-precision multiplication.
  BigUint &times; constant requires only 2 instructions (MUL + ADC) per limb and completes in O(n).
  Pair scan is also O(n), so the asymptotic complexity is identical, but BigUint always wins by a constant factor.
</p>

<h3>3.3 The Reality of Sweep: Nearly All Numbers Complete Within u128</h3>
<p>
  In 3n+1 range verification, the vast majority of inputs in the u64 range reach their stopping time
  by dropping below the initial value in an average of 3&ndash;5 steps.
  During this process, values almost never exceed u128 (128 bits),
  so very few numbers transition to pair scan (Phase 2).
  In other words, making sweep faster means making the u128 loop faster,
  and improvements to packed scan contribute almost nothing to sweep speed.
</p>

<!-- ========== Section 4 ========== -->
<h2>4. Optimization History</h2>
<p>
  From v0.1 to v0.2, the pair scan itself has been significantly improved.
  However, this improvement is not in sweep speed but in the efficiency of structural analysis.
</p>
<table>
  <tr><th>Version</th><th>Internal Representation</th><th>Carry Resolution</th><th>Improvement</th></tr>
  <tr><td>v0.1 initial</td><td>Vec&lt;u8&gt; per bit</td><td>Sequential, 1 bit at a time</td><td>Baseline</td></tr>
  <tr><td>v0.1 fast path</td><td>u128 + BigUint</td><td>CPU multiplier</td><td>Sweep made practical</td></tr>
  <tr><td>v0.2 current</td><td>Vec&lt;u64&gt; (64 pairs/word)</td><td>Kogge-Stone (6 stages)</td><td>8x memory improvement</td></tr>
</table>
<p>
  Through packed representation, memory efficiency improved 8x and intra-word carry resolution improved approximately 10x.
  However, the hot path of sweep is u128 Phase 1,
  and these improvements only take effect when Phase 2 is reached.
</p>

<h3>4.1 Optimization of GPK Statistics Collection</h3>
<p>
  A GPK ON/OFF toggle mechanism was introduced so that when statistics are not needed,
  the design completely skips <code>Vec&lt;u64&gt;</code> allocation, store, popcount, and max_carry_chain loops.
  As a result, 3n+1 sweep with GPK OFF runs on u128 arithmetic alone, achieving 442M nums/s.
  On the other hand, with GPK ON, the bit-by-bit loop in <code>accumulate_gpk_u128</code> becomes the bottleneck,
  reducing throughput to 22M nums/s.
  This approximately 20x difference demonstrates the fact that the GPK statistics collection cost itself
  is overwhelmingly heavier than the arithmetic core.
</p>

<!-- ========== Section 5 ========== -->
<h2>5. Crossover Point Analysis</h2>
<p>
  Because pair predicate decomposition does not use multiplication, it holds a structural advantage in asymptotic complexity.
  When bit width becomes sufficiently large, a crossover theoretically exists
  where the linear cost of pair scan becomes advantageous over the superlinear cost of direct multiplication.
</p>
<table>
  <tr><th>Bit Width</th><th>Direct Multiplication</th><th>Pair Scan</th><th>Notes</th></tr>
  <tr><td>~128</td><td>Native MUL O(1)</td><td>Bit operations ~30 instructions</td><td>u128 dominant</td></tr>
  <tr><td>~256</td><td>Multi-precision MUL 4 times + addition</td><td>Kogge-Stone 1 word</td><td>BigUint advantageous</td></tr>
  <tr><td>~1,000</td><td>Karatsuba O(n<sup>1.58</sup>)</td><td>O(n)</td><td>Asymptotically pair advantageous</td></tr>
  <tr><td>~10,000+</td><td>FFT O(n log n)</td><td>O(n), small constant</td><td>Pair scan dominant</td></tr>
</table>

<div class="box box-warn">
<p>
  <strong>Note:</strong>
  The Collatz-type map involves "large number &times; small constant," and BigUint &times; constant also completes in O(n).
  Therefore, unlike general multi-precision multiplication crossover tables,
  when restricted to constant &times; n multiplication, the asymptotic complexity is identical (both O(n)).
  In measured benchmarks, BigUint is approximately 100x faster even at 32,768 bits,
  and the speed crossover in the context of the Collatz map is practically unreachable.
</p>
</div>

<!-- ========== Section 6 ========== -->
<h2>6. The Essential Value of Pair Predicate Decomposition</h2>

<h3>6.1 Structure Visualization: GPK Statistics from 2<sup>33</sup>-Scale Verification</h3>
<p>
  Pair predicate decomposition transparently decomposes each step of the Collatz map
  not as multiplication but as carry propagation in an adder.
  Its byproduct, the GPK classification (Generate/Propagate/Kill),
  quantifies carry generation, propagation, and annihilation at each pair position,
  making the growth/shrinkage mechanism of numbers statistically observable.
</p>
<p>
  The following shows GPK statistics obtained from verifying all 4.99 billion odd numbers
  from 3 to 9,999,999,999 (&asymp; 2<sup>33</sup>) for the 3n+1 map.
</p>

<div class="box">
<p class="gpk-stat">
  G (carry generate) = 113,183,623,064 &ensp;(<strong>38.16%</strong>)<br>
  P (carry propagate) = &ensp;81,071,432,343 &ensp;(<strong>27.34%</strong>)<br>
  K (carry kill) = 102,328,662,110 &ensp;(<strong>34.50%</strong>)<br>
  Total pairs &emsp;&emsp;&emsp;&ensp;= 296,583,717,517<br>
  Total steps &emsp;&ensp;= &ensp;17,463,252,353<br>
  All numbers converged (maximum stopping time 282, n = 2,788,008,987)
</p>
</div>

<p><strong>Carry chain length distribution:</strong></p>
<table>
  <tr><th>Chain Length</th><th>Occurrences</th><th>Chain Length</th><th>Occurrences</th></tr>
  <tr><td class="num">1</td><td class="num">265,878,320</td><td class="num">14</td><td class="num">38,274,610</td></tr>
  <tr><td class="num">2</td><td class="num">1,842,752,124</td><td class="num">15</td><td class="num">22,412,468</td></tr>
  <tr><td class="num">3</td><td class="num">3,494,167,747</td><td class="num">16</td><td class="num">12,790,339</td></tr>
  <tr><td class="num">4</td><td class="num">3,634,880,654</td><td class="num">17</td><td class="num">12,412,547</td></tr>
  <tr><td class="num">5</td><td class="num">2,871,874,977</td><td class="num">18</td><td class="num">2,519,910</td></tr>
  <tr><td class="num">6</td><td class="num">1,991,272,449</td><td class="num">19</td><td class="num">415,078</td></tr>
  <tr><td class="num">7</td><td class="num">1,293,719,531</td><td class="num">20</td><td class="num">69,568</td></tr>
  <tr><td class="num">8</td><td class="num">814,361,343</td><td class="num">21</td><td class="num">11,275</td></tr>
  <tr><td class="num">9</td><td class="num">501,167,658</td><td class="num">22</td><td class="num">1,579</td></tr>
  <tr><td class="num">10</td><td class="num">304,639,101</td><td class="num">23</td><td class="num">337</td></tr>
  <tr><td class="num">11</td><td class="num">183,966,569</td><td class="num">24</td><td class="num">32</td></tr>
  <tr><td class="num">12</td><td class="num">110,232,559</td><td class="num">25</td><td class="num">6</td></tr>
  <tr><td class="num">13</td><td class="num">65,431,568</td><td class="num">26</td><td class="num">4</td></tr>
</table>
<p>
  Despite G% &gt; K%, all numbers converge because
  while G contributes at most 1 bit per occurrence,
  d (division by 2<sup>d</sup>) on average exceeds the effect of G.
  The carry chain length distribution peaks at 4&ndash;5, with a maximum of 26.
  This indicates that carry propagation remains local,
  and long-range propagation is exponentially rare.
</p>
<p>
  These findings &mdash; the locality of carry propagation, the stability of the G/K ratio, and the geometric distribution of chain lengths &mdash;
  are structural information that cannot be directly obtained from a multiplication-based approach,
  and represent the intrinsic value of pair predicate decomposition.
</p>

<h3>6.2 Hardware Implementation Potential</h3>
<p>
  The Kogge-Stone algorithm was originally a design technique for hardware adders, and
  if pair predicate decomposition is implemented on FPGA/ASIC,
  one step of the Collatz map can be completed in O(log n) adder depth without going through a multiplier.
  The advantage of not being constrained to a fixed width also provides natural scalability in circuit design.
</p>
<p>
  However, the claim of this paper is not "achieving the fastest Collatz computation."
  Hardware implementation is presented as one example of the theoretical consistency
  by which this method maps directly to adder structures,
  and the computational significance of pair predicate decomposition should not be reduced to performance comparisons.
</p>

<h3>6.3 Practical Advantage in GPK Statistics Collection</h3>
<p>
  The clear practical advantage of pair predicate decomposition lies in the cost of obtaining GPK statistics.
  From the measured benchmarks (Section 2), we compare the speed difference with and without GPK statistics collection.
</p>
<table>
  <tr><th></th><th>GPK OFF</th><th>GPK ON</th><th>GPK Overhead</th></tr>
  <tr><td>u128 arithmetic</td><td class="num">442M nums/s</td><td class="num">22M nums/s</td><td><span class="highlight">~20x slowdown</span></td></tr>
  <tr><td>Packed scan</td><td class="num">5.25M nums/s</td><td class="num">3.99M nums/s</td><td>~1.3x slowdown</td></tr>
</table>
<p>
  With u128 direct arithmetic, obtaining GPK statistics requires performing bit decomposition
  through a separate path from the multiplication, causing an approximately 20x speed reduction.
  In contrast, with pair scan, GPK is naturally obtained as a byproduct of the scan process,
  so the additional cost remains at only 1.3x.
</p>
<p>
  The effective comparison in scenarios where GPK statistics are needed (i.e., the classification verification of this paper) is:
</p>
<div class="box">
<p>
  u128 + GPK: &ensp;<strong>22M nums/s</strong><br>
  Packed + GPK: <strong>4M nums/s</strong><br>
  Speed gap: <strong>~5.5x</strong> (significantly reduced from the 84x gap when GPK is not needed)
</p>
</div>
<p>
  Pair scan is not "slow but reveals structure";
  rather, it is a method that <strong>"incurs almost no computational speed loss when observing structure."</strong>
</p>
<p>
  What this paper demonstrates is the structural properties of the map, not software benchmark rankings.
  Pair predicate decomposition transparently decomposes the Collatz map as carry propagation in an adder,
  providing GPK statistics as a quantitative analysis tool that comes as a byproduct of computation.
  This is the raison d'etre of this tool and its value as a verification platform for the classification paper.
</p>

<!-- ========== Section 7 ========== -->
<h2>7. Future Prospects</h2>
<p>
  We organize future prospects in two directions: improving pair scan speed and leveraging the structural value of pair predicate decomposition.
</p>
<table>
  <tr><th>Approach</th><th>Overview</th><th>Expected Effect</th><th>Application Domain</th></tr>
  <tr><td>SIMD (AVX2/512)</td><td>Simultaneous processing of multiple words at 256/512-bit width</td><td>Theoretical 4-8x</td><td>Packed scan core</td></tr>
  <tr><td>Inter-word parallelization</td><td>Apply Kogge-Stone across words</td><td>Effective for large numbers</td><td>1000 bits or more</td></tr>
  <tr><td>Sieve</td><td>Skip residue classes proven to converge by GPK classification</td><td>Mathematical reduction</td><td>Sweep overall</td></tr>
  <tr><td>SIMD multi-number parallel</td><td>Simultaneously scan 4 u64 numbers with AVX2</td><td>Theoretical 4x</td><td>Sweep (u64 range)</td></tr>
  <tr><td>FPGA/ASIC implementation</td><td>Implement pair predicate decomposition as adder circuit</td><td>1 clock/step</td><td>Demonstration of theoretical consistency</td></tr>
</table>

<h3>7.1 Most Promising Candidate for Sweep Acceleration: Sieve</h3>
<p>
  Through residue class analysis based on GPK classification,
  if a theorem can be derived stating "this residue class is always K-dominant, therefore convergence is guaranteed,"
  then numbers that can be mathematically skipped can be excluded in advance.
  This is the only pathway where pair predicate decomposition directly contributes to speed,
  and the direction that most strongly justifies the tool's existence.
</p>

<h3>7.2 Packed Scan Acceleration via SIMD</h3>
<p>
  AVX2 (256 bits) can process 4 words simultaneously, and AVX-512 (512 bits) can process 8 words simultaneously.
  SIMD-izing the intra-word operations of Kogge-Stone could theoretically yield a 4&ndash;8x improvement.
  However, as long as the hot path of sweep is u128,
  packed scan acceleration is limited to tracing large numbers.
</p>

<h3>7.3 Parallelization of Inter-Word Carry</h3>
<p>
  In the current implementation, inter-word carry is propagated sequentially
  (<code>carry_out = carry_after &gt;&gt; 63</code> &rarr; to the next word).
  Applying Kogge-Stone across words would improve carry resolution for k words to O(log k).
  This is effective for large numbers of 1000 bits or more, but does not affect the u64 input range of sweep.
</p>

<h3>7.4 FPGA Implementation</h3>
<p>
  Implementing pair predicate decomposition as an adder circuit on FPGA
  and demonstrating 1-clock/step operation without a hardware multiplier
  would serve as verification of this method's circuit-level consistency.
  By placing Kogge-Stone prefix trees in parallel and fixing the wiring for reference patterns,
  a circuit can be constructed that completes an arbitrary-width Collatz step
  in the number of adder stages (O(log n)).
</p>

<!-- ========== Section 8 ========== -->
<h2>8. Conclusion</h2>
<p>
  The measured speed of collatz-m4m6 v0.2.0 is several orders of magnitude slower than u128 direct arithmetic.
  However, this gap is the result of an asymmetric comparison between
  "CPU hardware multiplier vs. software bit operations,"
  and it does not negate the algorithmic value of pair predicate decomposition.
</p>
<p>
  What pair predicate decomposition provides is the transparent decomposition of the Collatz map
  as carry propagation in an adder, offering GPK statistics as a quantitative analysis tool.
  In scenarios where GPK statistics are needed, the overhead of pair scan remains at 1.3x,
  holding a practical advantage over the 20x overhead of u128 arithmetic.
</p>
<p>
  The predicate framework and speed are independent matters.
  The value of this tool lies in visualizing the structure of the Collatz map
  and providing a verification platform for the classification paper.
  Speed is a means to that end, not the end itself.
</p>

<footer>
  collatz-m4m6 v0.2.0 &nbsp;|&nbsp; Rust edition 2021 &nbsp;|&nbsp;
  Intel Core i7-12650H, 64GB DDR5 &nbsp;|&nbsp; 2026-02-08
</footer>

</body>
</html>
