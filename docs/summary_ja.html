<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3n+1 の構造 — ペア分解で見るコラッツ写像</title>
<style>
  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --border: #30363d;
    --text: #c9d1d9;
    --text-muted: #8b949e;
    --accent: #58a6ff;
    --green: #3fb950;
    --red: #f85149;
    --yellow: #d29922;
    --purple: #bc8cff;
    --orange: #f0883e;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', 'Hiragino Kaku Gothic ProN', 'Noto Sans JP', sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.9;
    padding: 2rem;
    max-width: 860px;
    margin: 0 auto;
  }
  h1 {
    font-size: 1.5rem;
    color: var(--accent);
    border-bottom: 1px solid var(--border);
    padding-bottom: 0.5rem;
    margin-bottom: 0.5rem;
  }
  .subtitle {
    color: var(--text-muted);
    font-size: 0.85rem;
    margin-bottom: 2rem;
  }
  h2 {
    font-size: 1.15rem;
    color: var(--purple);
    margin-top: 2.5rem;
    margin-bottom: 1rem;
    padding-left: 0.8rem;
    border-left: 3px solid var(--purple);
  }
  h3 {
    font-size: 1rem;
    color: var(--yellow);
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
  }
  p { margin-bottom: 1rem; }
  code {
    font-family: 'Cascadia Code', 'Consolas', monospace;
    background: var(--surface);
    padding: 0.15em 0.4em;
    border-radius: 3px;
    font-size: 0.9em;
    color: var(--green);
  }
  .box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.2rem 1.5rem;
    margin: 1rem 0;
    font-family: 'Cascadia Code', 'Consolas', monospace;
    font-size: 0.85rem;
    line-height: 2;
    overflow-x: auto;
  }
  .box .label {
    color: var(--text-muted);
    font-size: 0.75rem;
    font-family: 'Segoe UI', sans-serif;
  }
  .hl { color: var(--yellow); font-weight: bold; }
  .hg { color: var(--green); }
  .hr { color: var(--red); }
  .ha { color: var(--accent); }
  .ho { color: var(--orange); }
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
    font-size: 0.88rem;
  }
  th {
    background: var(--surface);
    color: var(--accent);
    font-weight: 600;
    text-align: left;
    padding: 0.6rem 1rem;
    border: 1px solid var(--border);
  }
  td {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
  }
  tr:nth-child(even) td { background: rgba(22,27,34,0.5); }
  .yes { color: var(--green); font-weight: bold; }
  .no { color: var(--red); font-weight: bold; }
  .note {
    background: rgba(88,166,255,0.08);
    border-left: 3px solid var(--accent);
    padding: 0.8rem 1.2rem;
    margin: 1rem 0;
    border-radius: 0 6px 6px 0;
    font-size: 0.9rem;
  }
  .warn {
    background: rgba(248,81,73,0.08);
    border-left: 3px solid var(--red);
    padding: 0.8rem 1.2rem;
    margin: 1rem 0;
    border-radius: 0 6px 6px 0;
    font-size: 0.9rem;
  }
  .causal {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.2rem 1.5rem;
    margin: 1rem 0;
    font-family: 'Cascadia Code', 'Consolas', monospace;
    font-size: 0.82rem;
    line-height: 2.2;
    color: var(--text-muted);
  }
  ul, ol { padding-left: 1.5rem; margin-bottom: 1rem; }
  li { margin-bottom: 0.4rem; }
  .example {
    background: rgba(63,185,80,0.06);
    border-left: 3px solid var(--green);
    padding: 0.8rem 1.2rem;
    margin: 1rem 0;
    border-radius: 0 6px 6px 0;
  }
  .example-title {
    color: var(--green);
    font-weight: bold;
    font-size: 0.85rem;
    margin-bottom: 0.3rem;
  }
  .verified {
    font-size: 0.75rem;
    color: var(--green);
    margin-top: 0.5rem;
  }
  .verified::before { content: "✓ "; }
  .sn { color: var(--text-muted); font-size: 0.85rem; margin-right: 0.3rem; }
  .tag {
    display: inline-block;
    font-size: 0.68rem;
    padding: 0.1em 0.5em;
    border-radius: 3px;
    margin-left: 0.3rem;
    vertical-align: middle;
  }
  .tag-id { background: rgba(63,185,80,0.15); color: var(--green); border: 1px solid rgba(63,185,80,0.3); }
</style>
</head>
<body>

<h1>3n+1 の構造 — ペア分解で見るコラッツ写像</h1>
<p class="subtitle">高校数学＋二進法の知識で読める要約</p>


<!-- ===== 0. 前提 ===== -->
<h2><span class="sn">§0</span> 前提：コラッツ予想とは</h2>

<p>任意の正の整数 n に対して、次の操作を繰り返す：</p>
<ul>
  <li>n が偶数なら → n ÷ 2</li>
  <li>n が奇数なら → 3n + 1</li>
</ul>
<p><strong>「どんな数から始めても、いつか必ず 1 に到達する」</strong>——これがコラッツ予想。1937年に提起されて以来、約90年間未解決。</p>

<div class="example">
  <div class="example-title">例：n = 27</div>
  27 → 82 → 41 → 124 → 62 → 31 → ... → 最高9232まで上がってから → ... → 1 に到達（全111ステップ）
</div>

<p>この論文が問うのは：<strong>3n+1 の計算の「中身」は何か？ なぜ x=3 だけが特別なのか？</strong></p>


<!-- ===== 1. ファスナー構造 ===== -->
<h2><span class="sn">§1</span> ファスナー構造：数を2ビットずつ切る</h2>

<p>任意の正の整数は二進法で書ける。それを<strong>2ビットずつ区切って</strong>ペアにする。</p>

<div class="example">
  <div class="example-title">例：n = 27</div>
  27 = 11011（二進） → 桁数が奇数なので先頭に0を補う → <code>011011</code><br><br>
  2ビットずつ切る：
  <span class="ha">(01)</span> <span class="ho">(10)</span> <span class="hg">(11)</span><br><br>
  各ペアの左ビット（m4）：<code>0, 1, 1</code> → 並べると <code>011</code><br>
  各ペアの右ビット（m6）：<code>1, 0, 1</code> → 並べると <code>101</code>
</div>

<p>ここで重要なのが<strong>ファスナー構造</strong>。m4 と m6 を交互に噛み合わせると元の数に戻る：</p>

<div class="box">
  m4 = <span class="ho">0</span>_<span class="ho">1</span>_<span class="ho">1</span>_ = <span class="ho">0</span>·<span class="ha">1</span>·<span class="ho">1</span>·<span class="ha">0</span>·<span class="ho">1</span>·<span class="ha">1</span> = 011011 = 27 ✓<br>
  m6 = _<span class="ha">1</span>_<span class="ha">0</span>_<span class="ha">1</span>
</div>

<p>もっと単純な例で見ると：</p>

<div class="box">
  <span class="label">m4 だけ（左ビット）</span><br>
  <span class="ho">1</span> 0 <span class="ho">1</span> 0 = <span class="ho">1010</span><br><br>
  <span class="label">m6 だけ（右ビット）</span><br>
  0 <span class="ha">1</span> 0 <span class="ha">1</span> = <span class="ha">0101</span><br><br>
  <span class="label">ファスナーで噛み合わせる</span><br>
  <span class="ho">1</span><span class="ha">1</span><span class="ho">1</span><span class="ha">1</span> = <span class="hl">1111</span><br><br>
  <span class="ho">1010</span> + <span class="ha">0101</span> = <span class="hl">1111</span>
</div>

<p>つまり<strong>どんな数も、m4 と m6 の2本のビット列に分解でき、ファスナーで元に戻せる</strong>。これがペア分解の基本。</p>


<!-- ===== 2. GPK ===== -->
<h2><span class="sn">§2</span> ペアの4種類とGPK</h2>

<p>2ビットのペアは4種類しかない。それぞれに名前をつける：</p>

<table>
  <tr><th>ペア</th><th>名前</th><th>意味</th><th>足し算での役割</th></tr>
  <tr>
    <td><code>(0, 0)</code></td><td><strong>K</strong> (Kill)</td>
    <td>両方0</td><td>繰り上がりを<strong>止める</strong></td>
  </tr>
  <tr>
    <td><code>(0, 1)</code></td><td><strong>P</strong> (Propagate)</td>
    <td>片方だけ1</td><td>繰り上がりを<strong>通す</strong></td>
  </tr>
  <tr>
    <td><code>(1, 0)</code></td><td><strong>P</strong> (Propagate)</td>
    <td>片方だけ1</td><td>繰り上がりを<strong>通す</strong></td>
  </tr>
  <tr>
    <td><code>(1, 1)</code></td><td><strong>G</strong> (Generate)</td>
    <td>両方1</td><td>繰り上がりを<strong>生む</strong></td>
  </tr>
</table>

<p>この G / P / K の分類は、半導体の加算回路（carry-lookahead adder）で1960年代から使われている標準的な概念。</p>

<div class="example">
  <div class="example-title">例：n = 27 = 011011</div>
  ペア列：(0,1), (1,0), (1,1)<br>
  GPK ：<strong>P, P, G</strong><br><br>
  → ペアを見るだけでGPKが分かる。計算不要。ただ読むだけ。
</div>


<!-- ===== 3. 3n+1 の中身 ===== -->
<h2><span class="sn">§3</span> 3n+1 の中身：掛け算せずに表を引く</h2>

<p>3n+1 = 2n + n + 1。ここで 2n は n を<strong>1ビット左にずらしたもの</strong>。つまり：</p>

<div class="box">
  3n + 1 = （nを1ビットずらしたもの）+（n）+（1）
</div>

<p>この足し算は、ペアごとに分解できる。各ペア位置で「どのビットとどのビットを足すか」が決まっていて、結果は<strong>16通りしかない</strong>。</p>

<p>なぜ16通りか：</p>
<ul>
  <li>入力ペアの種類：4通り（K, P, P, G）</li>
  <li>状態：4通り（下記参照）</li>
  <li>合計：4 × 4 = <strong>16通り</strong></li>
</ul>

<h3>「状態」とは何か</h3>
<p>表を引くには、入力ペアの他に<strong>状態</strong>が必要。状態は4つだけ：</p>
<table style="max-width:640px;">
  <tr><th>ラベル</th><th>c<sub>in</sub></th><th>a<sub>i-1</sub></th><th>意味</th></tr>
  <tr><td><strong>S0</strong></td><td>0</td><td>0</td><td>繰り上がりなし、直前の入力ペアの上ビット=0</td></tr>
  <tr><td><strong>S1</strong></td><td>0</td><td>1</td><td>繰り上がりなし、直前の入力ペアの上ビット=1</td></tr>
  <tr><td><strong>S2</strong></td><td>1</td><td>0</td><td>繰り上がりあり、直前の入力ペアの上ビット=0</td></tr>
  <tr><td><strong>S3</strong></td><td>1</td><td>1</td><td>繰り上がりあり、直前の入力ペアの上ビット=1</td></tr>
</table>
<p style="font-size:0.85rem; color:var(--text-muted);">
  c<sub>in</sub> = 直前のペアから来た繰り上がり（carry in）。
  a<sub>i-1</sub> = 直前に処理した入力ペア(a, b)のa。
  c<sub>out</sub> = 今のペアから出る繰り上がり（carry out）→ 次のペアの c<sub>in</sub> になる。
</p>
<p>
  <strong>初期状態 = S2</strong>（+1 による繰り上がりあり、前のペアがないので上ビット=0）。<br>
  <strong>次の状態</strong>は、表の出力（繰り上がりが出たか）と今の入力ペアの上ビットで決まる。表を引けば自動的にわかる。
</p>

<p>この16通りを全部書き出したのが<strong>Table 5.1</strong>（論文の核心）。</p>

<div class="example">
  <div class="example-title">例：n = 71 → n' = 107 を表引きだけで求める</div>
  71 = 01000111₂ → ペア(LSB順)：(1,1), (0,1), (0,0), (0,1)<br>
  GPK：G, P, K, P<br><br>
  初期状態 = <strong>S2</strong><br><br>
  pair 0: G(1,1) + S2 → Case 15 → 出力 P(1,0), carry=1 → 次: <strong>S3</strong> <span style="color:var(--red)">← G破壊、キャリー生成</span><br>
  pair 1: P(0,1) + S3 → Case 8  → 出力 P(0,1), carry=1 → 次: <strong>S2</strong> <span style="color:var(--yellow)">← キャリーが通過</span><br>
  pair 2: K(0,0) + S2 → Case 3  → 出力 P(0,1), carry=0 → 次: <strong>S0</strong> <span style="color:var(--green)">← Kがキャリーを止める</span><br>
  pair 3: P(0,1) + S0 → Case 5  → 出力 G(1,1), carry=0 <span style="color:var(--green)">← P→G生成！連鎖しない</span><br><br>
  出力 = 11010110₂ = 214 → 末尾に0が1個 → d=1 → 214 ÷ 2 = <strong>107</strong><br><br>
  検算：(3×71+1)/2 = 214/2 = 107 ✓<br>
  <strong>掛け算も足し算もしていない。表を4回引いただけ。</strong>
</div>


<h3>Table 5.1：3n+1 の完全なスキャン遷移表</h3>

<p>これが表の全体。この要約の全ての主張はこの表を読めば検証できる。</p>

<div style="overflow-x:auto;">
<table style="font-size:0.78rem; white-space:nowrap;">
  <tr>
    <th>#</th><th>入力</th><th>GPK</th>
    <th>c<sub>in</sub></th><th>a<sub>i-1</sub></th>
    <th>c<sub>out</sub></th>
    <th>出力</th><th>出力GPK</th>
    <th style="color:var(--text-muted)">注目点</th>
  </tr>
  <tr><td>1</td><td>(0,0)</td><td>K</td><td>0</td><td>0</td><td class="yes">0</td><td>(0,0)</td><td>K</td><td></td></tr>
  <tr><td>2</td><td>(0,0)</td><td>K</td><td>0</td><td>1</td><td class="yes">0</td><td>(0,1)</td><td>P</td><td></td></tr>
  <tr><td>3</td><td>(0,0)</td><td>K</td><td>1</td><td>0</td><td class="yes">0</td><td>(0,1)</td><td>P</td><td></td></tr>
  <tr><td>4</td><td>(0,0)</td><td>K</td><td>1</td><td>1</td><td class="yes">0</td><td>(1,0)</td><td>P</td><td style="color:var(--green)">K→Gなし</td></tr>
  <tr style="background:rgba(63,185,80,0.1);"><td>5</td><td>(0,1)</td><td>P</td><td>0</td><td>0</td><td class="yes">0</td><td><strong>(1,1)</strong></td><td><strong style="color:var(--green)">G</strong></td><td style="color:var(--green)">P→G, c<sub>out</sub>=0</td></tr>
  <tr><td>6</td><td>(0,1)</td><td>P</td><td>0</td><td>1</td><td>1</td><td>(0,0)</td><td>K</td><td></td></tr>
  <tr><td>7</td><td>(0,1)</td><td>P</td><td>1</td><td>0</td><td>1</td><td>(0,0)</td><td>K</td><td></td></tr>
  <tr><td>8</td><td>(0,1)</td><td>P</td><td>1</td><td>1</td><td>1</td><td>(0,1)</td><td>P</td><td></td></tr>
  <tr><td>9</td><td>(1,0)</td><td>P</td><td>0</td><td>0</td><td class="yes">0</td><td>(1,0)</td><td>P</td><td></td></tr>
  <tr style="background:rgba(63,185,80,0.1);"><td>10</td><td>(1,0)</td><td>P</td><td>0</td><td>1</td><td class="yes">0</td><td><strong>(1,1)</strong></td><td><strong style="color:var(--green)">G</strong></td><td style="color:var(--green)">P→G, c<sub>out</sub>=0</td></tr>
  <tr style="background:rgba(63,185,80,0.1);"><td>11</td><td>(1,0)</td><td>P</td><td>1</td><td>0</td><td class="yes">0</td><td><strong>(1,1)</strong></td><td><strong style="color:var(--green)">G</strong></td><td style="color:var(--green)">P→G, c<sub>out</sub>=0</td></tr>
  <tr><td>12</td><td>(1,0)</td><td>P</td><td>1</td><td>1</td><td>1</td><td>(0,0)</td><td>K</td><td></td></tr>
  <tr style="background:rgba(248,81,73,0.08);"><td>13</td><td>(1,1)</td><td>G</td><td>0</td><td>0</td><td class="no">1</td><td>(0,1)</td><td>P</td><td style="color:var(--red)">G→P, c<sub>out</sub>=1</td></tr>
  <tr style="background:rgba(248,81,73,0.08);"><td>14</td><td>(1,1)</td><td>G</td><td>0</td><td>1</td><td class="no">1</td><td>(1,0)</td><td>P</td><td style="color:var(--red)">G→P, c<sub>out</sub>=1</td></tr>
  <tr style="background:rgba(248,81,73,0.08);"><td>15</td><td>(1,1)</td><td>G</td><td>1</td><td>0</td><td class="no">1</td><td>(1,0)</td><td>P</td><td style="color:var(--red)">G→P, c<sub>out</sub>=1</td></tr>
  <tr style="background:rgba(248,81,73,0.08);"><td>16</td><td>(1,1)</td><td>G</td><td>1</td><td>1</td><td class="no">1</td><td>(1,1)</td><td>G</td><td style="color:var(--red)">G→G, c<sub>out</sub>=1</td></tr>
</table>
</div>

<p style="font-size:0.85rem; color:var(--text-muted);">
  この表から直接読み取れること：<br>
  <span class="no">■</span> Case 13–16：G入力 → c<sub>out</sub>=1 が<strong>全4ケース</strong>（無条件キャリー生成）<br>
  <span class="yes">■</span> Case 1–4：K入力 → c<sub>out</sub>=0 が<strong>全4ケース</strong>、出力にGなし（K→G不可能）<br>
  <span style="color:var(--green)">■</span> Case 5, 10, 11：P→G — ただし c<sub>out</sub>=0（生成は連鎖しない）
</p>

<!-- ===== 4. n→n' フロー ===== -->
<h2><span class="sn">§4</span> n → n' の完全なフロー</h2>

<div class="box" style="font-size:0.95rem; line-height:2.5; text-align:center;">
  n<br>
  <span class="hl">↓</span> ペア分解<br>
  各ペアのGPK分類 <span style="color:var(--text-muted)">（読むだけ）</span><br>
  <span class="hl">↓</span> Table 5.1 で表引き（16パターン）<br>
  3n+1 のペア列<br>
  <span class="hl">↓</span> 末尾ゼロを数えて d を決定<br>
  <span class="hl">↓</span> ÷ 2<sup>d</sup>（ゼロを除去）<br>
  <span class="hl">↓</span> d が奇数なら再ペアリング <span style="color:var(--text-muted)">（Table 5.2, ファスナーの読み直し）</span><br>
  n'
</div>

<div class="note">
  <strong>外部情報は一切不要。</strong>n のビット列が n' のビット列を完全に決定する。<br>
  GPKは「追加成果物」ではなく、入力ペアに内在する属性。読むだけ。
</div>

<p style="color:var(--text-muted); font-size:0.85rem; margin-top:0.5rem;">
  ※ このフロー図では「n → ペア分解」と「n'」を整数として書いているが、実際の計算では<strong>整数に戻す工程は不要</strong>。スキャンの入力はペア列、出力もペア列。÷2<sup>d</sup> はペアの除去と境界シフト。re-pairing もペア→ペア。次のステップの入力もペア列。<strong>ペア列のまま、1に到達するまで進行する。</strong>結合（ファスナーを閉じる）は人間が数を確認したいときだけ必要になる表示上の操作であり、計算の一部ではない。
</p>


<!-- ===== 5. 閉鎖性 ===== -->
<h2><span class="sn">§5</span> 3n+1 は完全に「閉じている」</h2>

<p>フロー全体で、ペアの種類は<strong>この4種の外に出ない</strong>：</p>

<div class="box" style="text-align:center; font-size:1rem;">
  入力 {K, P01, P10, G} <span class="hl">→</span> スキャン出力 {K, P01, P10, G} <span class="hl">→</span> re-pairing {K, P01, P10, G} <span class="hl">→</span> n' {K, P01, P10, G}
</div>

<p style="font-size:0.9rem;">「閉じている」は「毎回4種が全部登場する」ではない。各ステップで使われる種類は異なりうるが、<strong>5番目の型が発生することは絶対にない</strong>。出力の n' をまた同じ表に入れれば次の n'' が出る。その次も同じ表。<strong>永久に同じ4種と同じ16行の表で回り続ける</strong>。これが閉鎖。</p>

<p>しかも、以下の性質が<strong>例外なく</strong>成り立つ：</p>

<table>
  <tr><th>性質</th><th>3n+1 では</th><th>意味</th></tr>
  <tr>
    <td>G → 繰り上がり出力</td>
    <td class="yes">常に1（全4ケース）</td>
    <td>Gは<strong>必ず</strong>繰り上がりを生む</td>
  </tr>
  <tr>
    <td>K → 繰り上がり出力</td>
    <td class="yes">常に0（全4ケース）</td>
    <td>Kは<strong>必ず</strong>繰り上がりを止める</td>
  </tr>
  <tr>
    <td>K が G に変わるか</td>
    <td class="no">絶対に起きない</td>
    <td>一度Kになったら<strong>Gに戻れない</strong></td>
  </tr>
</table>

<p>「常に」「絶対に」は比喩ではない。16行の表を全部調べた結果、<strong>例外がゼロ</strong>。</p>

<div class="note">
  これは「傾向」や「確率」ではなく、<strong>恒等式</strong>（どんなnでも、どんなビット長でも、毎回成立する代数的事実）。
</div>


<!-- ===== 6. 5n+1 との比較 ===== -->
<h2><span class="sn">§6</span> 5n+1 と比べると何が違うか</h2>

<p>同じ手順で 5n+1 の表も作れる（5n+1 = 4n + n + 1、シフト量2ビット）。作って比べると：</p>

<table>
  <tr>
    <th>性質</th>
    <th>3n+1</th>
    <th>5n+1</th>
  </tr>
  <tr>
    <td>表のサイズ</td>
    <td>16行（4状態×4入力）</td>
    <td>32行（8状態×4入力）</td>
  </tr>
  <tr>
    <td>G → 繰り上がり = 常に1？</td>
    <td class="yes">はい（全件）</td>
    <td class="no">いいえ（1状態で0になる）</td>
  </tr>
  <tr>
    <td>K → 繰り上がり = 常に0？</td>
    <td class="yes">はい（全件）</td>
    <td class="no">いいえ（1状態で1になる）</td>
  </tr>
  <tr>
    <td>K → G の変化</td>
    <td class="yes">起きない</td>
    <td class="no">起きる（2状態で発生）</td>
  </tr>
  <tr>
    <td>逃げ道</td>
    <td class="yes">ない</td>
    <td class="no">ある</td>
  </tr>
  <tr>
    <td>1以外のサイクル</td>
    <td>なし（構造的に排除）</td>
    <td>5n+1では存在（例：13→33→83→13；他のxは未検証）</td>
  </tr>
</table>

<p class="verified">両方の表を実際に構成し、奇数500個で全件検証済み</p>

<div class="warn">
  <strong>ここが核心：</strong>同じ手順で作った2つの表の中身が、質的に違う。<br>
  3n+1 では「逃げ道がない」。5n+1 では「逃げ道がある」。<br>
  この差がサイクルの有無と対応している。
</div>


<!-- ===== 7. なぜ閉じると逃げられないのか ===== -->
<h2><span class="sn">§7</span> なぜ「閉じている」と逃げられないのか</h2>

<h3>成長の条件</h3>
<p>3n+1 で数が大きくなるには、÷2 で1回しか割れない（d=1）必要がある。d=1 になるのは、<strong>一番下のペアが G(1,1) のとき</strong>だけ。</p>
<p style="font-size:0.85rem; color:var(--text-muted);">※ なぜ G(1,1) だけなのか — Syracuse 関数は奇数→奇数の写像なので、入力 n は常に奇数。最下位ビットは必ず1になるため、最下位ペアは P(0,1) か G(1,1) の二択しかない（K(0,0) と P(1,0) は最下位ビットが0なので最下位ペアになれない）。P(0,1) だと 3n+1 の末尾に0が2個以上並び d≥2 で縮小、G(1,1) だと末尾の0はちょうど1個で d=1。</p>

<h3>成長すると何が起きるか</h3>
<p>一番下のペアが G(1,1) で表を引くと（Case 15）：</p>
<ul>
  <li>出力は P(1,0) に変換される → <strong>G が消える</strong></li>
  <li>繰り上がり c<sub>out</sub> = 1 が発生 → <strong>隣も巻き込む</strong></li>
</ul>
<p>つまり<strong>「成長の原因（G）」が「成長を壊す繰り上がり」を必ず生む</strong>。これが表から逃れようがない。</p>

<h3>壊れた後、復活できるか？</h3>

<table>
  <tr><th>経路</th><th>可能か</th><th>性質</th></tr>
  <tr>
    <td>K → G（Killから復活）</td>
    <td class="no">不可能</td>
    <td>表の全16行に K→G なし</td>
  </tr>
  <tr>
    <td>P → G（Propagateから生成）</td>
    <td>可能（3ケース）</td>
    <td>ただし c<sub>out</sub>=0 で<strong>連鎖しない</strong></td>
  </tr>
</table>

<h3>生成と破壊の非対称性</h3>
<table>
  <tr><th></th><th>G の生成（P→G）</th><th>G の破壊（G→P）</th></tr>
  <tr><td>規模</td><td>1個ずつ</td><td>連鎖（隣の橋も壊す）</td></tr>
  <tr><td>繰り上がり</td><td>0（波及しない）</td><td>1（波及する）</td></tr>
  <tr><td>燃料</td><td>Pを消費する</td><td>—</td></tr>
</table>

<p><strong>破壊は連鎖するが、生成は連鎖しない。</strong>この非対称性は16行の表から読み取れる代数的事実。</p>

<h3>scan + re-pairing を合わせた構造的上限（net ≤ 0）</h3>

<p>Table 5.1 と Table 5.2 を合わせて読むと、最左 G-block の1ステップあたりのネット変化に上限がある：</p>

<table>
  <tr><th>フェーズ</th><th>影響</th><th>根拠</th></tr>
  <tr>
    <td>Scan</td>
    <td>先頭 G を除去 → −1</td>
    <td>Table 5.1 (Lemma 5.1(b))</td>
  </tr>
  <tr>
    <td>Re-pairing</td>
    <td>末尾で最大 +1 伸長</td>
    <td>Table 5.2 (Lemma 5.6)</td>
  </tr>
  <tr>
    <td><strong>1ステップ合計</strong></td>
    <td><strong>≤ 0</strong></td>
    <td><strong>全ケース、例外なし</strong></td>
  </tr>
</table>

<p>これは平均ではなく最悪ケースの上限。max(X) ≤ 0 であり、E[X] &lt; 0 ではない。net +1 となる配列は存在しない。</p>

<!-- ===== 7.5 ===== -->
<h2><span class="sn">§7.5</span> なぜ 1 への収束は構造的に不可避か</h2>

<p>§7 で示したのは1回の scan 内の話。しかし re-pairing（Table 5.2）が全部ひっくり返すのでは？ この問いに3点で答える。</p>

<h3>1. re-pairing は閉鎖性を壊さない</h3>

<p>re-pairing の出力も同じ4種のペア（Table 5.2 で全16ケース確認可能）。スキャン → 除算 → re-pairing → 次のスキャン、どの段階でも5番目の型は現れない。§7 で示した表の性質（G→c<sub>out</sub>=1、K→G不可能、P→Gはc<sub>out</sub>=0）は、re-pairing 後の n' にもそのまま適用される。</p>

<h3>2. 連続 d=1 には算術的上限がある（Corollary 5.3）</h3>

<p>表とは独立に、剰余算術だけで導ける事実：</p>

<div class="box">
L 回連続 d=1 には n ≡ 2<sup>L+1</sup>−1 (mod 2<sup>L+1</sup>) が必要、<br>
すなわち n の下位 L+1 ビットがすべて 1 でなければならない。<br><br>
n のビット数は高々 ⌊log<sub>2</sub> n⌋ + 1 なので、<br>
<strong>連続 d=1 の最大回数 ≤ ⌊log<sub>2</sub> n⌋。</strong>
</div>

<p>成長（d=1）は必ず有限回で止まる。これは GPK とも表とも無関係な算術的事実。</p>

<h3>3. 有限の箱の中に逃げ場はない</h3>

<p>d=1 が持続できないので軌道は発散しない（有界）。閉鎖性により、軌道がどこにいても同じ表・同じ制約が適用される（スケール不変）。有界な軌道が閉じたスケール不変な系の中で取りうる終状態は、サイクルだけ。x=3 では構造的に許容されるサイクルは n=1 の不動点のみ（§8.4）。</p>

<div class="note">
  n=1 はペア P(0,1)、d=2、n'=1。不動点。<br>
  軌道は一時的に大きく増加しうる（例：n=27 は奇数ステップで 3077 まで上昇する；§0の9232は3×3077+1の偶数値）。しかし d=1 が持続不可能である以上、発散は不可能。
</div>

<p style="font-size:0.85rem; color:var(--text-muted);">論文本体の Proposition 5.4 では、G-block の左端消滅（net ≤ 0）、次元分離、エピソード構造など、表の性質からの詳細な導出を与えている。上の3点はその結論の核心部分。</p>


<!-- ===== 8. 因果の連鎖 ===== -->
<h2><span class="sn">§8</span> 全体像：閉鎖性 → 自壊 → 脱出不可能</h2>

<div class="box" style="font-size:0.82rem; line-height:2.2;">
<pre style="margin:0; font-family:inherit; color:var(--text-muted); white-space:pre-wrap;">
<span style="color:var(--text)">3n+1 = 2n + n + 1（シフト量1ビット &lt; ペア幅2ビット）</span>
<span style="color:var(--accent)">  └→</span> <span style="color:var(--text)">GPK分類がペアを読むだけで確定する（閉鎖性）</span>
<span style="color:var(--accent)">      └→</span> <span style="color:var(--text)">繰り上がり挙動が状態に依存しない</span>
<span style="color:var(--accent)">          ├→</span> <span style="color:var(--text)">G は無条件に繰り上がりを生む</span>
<span style="color:var(--accent)">          │   └→</span> <span style="color:var(--green)">その繰り上がりが G 自身を破壊する</span>
<span style="color:var(--accent)">          ├→</span> <span style="color:var(--text)">K は無条件に繰り上がりを止める</span>
<span style="color:var(--accent)">          │   └→</span> <span style="color:var(--green)">K が G に戻ることもない</span>
<span style="color:var(--accent)">          └→</span> <span style="color:var(--yellow)"><strong>成長の源（G）＝ 成長の破壊者。逃げ道なし。</strong></span>
</pre>
</div>

<p>n=1 はペア (0,1)=P で、d=2、n'=1。<strong>不動点</strong>。他の全ての n は上記の制約により、この不動点に向かう以外の構造を持てない。</p>

<div class="note">
  5n+1 では閉鎖性がないため、G が繰り上がりを出さない状態がある（逃げ道）。K が G に変わることもある（復活）。だから 5n+1 には 13→33→83→13 のような非自明サイクルが存在できる。
</div>


<!-- ===== 9. 確率ではない ===== -->
<h2><span class="sn">§9</span> これは「確率的に縮みやすい」という話ではない</h2>

<p>よくある議論：「3n+1 は平均的に ÷2 の回数が多いから縮む」。しかしこれは確率論なので「運が悪ければ発散するかも」と反論できる。</p>

<p>この論文の議論はそれとは<strong>別の層</strong>にある：</p>

<table>
  <tr><th></th><th>確率的な主張</th><th>この論文の主張</th></tr>
  <tr>
    <td>内容</td>
    <td>「平均的に d が大きいから縮みやすい」</td>
    <td>「G は<strong>無条件で</strong>繰り上がりを出す」</td>
  </tr>
  <tr>
    <td>反論</td>
    <td class="no">「分散で偏れるかも」→ 有効</td>
    <td class="yes">分散がない。全位置、全n、毎回成立</td>
  </tr>
</table>

<ul>
  <li>G → c<sub>out</sub>=1 は「傾向」ではなく<strong>恒等式</strong></li>
  <li>K → G 不可能は「稀」ではなく<strong>ゼロ</strong></li>
  <li>P → G の c<sub>out</sub>=0 は「大体」ではなく<strong>全件</strong></li>
</ul>

<h3>ネット ≤ 0：構造的上限 vs. 確率的傾向</h3>

<p>G-block のネット変化（§7）で、この区別は特に明確になる：</p>

<table>
  <tr><th></th><th>確率的議論</th><th>ネット ≤ 0（本論文）</th></tr>
  <tr>
    <td>主張</td>
    <td>「平均的に G は減る」</td>
    <td>「全ケースで最左 G-block の1ステップあたりネット ≤ 0」</td>
  </tr>
  <tr>
    <td>定式化</td>
    <td>E[X] &lt; 0</td>
    <td>max(X) ≤ 0</td>
  </tr>
  <tr>
    <td>反例の可能性</td>
    <td class="no">あり — 分散が外れ値を許容</td>
    <td class="yes">なし — 最大値が既に ≤ 0</td>
  </tr>
</table>

<p>ネット ≤ 0 は G の総量が単調に減ることを意味<strong>しない</strong>。新しい G-block は生まれうるし（P→G）、÷2<sup>d</sup> が非 G ペアを除去すれば G 密度は上昇する — 100% に戻ることすらある。ネット ≤ 0 が保証するのは、<strong>個々の最左 G-block の寿命が有限</strong>であること：各 d=1 連続（成長バースト）は必ず終わり、終わった後に d≥2 の崩壊が来る。</p>


<!-- ===== 10. まとめ ===== -->
<h2><span class="sn">§10</span> 表ができた時点で、結論は表の中にある</h2>

<p>Table 5.1（スキャン16行）と Table 5.2（再ペアリング16行）が構成された時点で：</p>

<table>
  <tr><th>読み取れること</th><th>方法</th></tr>
  <tr><td>G → c<sub>out</sub>=1（例外なし）</td><td>表から読める</td></tr>
  <tr><td>K → G は不可能（例外なし）</td><td>表から読める</td></tr>
  <tr><td>P → G は c<sub>out</sub>=0（例外なし）</td><td>表から読める</td></tr>
  <tr><td>G-block が合流しない</td><td>表から読める</td></tr>
</table>

<p>論文の Lemma（補題）や Proposition（命題）は、<strong>表に既に書いてあることを言語化しているだけ</strong>。</p>

<div class="note">
  <strong>この論文の実質的な仕事は4つ：</strong>
  <ol style="padding-left:1.2rem; margin-top:0.5rem;">
    <li>3n+1 が16行の表で完全に記述できると認識したこと</li>
    <li>その表を構成したこと</li>
    <li>表の性質を読み取ったこと（G常に繰り上がり、K→G不可能、etc.）</li>
    <li>5n+1 と比較して「3n+1 だけが特殊」と確認したこと</li>
  </ol>
  <p style="font-size:1.15rem; color:var(--yellow); font-weight:bold; margin-top:1rem; margin-bottom:0;">結論：何もしてない！</p>
  <p style="font-size:0.85rem; color:var(--text-muted); margin-top:0.3rem;">構造は最初からそこにあった。</p>
</div>


<!-- footer -->
<p style="margin-top:3rem; color:var(--text-muted); font-size:0.78rem; border-top:1px solid var(--border); padding-top:1rem;">
  検証スクリプト: dfst_final.py, dfst_properties.py<br>
  構造比較データ: dfst_comparison_record.md<br>
  元論文: "Pair Predicate Decomposition of Collatz-type Maps (xn+1)/2<sup>d</sup>" v5.1 (February 2026)
</p>

</body>
</html>
